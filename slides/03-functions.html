<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 3: 함수 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 3, 함수입니다. 이 챕터에서는 함수 매개변수와 반환 타입 어노테이션, 선택적 매개변수와 기본값, 나머지 매개변수, 함수 오버로드, 콜백과 고차 함수, 그리고 제네릭 함수까지 학습합니다. 함수는 프로그래밍의 기본 단위이므로 타입 시스템을 정확히 이해하는 것이 매우 중요합니다.">
        <span class="chapter-number">Chapter 03</span>
        <h1>함수</h1>
        <p class="subtitle">TypeScript 함수의 타입 시스템 완전 이해</p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.6em;">&#8592; 목차로 돌아가기</a></p>
      </section>

      <!-- Slide 2: Function Type Annotations -->
      <section data-transition="slide" data-narration="함수의 매개변수와 반환 타입에 어노테이션을 붙여 타입 안전성을 확보합니다. 코드에서 add 함수는 매개변수 a와 b에 number를, 반환값에도 number를 지정했습니다. multiply처럼 반환 타입은 생략하면 자동 추론됩니다. 이렇게 타입을 지정하면 문자열 1을 전달하거나 인수 개수를 틀리면 즉시 컴파일 에러가 발생합니다. 매개변수 타입은 반드시 명시하고, 반환 타입은 추론에 맡겨도 괜찮습니다.">
        <h2>함수 타입 어노테이션 (Type Annotation)</h2>
        <p>매개변수 (Parameter, 함수에 전달하는 입력값)와 반환 타입 (Type)을 명시적으로 지정합니다.</p>
        <pre><code class="language-typescript">// 매개변수 타입 + 반환 타입
function add(a: number, b: number): number {
  return a + b;
}

// 반환 타입 추론 (명시하지 않아도 OK)
function multiply(a: number, b: number) {
  return a * b;  // number로 자동 추론
}

// 문자열을 반환하는 함수
function greet(name: string): string {
  return `안녕하세요, ${name}님!`;
}

// 타입 에러 예시
add("1", 2);         // Error! string은 number에 할당 불가
add(1, 2, 3);        // Error! 매개변수 2개만 허용
greet(42);           // Error! number는 string에 할당 불가</code></pre>

        <div class="fragment tip">
          <strong>Tip:</strong> 매개변수 타입은 반드시 명시하세요. 반환 타입은 추론에 맡겨도 괜찮습니다.
        </div>
      </section>

      <!-- Slide 3: Arrow Functions -->
      <section data-transition="slide" data-narration="화살표 함수에도 동일하게 타입을 지정할 수 있습니다. 코드에서 add 화살표 함수는 매개변수와 반환 타입을 명시했고, double은 한 줄로 간결하게 작성했습니다. MathOperation이라는 타입 별칭을 정의하면, subtract와 divide 같은 함수에 동일한 타입을 재사용할 수 있습니다. 이 함수들을 배열에 넣어 반복 실행하는 것도 가능합니다. 타입 별칭으로 함수 타입을 정의하는 것이 가장 권장되는 패턴입니다.">
        <h2>화살표 함수와 타입</h2>
        <pre><code class="language-typescript">// 기본 화살표 함수: (매개변수): 반환타입 => { 본문 }
const add = (a: number, b: number): number => {
  return a + b;
};

// 한 줄 표현식 (중괄호와 return 생략 가능)
const double = (n: number): number => n * 2;

// 함수 타입을 변수에 먼저 선언하고, 나중에 구현
const greet: (name: string) => string = (name) => {
  return `Hello, ${name}!`;
};

// 타입 별칭 (Type Alias)으로 함수 타입 정의 (권장)
type MathOperation = (a: number, b: number) => number;

const subtract: MathOperation = (a, b) => a - b;
const divide: MathOperation = (a, b) => a / b;

// 함수 배열도 가능
const operations: MathOperation[] = [add, subtract, divide];
operations.forEach(op => console.log(op(10, 3)));</code></pre>
      </section>

      <!-- Slide 4: Optional Parameters -->
      <section data-transition="slide" data-narration="매개변수 이름 뒤에 물음표를 붙이면 선택적 매개변수가 됩니다. 코드에서 greet 함수의 greeting 매개변수는 물음표가 붙어 있어 호출 시 생략할 수 있습니다. 생략하면 undefined가 되므로 논리 OR 연산자로 기본값을 설정합니다. createUser처럼 여러 선택적 매개변수를 사용할 때는 undefined 체크가 필요합니다. 중요한 규칙은 선택적 매개변수가 반드시 필수 매개변수 뒤에 와야 한다는 것입니다.">
        <h2>선택적 매개변수</h2>
        <pre><code class="language-typescript">// ? 를 붙이면 선택적 매개변수 (호출 시 생략 가능)
function greet(name: string, greeting?: string): string {
  // greeting의 타입: string | undefined (값이 없을 수 있음)
  return `${greeting || "안녕하세요"}, ${name}님!`;
}

greet("홍길동");              // "안녕하세요, 홍길동님!"
greet("홍길동", "반갑습니다");  // "반갑습니다, 홍길동님!"

// 여러 선택적 매개변수
function createUser(
  name: string,
  age?: number,
  email?: string
): void {
  console.log(name);
  if (age !== undefined) console.log(`나이: ${age}`);
  if (email !== undefined) console.log(`이메일: ${email}`);
}</code></pre>

        <div class="warning">
          <strong>규칙:</strong> 선택적 매개변수는 반드시 필수 매개변수 <strong>뒤에</strong> 와야 합니다.
          <code>function bad(x?: number, y: number)</code>는 에러입니다.
        </div>
      </section>

      <!-- Slide 5: Default Parameters -->
      <section data-transition="slide" data-narration="매개변수에 기본값을 지정하면 인수를 생략했을 때 기본값이 사용됩니다. 코드에서 greet 함수의 greeting 매개변수에 안녕하세요를 기본값으로 설정했습니다. createConfig처럼 여러 매개변수에 기본값을 주면 타입이 자동 추론되어 별도 어노테이션이 불필요합니다. format 함수에서 보듯이 중간 매개변수를 건너뛰려면 undefined를 전달하면 됩니다. 선택적 매개변수보다 기본값 매개변수가 더 실용적인 경우가 많습니다.">
        <h2>기본값 매개변수</h2>
        <pre><code class="language-typescript">// 기본값이 있으면 타입을 추론하고, 생략 가능
function greet(name: string, greeting: string = "안녕하세요"): string {
  return `${greeting}, ${name}님!`;
}

greet("홍길동");              // "안녕하세요, 홍길동님!"
greet("홍길동", "환영합니다"); // "환영합니다, 홍길동님!"

// 기본값에서 타입 추론
function createConfig(
  port: number = 3000,
  host: string = "localhost",
  debug: boolean = false
) {
  return { port, host, debug };
}

// 기본값은 중간에도 올 수 있음 (undefined로 건너뛰기)
function format(
  value: number,
  prefix: string = "$",
  suffix: string = ""
): string {
  return `${prefix}${value}${suffix}`;
}

format(100);                   // "$100"
format(100, undefined, "원");  // "$100원"
format(100, "\\", "");          // "\\100"</code></pre>
      </section>

      <!-- Slide 6: Rest Parameters -->
      <section data-transition="slide" data-narration="나머지 매개변수는 점 세 개로 표시하며, 개수가 정해지지 않은 인수를 배열로 받습니다. 코드에서 sum 함수는 numbers를 number 배열 타입으로 받아 reduce로 모두 더합니다. 인수를 1개든 5개든 자유롭게 전달할 수 있습니다. log 함수처럼 일반 매개변수와 함께 사용할 수도 있고, createUser처럼 튜플과 결합하면 나머지 요소의 타입과 개수를 정확히 지정할 수 있습니다.">
        <h2>나머지 매개변수 (Rest Parameters)</h2>
        <pre><code class="language-typescript">// ...args로 가변 인수 받기 (개수 제한 없이 여러 개를 배열로 받음)
function sum(...numbers: number[]): number {
  return numbers.reduce((total, n) => total + n, 0); // 모든 숫자를 더함
}

sum(1, 2, 3);           // 6
sum(1, 2, 3, 4, 5);     // 15
sum();                   // 0

// 일반 매개변수 + 나머지 매개변수
function log(level: string, ...messages: string[]): void {
  console.log(`[${level}]`, ...messages);
}

log("INFO", "서버 시작", "포트: 3000");
log("ERROR", "연결 실패");

// 튜플과 함께 사용
function createUser(
  name: string,
  ...info: [age: number, email: string]
): void {
  const [age, email] = info;
  console.log(`${name}, ${age}, ${email}`);
}

createUser("Kim", 25, "kim@example.com");</code></pre>
      </section>

      <!-- Slide 7: Function Overloads -->
      <section data-transition="slide" data-narration="함수 오버로드는 같은 이름의 함수가 입력 타입에 따라 다른 반환 타입을 가질 수 있게 합니다. 코드에서 createElement 함수는 a를 전달하면 HTMLAnchorElement를, canvas를 전달하면 HTMLCanvasElement를 반환합니다. 오버로드 시그니처를 여러 개 선언한 뒤 마지막에 구현부를 작성합니다. 이렇게 하면 호출 시 반환 타입이 정확하게 추론되어 link.href나 canvas.getContext 같은 메서드를 안전하게 사용할 수 있습니다.">
        <h2>함수 오버로드 (Overload)</h2>
        <p>같은 함수명으로 다른 매개변수 타입에 따라 다른 반환 타입을 제공합니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">하나의 함수가 여러 가지 "사용 설명서"를 가지는 것과 같습니다.</span></p>
        <pre><code class="language-typescript">// 오버로드 시그니처 (Signature, 함수의 입출력 형태 선언)
function createElement(tag: "a"): HTMLAnchorElement;
function createElement(tag: "canvas"): HTMLCanvasElement;
function createElement(tag: "input"): HTMLInputElement;
function createElement(tag: string): HTMLElement;

// 구현부 (실제 로직)
function createElement(tag: string): HTMLElement {
  return document.createElement(tag);
}

// 호출 시 반환 타입이 정확하게 추론
const link = createElement("a");       // HTMLAnchorElement
const canvas = createElement("canvas"); // HTMLCanvasElement
const div = createElement("div");       // HTMLElement

link.href = "https://example.com";  // OK (HTMLAnchorElement)
canvas.getContext("2d");             // OK (HTMLCanvasElement)</code></pre>
      </section>

      <!-- Slide 8: Overload practical example -->
      <section data-transition="slide" data-narration="코드에서 parseValue 함수는 문자열 하나를 받으면 number를, 문자열 배열을 받으면 number 배열을 반환합니다. Array.isArray로 배열 여부를 판별하여 분기합니다. formatDate 함수는 매개변수 개수에 따라 다른 오버로드를 제공합니다. 타임스탬프 하나를 받거나 년, 월, 일 세 개를 받아 각각 다른 포맷으로 날짜를 반환합니다. 이처럼 오버로드는 다양한 입력 형태를 하나의 함수로 안전하게 처리할 수 있게 합니다.">
        <h2>함수 오버로드 실전 예제</h2>
        <pre><code class="language-typescript">// 입력 타입에 따라 반환 타입이 달라지는 경우
function parseValue(value: string): number;
function parseValue(value: string[]): number[];
function parseValue(value: string | string[]): number | number[] {
  if (Array.isArray(value)) {
    return value.map(v => parseInt(v, 10));
  }
  return parseInt(value, 10);
}

const single = parseValue("42");          // number
const multiple = parseValue(["1", "2"]);  // number[]

// 매개변수 개수가 다른 오버로드
function formatDate(timestamp: number): string;
function formatDate(year: number, month: number, day: number): string;
function formatDate(yearOrTimestamp: number, month?: number, day?: number): string {
  if (month !== undefined && day !== undefined) {
    return `${yearOrTimestamp}-${month}-${day}`;
  }
  return new Date(yearOrTimestamp).toISOString();
}

formatDate(1700000000000);    // "2023-11-14T..."
formatDate(2024, 1, 15);     // "2024-1-15"</code></pre>
      </section>

      <!-- Slide 9: void vs undefined -->
      <section data-transition="slide" data-narration="void와 undefined의 차이를 이해해야 합니다. 왼쪽 코드에서 void는 반환값을 사용하지 않겠다는 의미이며, 콜백 타입에서 void를 쓰면 실제로 값을 반환해도 무시됩니다. 이것이 forEach 콜백이 동작하는 원리입니다. 오른쪽의 undefined는 정확히 undefined를 반환해야 하며, return문이 없으면 에러입니다. 함수가 값을 반환하지 않을 때는 void를, 명시적으로 undefined를 반환할 때만 undefined 타입을 사용하세요.">
        <h2>void vs undefined 반환</h2>
        <div class="two-columns">
          <div>
            <h3 style="font-size: 1em; color: var(--ts-blue);">void</h3>
            <pre><code class="language-typescript">// void: "반환값을 사용하지 않겠다"
function logMessage(msg: string): void {
  console.log(msg);
}

// 콜백에서의 void는 특별함
type Callback = () => void;

// 반환값이 있어도 무시됨!
const cb: Callback = () => {
  return 42; // OK! void 콜백이라 반환값 무시
};

// void 콜백의 반환값은 사용 불가
const result: void = cb();
// result를 숫자처럼 사용할 수 없음</code></pre>
          </div>
          <div>
            <h3 style="font-size: 1em; color: var(--ts-green);">undefined</h3>
            <pre><code class="language-typescript">// undefined: 정확히 undefined를 반환
function nothing(): undefined {
  return undefined; // 반드시 명시
}

// return 없으면 에러
function bad(): undefined {
  // Error! 반환문이 필요
}

// 실제 차이점 예시
const arr = [1, 2, 3];

// forEach 콜백은 void 반환
arr.forEach((n): void => {
  console.log(n);
  // return 있어도 OK
});

// map에서는 반환 타입이 중요
arr.map((n): number => {
  return n * 2;
});</code></pre>
          </div>
        </div>
      </section>

      <!-- Slide 10: Callback Types -->
      <section data-transition="slide" data-narration="콜백 함수의 타입을 정확하게 정의하면 타입 안전성을 확보할 수 있습니다. 코드에서 SuccessCallback은 data 문자열을 받는 함수 타입이고, ErrorCallback은 Error 객체를 받는 함수 타입입니다. fetchData 함수에 이 콜백들을 전달하면, 콜백 내부에서 매개변수 타입이 자동으로 추론됩니다. 이벤트 핸들러도 동일한 패턴으로, event 객체의 type과 target 속성에 안전하게 접근할 수 있습니다.">
        <h2>콜백 (Callback) 함수 타입</h2>
        <p style="font-size: 0.85em; color: #aaa;">콜백이란 "나중에 호출해줘"라고 다른 함수에 전달하는 함수입니다. 특정 작업이 끝난 후 실행됩니다.</p>
        <pre><code class="language-typescript">// 콜백 타입 정의
type SuccessCallback = (data: string) => void;
type ErrorCallback = (error: Error) => void;

function fetchData(
  url: string,
  onSuccess: SuccessCallback,
  onError: ErrorCallback
): void {
  try {
    // ... 데이터 가져오기
    onSuccess("데이터 로드 완료!");
  } catch (e) {
    onError(e as Error);
  }
}

// 사용 예시
fetchData(
  "/api/users",
  (data) => console.log(data),      // data: string
  (error) => console.error(error)    // error: Error
);

// 이벤트 핸들러 타입
type EventHandler = (event: { type: string; target: HTMLElement }) => void;

const handleClick: EventHandler = (event) => {
  console.log(`${event.type} on ${event.target.tagName}`);
};</code></pre>
      </section>

      <!-- Slide 11: Higher Order Functions -->
      <section data-transition="slide" data-narration="고차 함수는 함수를 매개변수로 받거나 함수를 반환하는 함수입니다. 코드에서 createMultiplier는 factor를 받아 숫자를 factor배로 만드는 함수를 반환합니다. double과 triple은 각각 2배, 3배 함수가 됩니다. applyToArray는 제네릭으로 배열과 변환 함수를 받아 map을 적용하며, 입력과 출력 타입이 자동으로 추론됩니다. 이렇게 고차 함수의 타입을 정확하게 표현하면 함수 합성 패턴을 안전하게 구현할 수 있습니다.">
        <h2>고차 함수 (Higher Order Function) 타입</h2>
        <p>함수를 매개변수로 받거나 반환하는 함수입니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">마치 "함수를 만들어주는 공장"처럼, 함수 자체를 값으로 다룹니다.</span></p>
        <pre><code class="language-typescript">// 함수를 반환하는 함수
function createMultiplier(factor: number): (n: number) => number {
  return (n: number) => n * factor;
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

double(5);  // 10
triple(5);  // 15

// 함수를 매개변수로 받는 함수
function applyToArray&lt;T, U&gt;(
  arr: T[],
  fn: (item: T, index: number) => U
): U[] {
  return arr.map(fn);
}

const numbers = [1, 2, 3, 4];
const strings = applyToArray(numbers, (n) => n.toString());
// strings: string[] = ["1", "2", "3", "4"]

const doubled = applyToArray(numbers, (n) => n * 2);
// doubled: number[] = [2, 4, 6, 8]</code></pre>
      </section>

      <!-- Slide 12: Generic Functions Intro -->
      <section data-transition="slide" data-narration="제네릭 함수는 꺾쇠 T처럼 타입을 매개변수로 전달받아 다양한 타입에서 재사용 가능한 함수를 만듭니다. 코드에서 first 함수는 타입 매개변수 T를 받아 T 배열의 첫 요소를 반환합니다. 문자열 배열을 전달하면 T가 string이 되고, 숫자 배열을 전달하면 T가 number가 됩니다. 타입이 자동 추론되지만 꺾쇠 안에 명시적으로 지정할 수도 있습니다. 제네릭 없이는 타입마다 별도 함수를 만들어야 하므로 코드 중복이 심해집니다.">
        <h2>제네릭 (Generic) 함수 입문</h2>
        <div class="key-point">
          <h3>핵심 개념</h3>
          <p>제네릭은 <strong>타입을 매개변수로</strong> 받아, 다양한 타입에서 재사용 가능한 함수를 만듭니다.<br>
          <span style="font-size: 0.85em;">비유하면, "어떤 타입이든 담을 수 있는 만능 상자"를 만드는 것과 같습니다.</span></p>
        </div>
        <pre><code class="language-typescript">// 문제: 모든 타입에 대해 동일한 로직을 반복해야 함
function firstString(arr: string[]): string | undefined {
  return arr[0];
}
function firstNumber(arr: number[]): number | undefined {
  return arr[0];
}

// 해결: 제네릭으로 한 번만 작성 (&lt;T&gt;가 "타입 매개변수")
function first&lt;T&gt;(arr: T[]): T | undefined {
  return arr[0]; // T가 어떤 타입이든 첫 번째 요소 반환
}

// 타입이 자동 추론됨 (전달한 배열의 타입을 보고 T를 결정)
const a = first(["hello", "world"]);  // T=string -> string | undefined
const b = first([1, 2, 3]);           // T=number -> number | undefined

// 명시적으로 타입 지정도 가능
const c = first&lt;boolean&gt;([true, false]); // T=boolean -> boolean | undefined</code></pre>
      </section>

      <!-- Slide 13: More Generic Examples -->
      <section data-transition="slide" data-narration="제네릭을 더 깊이 활용해 봅시다. 코드에서 pair 함수는 타입 매개변수 A와 B를 받아 두 값을 튜플로 묶습니다. getProperty 함수는 T와 K extends keyof T 제약 조건을 사용하여, 객체에 존재하는 키만 전달할 수 있게 합니다. email 같은 없는 키를 넣으면 컴파일 에러가 발생합니다. toArray 함수는 단일 값이든 배열이든 항상 배열로 변환합니다. 이처럼 제네릭과 제약 조건을 결합하면 매우 정밀한 타입 안전성을 확보할 수 있습니다.">
        <h2>제네릭 함수 활용</h2>
        <pre><code class="language-typescript">// 여러 타입 매개변수
function pair&lt;A, B&gt;(first: A, second: B): [A, B] {
  return [first, second];
}

const p = pair("hello", 42);  // [string, number]

// 제네릭 + 제약 조건
function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Kim", age: 25 };
const name = getProperty(user, "name");  // string
const age = getProperty(user, "age");    // number
// getProperty(user, "email");  // Error! "email"은 keyof User가 아님

// 제네릭 유틸리티 함수
function toArray&lt;T&gt;(value: T | T[]): T[] {
  return Array.isArray(value) ? value : [value];
}

toArray("hello");          // string[]
toArray([1, 2, 3]);        // number[]</code></pre>
      </section>

      <!-- Slide 14: Common Patterns -->
      <section data-transition="slide" data-narration="실전에서 자주 쓰이는 함수 타입 패턴 두 가지를 살펴봅시다. 첫 번째는 옵션 객체 패턴으로, FetchOptions 인터페이스에 method, headers, body, timeout을 선택적 속성으로 정의하고 기본값과 함께 사용합니다. 두 번째는 빌더 패턴으로, createQueryBuilder가 this를 반환하여 select, from, where를 체이닝으로 연결합니다. 이러한 패턴들의 타입을 정확하게 정의하면 IDE 자동 완성이 완벽하게 동작합니다.">
        <h2>함수 타입 실전 패턴</h2>
        <pre><code class="language-typescript">// 패턴 1: 옵션 객체 매개변수 (설정값을 객체로 묶어서 전달)
interface FetchOptions {
  method?: "GET" | "POST" | "PUT" | "DELETE"; // HTTP 요청 방식
  headers?: Record&lt;string, string&gt;;  // 요청 헤더 (Record: 키-값 쌍의 객체 타입)
  body?: string;     // 요청 본문
  timeout?: number;  // 제한 시간 (밀리초)

function fetchAPI(url: string, options: FetchOptions = {}): Promise&lt;Response&gt; {
  const { method = "GET", timeout = 5000 } = options;
  return fetch(url, { ...options, method });
}

// 패턴 2: 빌더 패턴의 체이닝
function createQueryBuilder() {
  let query = "";
  return {
    select(fields: string[]) { query += `SELECT ${fields.join(", ")} `; return this; },
    from(table: string) { query += `FROM ${table} `; return this; },
    where(condition: string) { query += `WHERE ${condition} `; return this; },
    build(): string { return query.trim(); }
  };
}

const sql = createQueryBuilder()
  .select(["name", "age"])
  .from("users")
  .where("age > 18")
  .build();</code></pre>
      </section>

      <!-- Slide 15: Summary -->
      <section data-transition="slide" data-narration="챕터 3을 정리하겠습니다. 표에서 보듯이 함수 타입 어노테이션, 화살표 함수, 선택적 매개변수와 기본값, 나머지 매개변수, 오버로드, void, 콜백 타입, 그리고 제네릭까지 학습했습니다. 가장 중요한 포인트는 매개변수에는 반드시 타입을 명시하고, 제네릭으로 재사용성을 높이는 것입니다. 다음 챕터에서는 인터페이스와 타입 별칭으로 복잡한 객체 타입을 정의하는 방법을 학습합니다.">
        <h2>Chapter 3 정리</h2>
        <table class="compare-table" style="font-size: 0.75em;">
          <thead>
            <tr>
              <th>개념</th>
              <th>문법</th>
              <th>설명</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>타입 어노테이션</td><td><code>(a: number): string</code></td><td>매개변수 + 반환 타입 명시</td></tr>
            <tr><td>화살표 함수</td><td><code>(n: number) => n * 2</code></td><td>간결한 함수 표현식</td></tr>
            <tr><td>선택적 매개변수</td><td><code>name?: string</code></td><td>생략 가능 (| undefined)</td></tr>
            <tr><td>기본값</td><td><code>port = 3000</code></td><td>생략 시 기본값 사용</td></tr>
            <tr><td>나머지 매개변수</td><td><code>...args: number[]</code></td><td>가변 인수</td></tr>
            <tr><td>오버로드</td><td>여러 시그니처 선언</td><td>입력에 따라 반환 타입 변경</td></tr>
            <tr><td>void</td><td><code>(): void</code></td><td>반환값 사용하지 않음</td></tr>
            <tr><td>콜백 타입</td><td><code>type Fn = (x: T) => R</code></td><td>함수 타입 별칭</td></tr>
            <tr><td>제네릭</td><td><code>&lt;T&gt;(arr: T[]): T</code></td><td>타입을 매개변수로</td></tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 16: Next Chapter -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 3을 마치겠습니다. 가장 중요한 포인트는 매개변수 타입을 명시하여 잘못된 인수 전달을 방지하는 것과, 제네릭으로 타입 안전한 재사용 가능 함수를 만드는 것입니다. 실무에서는 옵션 객체 패턴과 콜백 타입 정의를 가장 자주 사용합니다. 다음 챕터에서는 인터페이스와 타입 별칭으로 복잡한 객체 구조의 타입을 정의하는 방법을 학습합니다.">
        <span class="chapter-number">Next</span>
        <h1>수고하셨습니다!</h1>
        <br>
        <p>
          <a href="04-interfaces.html" style="color: var(--ts-blue); font-size: 1.2em;">
            다음 챕터: 인터페이스 &amp; 타입 별칭 &#8594;
          </a>
        </p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.7em;">&#8592; 목차로 돌아가기</a></p>
      </section>

    </div>
  </div>

  <div class="nav-footer">
    <a href="../index.html" style="color: #888;">TypeScript 완전 정복</a> | Chapter 03
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
