<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Chapter 11: 비동기 프로그래밍 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section data-narration="챕터 11, 비동기 프로그래밍입니다. 이 챕터에서는 콜백 패턴의 문제점, Promise 제네릭 타입을 활용한 타입 안전한 비동기 처리, async/await 문법, try/catch 에러 처리, Promise.all과 allSettled를 이용한 동시 실행 패턴, 그리고 재시도 로직과 동시성 제어까지 학습합니다. 실전 API 클라이언트를 직접 만들어봅니다.">
        <div class="chapter-title">
          <div class="chapter-number">Chapter 11</div>
          <h1>비동기 (Asynchronous) 프로그래밍</h1>
          <p class="subtitle">프로미스 (Promise), async/await, 그리고 타입 안전한 비동기 처리</p>
          <br>
          <p>
            <span class="badge badge-blue">Promise&lt;T&gt;</span>
            <span class="badge badge-green">async/await</span>
            <span class="badge badge-orange">Error Handling</span>
            <span class="badge badge-red">AsyncGenerator</span>
          </p>
        </div>
      </section>

      <!-- Slide 2: Callback Pattern -->
      <section data-narration="콜백 패턴은 비동기 작업 완료 시 실행할 함수를 인자로 전달하는 방식입니다. 이 코드에서 fetchUser 함수는 error와 user를 매개변수로 받는 콜백을 인자로 받아 1초 후에 호출합니다. 그러나 사용자 조회 후 게시글, 댓글을 순차적으로 가져오면 콜백이 깊게 중첩되는 콜백 지옥이 발생합니다. 에러 처리가 반복되고 타입 추론도 어려워집니다.">
        <h2>콜백 (Callback) 패턴과 그 문제점</h2>
        <div class="tip" style="margin-bottom: 0.5em;">
          <strong>비유로 이해하기:</strong> 식당에서 주문하는 상황을 생각해보세요.<br>
          - <strong>동기 (Synchronous)</strong>: 음식이 나올 때까지 카운터 앞에서 기다림 (다른 일 불가)<br>
          - <strong>비동기 (Asynchronous)</strong>: 진동벨을 받고 자리에 앉아 다른 일을 하다가, 벨이 울리면 음식을 받음<br>
          - <strong>콜백 (Callback)</strong>: "음식 준비되면 이 함수를 호출해줘"라고 미리 알려주는 것 (진동벨과 같은 역할)
        </div>
        <pre><code class="language-typescript" data-trim>
// 전통적인 콜백 (Callback) 방식
// "작업이 끝나면 이 함수를 실행해줘"라고 전달하는 패턴
function fetchUser(
  id: number,
  callback: (error: Error | null, user?: User) => void
) {
  setTimeout(() => {
    if (id <= 0) {
      callback(new Error('유효하지 않은 ID'));
      return;
    }
    callback(null, { id, name: '홍길동', email: 'hong@test.com' });
  }, 1000);
}
        </code></pre>
        <div class="fragment">
          <pre><code class="language-typescript" data-trim>
// 콜백 지옥 (Callback Hell)
// 콜백 안에 콜백이 깊게 중첩되어 코드를 읽기 매우 어려운 상태
fetchUser(1, (err, user) => {
  if (err) return console.error(err);
  fetchPosts(user!.id, (err, posts) => {
    if (err) return console.error(err);
    fetchComments(posts![0].id, (err, comments) => {
      if (err) return console.error(err);
      // 계속 중첩됨...
      console.log(comments);
    });
  });
});
          </code></pre>
        </div>
        <div class="warning fragment">
          <strong>문제점:</strong> 깊은 중첩, 에러 처리 반복, 타입 추론 어려움, 실행 순서 파악 어려움
        </div>
      </section>

      <!-- Slide 3: Promises Basics -->
      <section data-narration="프로미스는 비동기 작업의 미래 결과를 나타내는 객체입니다. 이 코드에서 Promise 생성자는 resolve와 reject 두 콜백을 매개변수로 받습니다. 성공하면 resolve를 호출하여 Fulfilled 상태가 되고, 실패하면 reject를 호출하여 Rejected 상태가 됩니다. 생성된 프로미스는 then으로 성공 결과를, catch로 에러를 처리합니다. Pending, Fulfilled, Rejected 세 가지 상태를 이해하는 것이 핵심입니다.">
        <h2>프로미스 (Promise) 기초</h2>
        <p>비동기 작업의 <strong>미래 결과</strong>를 나타내는 객체입니다. 식당 비유로 말하면, "주문 접수증"과 같습니다 - 지금은 음식이 없지만, 나중에 반드시 결과(성공 또는 실패)를 알려줍니다.</p>
        <div class="fragment">
          <pre><code class="language-typescript" data-trim>
// Promise 생성 - &lt;string&gt;은 성공 시 반환할 값의 타입
const promise = new Promise&lt;string&gt;((resolve, reject) => {
  const success = true;
  setTimeout(() => {       // 1초 후에 실행 (비동기 작업 시뮬레이션)
    if (success) {
      resolve('작업 완료!');   // 성공 시 resolve 호출 (음식 완성!)
    } else {
      reject(new Error('작업 실패'));  // 실패 시 reject 호출 (재료 소진!)
    }
  }, 1000);
});

// Promise 소비 - 결과를 받아서 처리
promise
  .then(result => console.log(result))   // 성공 시: '작업 완료!'
  .catch(error => console.error(error)); // 실패 시: 에러 처리
          </code></pre>
        </div>
        <div class="key-point fragment">
          <h3>Promise의 3가지 상태</h3>
          <p>
            <span class="badge badge-orange">Pending</span> 대기 중 &rarr;
            <span class="badge badge-green">Fulfilled</span> 이행됨 (resolve) 또는
            <span class="badge badge-red">Rejected</span> 거부됨 (reject)
          </p>
        </div>
      </section>

      <!-- Slide 4: Promise<T> Typing -->
      <section data-narration="타입스크립트에서 Promise 제네릭 타입의 T는 이행 시 반환되는 값의 타입을 나타냅니다. 이 코드에서 fetchUser 함수는 Promise User 타입을 반환하므로 resolve에 User 타입만 전달할 수 있습니다. async 함수에서 await로 받은 변수도 자동으로 User 타입으로 추론됩니다. Promise void는 반환값 없는 비동기 함수에, Promise never는 항상 reject되는 경우에 사용합니다.">
        <h2>Promise&lt;T&gt; 타입 지정</h2>
        <pre><code class="language-typescript" data-trim>
interface User {
  id: number;
  name: string;
  email: string;
}

interface ApiError {
  code: number;
  message: string;
}

// Promise의 제네릭 타입으로 resolve 값의 타입을 지정
function fetchUser(id: number): Promise&lt;User&gt; {
  return new Promise((resolve, reject) => {
    // resolve는 User 타입만 받을 수 있음
    resolve({ id, name: '홍길동', email: 'hong@test.com' });
    // resolve('문자열'); // 타입 에러!
  });
}

// 반환 타입이 자동 추론됨
async function getUser(id: number) {
  const user = await fetchUser(id);
  // user: User 로 자동 추론!
  console.log(user.name);  // OK
  console.log(user.age);   // 타입 에러! 'age'는 User에 없음
}
        </code></pre>
        <div class="tip fragment">
          <strong>팁:</strong> <code>Promise&lt;void&gt;</code>는 반환값이 없는 비동기 함수에 사용합니다.
          <code>Promise&lt;never&gt;</code>는 항상 reject되는 Promise에 사용합니다.
        </div>
      </section>

      <!-- Slide 5: Promise Chaining -->
      <section data-narration="프로미스 체이닝은 then 메서드가 새로운 프로미스를 반환하는 특성을 이용하여 비동기 작업을 순서대로 연결하는 패턴입니다. 이 코드에서 fetchUser의 결과로 fetchPosts를 호출하고, 그 결과로 fetchComments를 호출합니다. 각 then의 반환 타입이 다음 then의 입력 타입이 되므로 타입스크립트가 체인 전체의 타입을 추적합니다. catch 하나로 체인 어디서든 발생한 에러를 처리할 수 있습니다.">
        <h2>Promise 체이닝</h2>
        <pre><code class="language-typescript" data-trim>
interface User { id: number; name: string; }
interface Post { id: number; title: string; authorId: number; }
interface Comment { id: number; body: string; postId: number; }

function fetchUser(id: number): Promise&lt;User&gt; { /* ... */ }
function fetchPosts(userId: number): Promise&lt;Post[]&gt; { /* ... */ }
function fetchComments(postId: number): Promise&lt;Comment[]&gt; { /* ... */ }

// 체이닝으로 콜백 지옥 해결
fetchUser(1)
  .then(user => {
    console.log(`사용자: ${user.name}`);
    return fetchPosts(user.id);          // Promise&lt;Post[]&gt;
  })
  .then(posts => {
    console.log(`게시물 수: ${posts.length}`);
    return fetchComments(posts[0].id);   // Promise&lt;Comment[]&gt;
  })
  .then(comments => {
    console.log(`댓글 수: ${comments.length}`);
  })
  .catch(error => {
    // 체인 어디서든 발생한 에러를 여기서 처리
    console.error('오류 발생:', error.message);
  })
  .finally(() => {
    console.log('완료 (성공/실패 무관)');
  });
        </code></pre>
        <div class="key-point fragment">
          <h3>핵심</h3>
          <p>각 <code>.then()</code>의 반환 타입이 다음 <code>.then()</code>의 입력 타입이 됩니다. TypeScript가 체인 전체의 타입을 추적합니다.</p>
        </div>
      </section>

      <!-- Slide 6: async/await -->
      <section data-narration="async와 await는 프로미스 체이닝을 동기 코드처럼 작성할 수 있게 해주는 문법적 설탕입니다. 이 코드에서 왼쪽의 then 체이닝과 오른쪽의 async/await는 동일한 동작을 합니다. async 함수는 항상 프로미스를 반환하며, await는 프로미스가 이행될 때까지 실행을 일시 중단하고 결과값을 바로 변수에 할당합니다. 가독성이 크게 향상되어 실무에서 가장 많이 사용하는 비동기 패턴입니다.">
        <h2>async/await</h2>
        <p>프로미스 (Promise)를 <strong>동기 (Sync) 코드처럼</strong> 작성하는 문법적 설탕. <code>async</code>는 "이 함수는 비동기입니다"라고 선언하고, <code>await</code>는 "결과가 올 때까지 기다립니다"라는 뜻입니다.</p>
        <div class="two-columns">
          <div>
            <h3>Promise 체이닝</h3>
            <pre><code class="language-typescript" data-trim>
function loadData(): Promise&lt;Data&gt; {
  return fetchUser(1)
    .then(user =>
      fetchPosts(user.id)
    )
    .then(posts =>
      processData(posts)
    );
}
            </code></pre>
          </div>
          <div>
            <h3>async/await</h3>
            <pre><code class="language-typescript" data-trim>
// async: 비동기 함수 선언
async function loadData(): Promise&lt;Data&gt; {
  // await: 결과가 올 때까지 대기
  const user = await fetchUser(1);
  const posts = await fetchPosts(
    user.id
  );
  return processData(posts);
}
            </code></pre>
          </div>
        </div>
        <div class="fragment">
          <pre><code class="language-typescript" data-trim>
// async 함수는 항상 Promise를 반환합니다
async function greet(name: string): Promise&lt;string&gt; {
  return `안녕하세요, ${name}님!`;  // 자동으로 Promise로 감싸짐
}

// 위의 코드는 아래와 동일합니다:
function greetEquivalent(name: string): Promise&lt;string&gt; {
  return Promise.resolve(`안녕하세요, ${name}님!`);
}
          </code></pre>
        </div>
        <div class="tip fragment">
          <strong>규칙:</strong> <code>await</code>는 <code>async</code> 함수 내부에서만 사용 가능합니다. (ES2022+ 최상위 await 제외)
        </div>
      </section>

      <!-- Slide 7: Error Handling with try/catch -->
      <section data-narration="async/await에서는 try/catch/finally로 에러를 처리합니다. 이 코드에서 getUserData 함수는 fetch 실패 시 catch 블록에서 에러를 잡고 null을 반환합니다. 타입스크립트 4.4 이상에서 catch의 error는 unknown 타입이므로 instanceof로 타입을 좁혀 사용해야 합니다. 커스텀 ApiError 클래스를 정의하면 statusCode 같은 추가 정보에 접근하여 세밀한 에러 분기 처리가 가능합니다.">
        <h2>에러 처리: try/catch</h2>
        <pre><code class="language-typescript" data-trim>
// 기본 try/catch 패턴
async function getUserData(id: number): Promise&lt;User | null&gt; {
  try {
    const response = await fetch(`/api/users/${id}`);

    if (!response.ok) {
      throw new Error(`HTTP 에러: ${response.status}`);
    }

    const user: User = await response.json();
    return user;
  } catch (error) {
    // TS에서 catch의 error는 기본적으로 unknown 타입
    if (error instanceof Error) {
      console.error('사용자 조회 실패:', error.message);
    }
    return null;
  } finally {
    // 성공/실패 관계없이 실행
    console.log('API 호출 완료');
  }
}
        </code></pre>
        <div class="warning fragment">
          <strong>주의:</strong> TypeScript 4.4+에서 <code>catch(error)</code>의 <code>error</code>는 <code>unknown</code> 타입입니다. 반드시 타입 가드로 좁혀서 사용하세요.
        </div>
        <div class="fragment">
          <pre><code class="language-typescript" data-trim>
// 커스텀 에러 클래스로 정밀한 에러 처리
class ApiError extends Error {
  constructor(public statusCode: number, message: string) {
    super(message);
    this.name = 'ApiError';
  }
}

try {
  await fetchData();
} catch (error) {
  if (error instanceof ApiError) {
    console.log(error.statusCode); // number 접근 가능
  } else if (error instanceof TypeError) {
    console.log('타입 에러:', error.message);
  } else {
    console.log('알 수 없는 에러');
  }
}
          </code></pre>
        </div>
      </section>

      <!-- Slide 8: Promise.all -->
      <section data-narration="Promise.all은 여러 프로미스를 동시에 실행하고 모든 결과를 배열로 받습니다. 이 코드에서 loadDashboard 함수는 사용자, 게시물, 알림을 병렬로 조회하여 구조 분해 할당으로 받습니다. 타입스크립트는 결과를 User, Post 배열, Notification 배열의 튜플 타입으로 정확히 추론합니다. 단, 하나라도 reject되면 전체가 즉시 실패하므로, 부분 실패를 허용하려면 Promise.allSettled를 사용해야 합니다.">
        <h2>Promise.all</h2>
        <p>여러 Promise를 <strong>병렬</strong>로 실행하고 모두 완료되면 결과 반환</p>
        <pre><code class="language-typescript" data-trim>
// 모든 Promise가 성공해야 결과를 받음
async function loadDashboard(userId: number) {
  const [user, posts, notifications] = await Promise.all([
    fetchUser(userId),           // Promise&lt;User&gt;
    fetchPosts(userId),          // Promise&lt;Post[]&gt;
    fetchNotifications(userId),  // Promise&lt;Notification[]&gt;
  ]);
  // user: User, posts: Post[], notifications: Notification[]
  // 타입이 튜플로 정확히 추론됨!

  return { user, posts, notifications };
}
        </code></pre>
        <div class="fragment">
          <pre><code class="language-typescript" data-trim>
// 타입 추론 확인
const results = await Promise.all([
  Promise.resolve(42),           // number
  Promise.resolve('hello'),      // string
  Promise.resolve(true),         // boolean
]);
// results: [number, string, boolean] - 튜플 타입!
          </code></pre>
        </div>
        <div class="warning fragment">
          <strong>주의:</strong> 하나라도 reject되면 전체가 즉시 reject됩니다. 부분 실패를 허용하려면 <code>Promise.allSettled</code>를 사용하세요.
        </div>
      </section>

      <!-- Slide 9: Promise.race, Promise.allSettled -->
      <section data-narration="Promise.race와 Promise.allSettled는 서로 다른 동시 실행 전략을 제공합니다. 이 코드에서 왼쪽의 withTimeout 함수는 Promise.race를 사용하여 원래 프로미스와 타임아웃 프로미스 중 먼저 완료되는 쪽의 결과를 반환합니다. 오른쪽의 allSettled는 모든 프로미스가 완료될 때까지 기다린 후 각각의 성공 또는 실패 결과를 fulfilled, rejected 상태와 함께 배열로 반환합니다. 부분 실패를 허용하는 경우에 적합합니다.">
        <h2>Promise.race & Promise.allSettled</h2>
        <div class="two-columns">
          <div>
            <h3>Promise.race</h3>
            <p>가장 먼저 완료된 결과만</p>
            <pre><code class="language-typescript" data-trim>
// 타임아웃 구현
function withTimeout&lt;T&gt;(
  promise: Promise&lt;T&gt;,
  ms: number
): Promise&lt;T&gt; {
  const timeout = new Promise&lt;never&gt;(
    (_, reject) => setTimeout(
      () => reject(
        new Error('Timeout')
      ),
      ms
    )
  );

  return Promise.race([
    promise,
    timeout
  ]);
}

// 3초 안에 응답 없으면 에러
const data = await withTimeout(
  fetchData(), 3000
);
            </code></pre>
          </div>
          <div>
            <h3>Promise.allSettled</h3>
            <p>모든 결과를 성공/실패 포함</p>
            <pre><code class="language-typescript" data-trim>
const results =
  await Promise.allSettled([
    fetchUser(1),
    fetchUser(2),
    fetchUser(999), // 실패
  ]);

results.forEach((result, i) => {
  if (result.status === 'fulfilled') {
    // result.value: User
    console.log(
      `#${i} 성공:`,
      result.value.name
    );
  } else {
    // result.reason: any
    console.log(
      `#${i} 실패:`,
      result.reason
    );
  }
});

// #0 성공: 홍길동
// #1 성공: 김영희
// #2 실패: User not found
            </code></pre>
          </div>
        </div>
      </section>

      <!-- Slide 10: Typing Async Functions -->
      <section data-narration="비동기 함수의 타입을 정확하게 정의하는 방법을 알아봅시다. 이 코드에서 UserRepository 인터페이스는 findById, findAll, create 등 모든 메서드의 반환 타입을 Promise 제네릭으로 명시합니다. Awaited 유틸리티 타입은 Promise 내부의 실제 값 타입을 추출하며, 중첩된 프로미스도 재귀적으로 풀어냅니다. ReturnType과 함께 사용하면 async 함수의 실제 반환값 타입을 간편하게 추출할 수 있습니다.">
        <h2>비동기 함수의 타입 정의</h2>
        <pre><code class="language-typescript" data-trim>
// 함수 시그니처 타입
type AsyncFn&lt;T&gt; = () => Promise&lt;T&gt;;
type AsyncFnWithArg&lt;A, T&gt; = (arg: A) => Promise&lt;T&gt;;

// 인터페이스에서 비동기 메서드 정의
interface UserRepository {
  findById(id: number): Promise&lt;User | null&gt;;
  findAll(): Promise&lt;User[]&gt;;
  create(data: CreateUserDto): Promise&lt;User&gt;;
  update(id: number, data: Partial&lt;User&gt;): Promise&lt;User&gt;;
  delete(id: number): Promise&lt;void&gt;;
}
        </code></pre>
        <pre class="fragment"><code class="language-typescript" data-trim>
// 유틸리티 타입: Promise 내부 타입 추출
type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;
// TypeScript 4.5+에서는 내장 Awaited 타입 사용 가능

type A = Awaited&lt;Promise&lt;string&gt;&gt;;         // string
type B = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;; // number (재귀적)

// ReturnType과 함께 사용
async function fetchConfig() {
  return { apiUrl: 'https://...', timeout: 5000 };
}

type Config = Awaited&lt;ReturnType&lt;typeof fetchConfig&gt;&gt;;
// { apiUrl: string; timeout: number }
        </code></pre>
      </section>

      <!-- Slide 11: AsyncGenerator -->
      <section data-narration="비동기 제너레이터는 async function 별표 문법으로 정의하며 yield 키워드로 값을 하나씩 비동기적으로 생산합니다. 이 코드에서 fetchAllPages 함수는 API의 페이지네이션을 처리하여 각 페이지 데이터를 yield로 전달합니다. for await of 문으로 비동기 이터러블을 순회하면 각 페이지가 로드될 때마다 처리할 수 있습니다. 대용량 데이터 스트리밍이나 WebSocket 메시지 처리에 유용한 패턴입니다.">
        <h2>AsyncGenerator & for-await-of</h2>
        <p>비동기적으로 데이터를 순차적으로 생산하고 소비하는 패턴</p>
        <pre><code class="language-typescript" data-trim>
// 비동기 제너레이터: 페이지네이션(데이터를 여러 페이지로 나눠 가져오기) 처리
// function* 은 "값을 하나씩 순서대로 생산하는 함수"를 의미
async function* fetchAllPages&lt;T&gt;(
  baseUrl: string
): AsyncGenerator&lt;T[], void, unknown&gt; {
  let page = 1;        // 현재 페이지 번호
  let hasMore = true;  // 다음 페이지가 있는지 여부

  while (hasMore) {
    const response = await fetch(`${baseUrl}?page=${page}`);
    const data = await response.json();

    yield data.items as T[];  // yield: 이번 페이지 데이터를 하나씩 전달

    hasMore = data.hasNextPage;  // 다음 페이지 존재 여부 확인
    page++;
  }
}
        </code></pre>
        <pre class="fragment"><code class="language-typescript" data-trim>
// for-await-of로 비동기 이터레이터 소비
async function processAllUsers() {
  const allUsers: User[] = [];

  for await (const page of fetchAllPages&lt;User&gt;('/api/users')) {
    allUsers.push(...page);
    console.log(`${allUsers.length}명 로드됨...`);
  }

  console.log(`총 ${allUsers.length}명의 사용자 처리 완료`);
  return allUsers;
}
        </code></pre>
        <div class="tip fragment">
          <strong>활용:</strong> 대용량 데이터 스트리밍, WebSocket 메시지 처리, SSE(Server-Sent Events) 등에 유용합니다.
        </div>
      </section>

      <!-- Slide 12: Real-world Fetch Wrapper -->
      <section data-narration="Fetch API를 감싸는 타입 안전한 래퍼 클래스를 만들어 봅시다. 이 코드에서 ApiClient 클래스의 request 메서드는 제네릭 T로 응답 타입을 지정받아 fetch 호출 후 결과를 해당 타입으로 반환합니다. HTTP 에러 상태를 자동으로 감지하여 ApiError를 던지고, get, post, put, delete 메서드가 각각 적절한 HTTP 메서드와 함께 request를 호출합니다. 한 곳에서 공통 로직을 관리하는 실전 패턴입니다.">
        <h2>실전: 타입 안전한 Fetch 래퍼</h2>
        <pre><code class="language-typescript" data-trim style="font-size: 0.78em;">
class ApiClient {
  constructor(private baseUrl: string) {} // API 서버 주소 저장

  // 공통 요청 메서드 - 제네릭 T로 응답 타입을 지정
  private async request&lt;T&gt;(
    endpoint: string,       // API 경로 (예: '/users')
    options?: RequestInit   // 요청 설정 (메서드, 본문 등)
  ): Promise&lt;T&gt; {
    const url = `${this.baseUrl}${endpoint}`;
    const config: RequestInit = {
      headers: { 'Content-Type': 'application/json' },
      ...options,  // 전달받은 설정으로 덮어쓰기
    };

    const response = await fetch(url, config);

    if (!response.ok) {  // HTTP 에러 상태 (4xx, 5xx) 처리
      const errorBody = await response.json().catch(() => ({}));
      throw new ApiError(response.status, errorBody.message || '요청 실패');
    }

    return response.json() as Promise&lt;T&gt;;  // JSON을 T 타입으로 반환
  }

  get&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {
    return this.request&lt;T&gt;(endpoint, { method: 'GET' });
  }

  post&lt;T, B = unknown&gt;(endpoint: string, body: B): Promise&lt;T&gt; {
    return this.request&lt;T&gt;(endpoint, {
      method: 'POST',
      body: JSON.stringify(body),
    });
  }

  put&lt;T, B = unknown&gt;(endpoint: string, body: B): Promise&lt;T&gt; {
    return this.request&lt;T&gt;(endpoint, {
      method: 'PUT',
      body: JSON.stringify(body),
    });
  }

  delete&lt;T = void&gt;(endpoint: string): Promise&lt;T&gt; {
    return this.request&lt;T&gt;(endpoint, { method: 'DELETE' });
  }
}
        </code></pre>
      </section>

      <!-- Slide 13: Using the Fetch Wrapper -->
      <section data-narration="앞서 만든 ApiClient를 실제로 활용하는 방법입니다. 이 코드에서 api.get에 User 배열 제네릭을 지정하면 응답이 자동으로 User 배열 타입으로 추론됩니다. api.post에는 응답 타입 User와 요청 본문 타입 CreateUserDto를 함께 지정하여 요청과 응답 모두 컴파일 타임에 검증됩니다. 잘못된 필드 접근이나 타입 불일치를 코드 작성 시점에 사전 방지하는 것이 이 패턴의 핵심 장점입니다.">
        <h2>Fetch 래퍼 활용</h2>
        <pre><code class="language-typescript" data-trim>
// API 클라이언트 인스턴스 생성
const api = new ApiClient('https://api.example.com');

// 완전한 타입 안전성!
interface User {
  id: number;
  name: string;
  email: string;
}

interface CreateUserDto {
  name: string;
  email: string;
  password: string;
}

// 사용 - 제네릭으로 응답 타입 지정
async function userCRUD() {
  // GET: User[] 타입으로 자동 추론
  const users = await api.get&lt;User[]&gt;('/users');
  console.log(users[0].name); // OK, string

  // POST: 요청 body와 응답 타입 모두 지정
  const newUser = await api.post&lt;User, CreateUserDto&gt;('/users', {
    name: '김철수',
    email: 'kim@test.com',
    password: 'secure123',
  });
  console.log(newUser.id); // OK, number

  // DELETE: void 반환
  await api.delete('/users/1');
}
        </code></pre>
        <div class="key-point fragment">
          <h3>장점</h3>
          <p>모든 API 호출의 요청/응답 타입이 컴파일 타임 (Compile Time, 코드 변환 시점)에 검증됩니다. 잘못된 필드 접근이나 타입 불일치를 사전에 방지!</p>
        </div>
      </section>

      <!-- Slide 14: Error Handling Patterns -->
      <section data-narration="비동기 에러 처리의 실전 패턴 두 가지를 소개합니다. 첫 번째 safeAsync 함수는 Go 언어 스타일로 프로미스를 감싸서 성공 시 값과 null 튜플을, 실패 시 null과 Error 튜플을 반환합니다. try/catch 없이 구조 분해로 에러를 처리할 수 있습니다. 두 번째 withRetry 함수는 실패 시 지정된 횟수만큼 지수적 대기 시간을 두고 자동으로 재시도합니다. 네트워크 불안정 환경에서 필수적인 패턴입니다.">
        <h2>비동기 에러 처리 패턴</h2>
        <pre><code class="language-typescript" data-trim>
// 패턴 1: Go 스타일 - tuple 반환
async function safeAsync&lt;T&gt;(
  promise: Promise&lt;T&gt;
): Promise&lt;[T, null] | [null, Error]&gt; {
  try {
    const data = await promise;
    return [data, null];
  } catch (error) {
    return [null, error instanceof Error ? error : new Error(String(error))];
  }
}

// 사용
const [user, error] = await safeAsync(fetchUser(1));
if (error) {
  console.error('실패:', error.message);
} else {
  console.log('성공:', user.name); // user는 User 타입
}
        </code></pre>
        <pre class="fragment"><code class="language-typescript" data-trim>
// 패턴 2: 재시도 로직 - 실패하면 자동으로 다시 시도
async function withRetry&lt;T&gt;(
  fn: () => Promise&lt;T&gt;,       // 실행할 비동기 함수
  maxRetries: number = 3,     // 최대 재시도 횟수
  delay: number = 1000        // 재시도 전 대기 시간(ms)
): Promise&lt;T&gt; {
  for (let attempt = 1; attempt &lt;= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) throw error;
      console.log(`시도 ${attempt} 실패, ${delay}ms 후 재시도...`);
      await new Promise(r => setTimeout(r, delay * attempt));
    }
  }
  throw new Error('도달할 수 없는 코드'); // TypeScript 만족
}

const data = await withRetry(() => fetchData(), 3, 2000);
        </code></pre>
      </section>

      <!-- Slide 15: Advanced Pattern - Concurrent Control -->
      <section data-narration="동시성 제어 패턴은 한 번에 실행되는 비동기 작업 수를 제한합니다. 이 코드에서 asyncPool 함수는 concurrency 매개변수로 최대 동시 실행 수를 받고, Set으로 현재 실행 중인 작업을 추적합니다. 실행 중인 작업이 최대치에 도달하면 Promise.race로 하나가 완료될 때까지 대기합니다. 100개 API 요청을 동시에 보내면 서버가 과부하되므로, 3개씩만 동시 실행하는 식으로 활용합니다. 대량 데이터 처리의 필수 패턴입니다.">
        <h2>고급: 동시성 제어</h2>
        <pre><code class="language-typescript" data-trim>
// 동시 실행 수를 제한하는 유틸리티
// 예: 100개 요청을 한번에 보내면 서버가 과부하되므로, 3개씩만 동시 실행
async function asyncPool&lt;T, R&gt;(
  concurrency: number,          // 동시에 실행할 최대 개수
  items: T[],                   // 처리할 항목들
  fn: (item: T) => Promise&lt;R&gt;  // 각 항목에 실행할 비동기 함수
): Promise&lt;R[]&gt; {
  const results: R[] = [];                       // 결과 저장 배열
  const executing = new Set&lt;Promise&lt;void&gt;&gt;();  // 현재 실행 중인 작업들

  for (const [index, item] of items.entries()) {
    const promise = fn(item).then(result => {
      results[index] = result;   // 결과를 원래 순서에 맞게 저장
    });

    const wrapped = promise.then(() => {
      executing.delete(wrapped); // 완료되면 실행 목록에서 제거
    });

    executing.add(wrapped);      // 실행 목록에 추가

    if (executing.size >= concurrency) {
      await Promise.race(executing); // 하나가 끝날 때까지 대기
    }
  }

  await Promise.all(executing);  // 남은 작업들 모두 완료 대기
  return results;
}
        </code></pre>
        <pre class="fragment"><code class="language-typescript" data-trim>
// 한 번에 최대 3개씩만 요청
const userIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const users = await asyncPool(
  3,                         // 동시에 3개까지만
  userIds,
  (id) => fetchUser(id)      // 각 ID에 대해 비동기 실행
);
console.log(`${users.length}명 로드 완료`);
        </code></pre>
      </section>

      <!-- Slide 16: Summary -->
      <section data-narration="챕터 11을 마치겠습니다. 가장 중요한 포인트는 Promise 제네릭 타입으로 비동기 코드에서도 완전한 타입 안전성을 확보할 수 있다는 점입니다. 실무에서는 async/await와 적절한 에러 처리를 기본으로 사용하고, 성능이 중요한 경우 동시성 제어 패턴을 적용하세요. 다음 챕터에서는 프로덕션 레벨의 실전 디자인 패턴을 학습합니다.">
        <h2>Chapter 11 요약</h2>
        <div class="two-columns">
          <div>
            <div class="key-point">
              <h3>비동기 기초</h3>
              <ul>
                <li class="fragment"><strong>Promise&lt;T&gt;</strong> - 타입이 있는 비동기 값</li>
                <li class="fragment"><strong>async/await</strong> - 동기 스타일 비동기 코드</li>
                <li class="fragment"><strong>try/catch</strong> - unknown 타입 에러 처리</li>
                <li class="fragment"><strong>Promise.all</strong> - 병렬 실행</li>
                <li class="fragment"><strong>Promise.allSettled</strong> - 부분 실패 허용</li>
              </ul>
            </div>
          </div>
          <div>
            <div class="key-point">
              <h3>고급 패턴</h3>
              <ul>
                <li class="fragment"><strong>AsyncGenerator</strong> - 스트리밍</li>
                <li class="fragment"><strong>API 클라이언트</strong> - 타입 안전 래퍼</li>
                <li class="fragment"><strong>safeAsync</strong> - Go 스타일 에러</li>
                <li class="fragment"><strong>withRetry</strong> - 재시도 로직</li>
                <li class="fragment"><strong>asyncPool</strong> - 동시성 제어</li>
              </ul>
            </div>
          </div>
        </div>
        <div class="tip fragment">
          <strong>핵심 원칙:</strong> 비동기 코드에서도 타입 안전성을 유지하세요. <code>any</code>로 도망치지 마세요!
        </div>
        <br>
        <p class="fragment">
          <a href="12-real-world.html" style="color: var(--ts-blue);">
            다음 챕터: Chapter 12 - 실전 패턴 &rarr;
          </a>
        </p>
      </section>

    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
