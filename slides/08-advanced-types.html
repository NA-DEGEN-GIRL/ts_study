<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Chapter 8: 고급 타입 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-narration="챕터 8, 고급 타입입니다. 이 챕터에서는 조건부 타입과 infer를 활용한 타입 추출, 매핑된 타입을 통한 속성 변환, 템플릿 리터럴 타입과 재귀 타입을 학습합니다. 고급 타입은 라이브러리 수준의 타입 안전성을 구현하는 데 필수적이며, 실전에서 유틸리티 타입을 직접 만들 때 활용됩니다.">
        <div class="chapter-number">Chapter 8</div>
        <h1>고급 타입</h1>
        <p class="subtitle">타입 시스템의 깊은 세계로</p>
        <br>
        <p style="font-size:0.6em; color:#888;">
          <span class="badge badge-blue">조건부 타입 (Conditional Type)</span>
          <span class="badge badge-green">매핑된 타입 (Mapped Type)</span>
          <span class="badge badge-orange">템플릿 리터럴 타입 (Template Literal Type)</span>
          <span class="badge badge-red">타입 레벨 프로그래밍</span>
        </p>
        <div class="tip" style="font-size:0.55em; margin-top: 1em;">
          이 장은 고급 내용입니다. 처음에 완벽히 이해하지 못해도 괜찮습니다. 필요할 때 다시 돌아와서 참고하세요.
        </div>
      </section>

      <!-- Slide 2: Conditional Types -->
      <section data-narration="조건부 타입은 삼항 연산자와 비슷하게 조건에 따라 다른 타입을 반환합니다. extends 키워드로 타입 간의 관계를 검사하여, 참이면 첫 번째 타입을, 거짓이면 두 번째 타입을 선택합니다. 코드에서 IsString 타입은 T가 string에 해당하면 true를, 아니면 false를 반환합니다. Flatten 타입은 배열이면 infer로 요소 타입을 추출하고, 아니면 원래 타입을 그대로 반환합니다.">
        <h2>조건부 타입 (Conditional Type)</h2>
        <p>타입 레벨(타입을 다루는 차원)의 삼항 연산자: <code>T extends U ? X : Y</code></p>
        <div class="tip" style="margin-bottom: 0.3em; font-size: 0.7em;">
          <strong>왜 이게 필요한가?</strong> 입력 타입에 따라 출력 타입을 자동으로 바꾸고 싶을 때 사용합니다. 예: "문자열을 넣으면 문자열을 반환하고, 숫자를 넣으면 숫자를 반환하는 함수"를 타입으로 표현할 수 있습니다.
        </div>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 문법: "T가 string에 해당하면 true, 아니면 false"
type IsString&lt;T&gt; = T extends string ? true : false;

type A = IsString&lt;string&gt;;    // true
type B = IsString&lt;number&gt;;    // false
type C = IsString&lt;"hello"&gt;;   // true (리터럴도 string을 확장)
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 중첩 조건부 타입
type TypeName&lt;T&gt; =
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends undefined ? "undefined" :
  T extends Function ? "function" :
  "object";

type T1 = TypeName&lt;string&gt;;       // "string"
type T2 = TypeName&lt;() => void&gt;;   // "function"
type T3 = TypeName&lt;string[]&gt;;     // "object"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: 배열이면 요소 타입 추출, 아니면 그대로
// infer U = "U라는 타입을 여기서 추출(추론)해라"
type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T;

type Str = Flatten&lt;string[]&gt;;     // string
type Num = Flatten&lt;number&gt;;       // number (배열이 아니므로 그대로)
        </code></pre>
      </section>

      <!-- Slide 3: Conditional Type Evaluation Trace (NEW) -->
      <section data-narration="조건부 타입의 평가 과정을 단계별로 추적해 보겠습니다. Flatten에 string 배열을 전달하면, 먼저 string 배열이 Array 제네릭 형태에 해당하는지 검사합니다. 해당하므로 infer U에 string이 추출되고 최종 결과는 string입니다. number를 전달하면 배열이 아니므로 조건이 거짓이 되어 원래 타입인 number가 그대로 반환됩니다. 이 추적 방식을 익히면 복잡한 조건부 타입도 이해할 수 있습니다.">
        <h2>조건부 타입 평가 과정 단계별 추적</h2>
        <p>조건부 타입이 실제로 어떻게 평가되는지 한 단계씩 따라가기</p>
        <pre><code class="typescript" data-trim data-noescape>
// 정의
type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T;
        </code></pre>
        <div class="fragment">
          <h3 style="font-size: 0.8em; color: #4ec9b0;">예제 1: Flatten 에 string[] 전달</h3>
          <pre><code class="typescript" data-trim data-noescape>
// Step 1: T = string[]
// Step 2: string[] extends Array 꺾쇠 infer U 꺾쇠 ? U : string[]
// Step 3: string[]은 Array 꺾쇠 string 꺾쇠 이므로 → 조건 참!
// Step 4: infer U = string (U에 string이 추출됨)
// Step 5: 결과 = U = string ✓

type Result1 = Flatten&lt;string[]&gt;;  // string
          </code></pre>
        </div>
        <div class="fragment">
          <h3 style="font-size: 0.8em; color: #4ec9b0;">예제 2: Flatten 에 number 전달</h3>
          <pre><code class="typescript" data-trim data-noescape>
// Step 1: T = number
// Step 2: number extends Array 꺾쇠 infer U 꺾쇠 ? U : number
// Step 3: number는 Array가 아님 → 조건 거짓!
// Step 4: 결과 = T = number ✓

type Result2 = Flatten&lt;number&gt;;    // number
          </code></pre>
        </div>
        <div class="fragment">
          <h3 style="font-size: 0.8em; color: #4ec9b0;">예제 3: 중첩 배열 - Flatten 에 number[][] 전달</h3>
          <pre><code class="typescript" data-trim data-noescape>
// Step 1: T = number[][]
// Step 2: number[][] extends Array 꺾쇠 infer U 꺾쇠 ?
// Step 3: number[][]는 Array 꺾쇠 number[] 꺾쇠 이므로 → 조건 참!
// Step 4: infer U = number[] (한 겹만 벗겨짐)
// Step 5: 결과 = number[] (완전히 평탄화되지 않음!)

type Result3 = Flatten&lt;number[][]&gt;; // number[]
          </code></pre>
        </div>
        <div class="key-point fragment">
          <h3>핵심 포인트</h3>
          <p>조건부 타입은 <strong>extends로 패턴 매칭</strong>하고, <strong>infer로 원하는 부분을 추출</strong>합니다.
          중첩 구조를 완전히 풀려면 재귀 타입이 필요합니다.</p>
        </div>
      </section>

      <!-- Slide 4: infer Keyword -->
      <section data-narration="infer 키워드는 조건부 타입 안에서 특정 위치의 타입을 추출하는 데 사용됩니다. 코드에서 MyReturnType은 함수 타입에서 반환 타입을 R로 추출하고, MyParameters는 매개변수 타입을 P로 추출합니다. UnwrapPromise는 Promise의 내부 타입을 꺼내며, DeepUnwrap은 재귀적으로 중첩된 Promise를 모두 풀어냅니다. infer는 타입스크립트 내장 유틸리티 타입의 핵심 구현 원리입니다.">
        <h2><code>infer</code> 키워드 (타입 추론/추출)</h2>
        <p>조건부 타입 안에서 타입을 <strong>추출(추론)</strong>하는 키워드. <code>infer R</code>은 "여기에 해당하는 타입을 R이라고 부르겠다"는 뜻입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 함수의 반환 타입 추출 (ReturnType의 내부 구현 원리)
// "T가 함수라면, 그 반환 타입을 R로 추출해라"
type MyReturnType&lt;T&gt; = T extends (...args: any[]) => infer R ? R : never;

type R1 = MyReturnType&lt;() => string&gt;;          // string
type R2 = MyReturnType&lt;(x: number) => boolean&gt;; // boolean
type R3 = MyReturnType&lt;string&gt;;                 // never
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 함수의 매개변수 타입 추출 (Parameters의 내부 구현 원리)
// "T가 함수라면, 그 매개변수 타입들을 P로 추출해라"
type MyParameters&lt;T&gt; = T extends (...args: infer P) => any ? P : never;

type P1 = MyParameters&lt;(a: string, b: number) => void&gt;;
// [a: string, b: number]
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Promise 내부 타입 추출
type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;

type V1 = UnwrapPromise&lt;Promise&lt;string&gt;&gt;;   // string
type V2 = UnwrapPromise&lt;Promise&lt;number[]&gt;&gt;; // number[]
type V3 = UnwrapPromise&lt;string&gt;;             // string (Promise가 아님)

// 중첩 Promise도 재귀적으로 풀기 (자기 자신을 다시 호출)
type DeepUnwrap&lt;T&gt; = T extends Promise&lt;infer U&gt; ? DeepUnwrap&lt;U&gt; : T;

type V4 = DeepUnwrap&lt;Promise&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;&gt;; // number
        </code></pre>
      </section>

      <!-- Slide 5: More infer Patterns -->
      <section data-narration="infer를 다양한 위치에서 활용하는 패턴을 살펴봅시다. 코드에서 First 타입은 튜플의 첫 번째 요소를, Last 타입은 마지막 요소의 타입을 추출합니다. InstanceOf 타입은 생성자 함수에서 인스턴스 타입을 꺼내고, ExtractRouteParams는 URL 경로 문자열에서 콜론으로 시작하는 파라미터 이름을 재귀적으로 추출합니다. 이처럼 infer는 패턴 매칭의 핵심 도구입니다.">
        <h2><code>infer</code> 활용 패턴</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 배열의 첫 번째 요소 타입 추출
// [infer F, ...any[]] = "첫 번째를 F로, 나머지는 아무거나"
type First&lt;T extends any[]&gt; = T extends [infer F, ...any[]] ? F : never;

type F1 = First&lt;[string, number, boolean]&gt;;  // string
type F2 = First&lt;[42, "hello"]&gt;;              // 42
type F3 = First&lt;[]&gt;;                          // never
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 배열의 마지막 요소 타입 추출
type Last&lt;T extends any[]&gt; = T extends [...any[], infer L] ? L : never;

type L1 = Last&lt;[string, number, boolean]&gt;;  // boolean
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 생성자의 인스턴스 타입 추출
type InstanceOf&lt;T&gt; = T extends new (...args: any[]) => infer I ? I : never;

class UserModel {
  constructor(public name: string) {}
}

type UserInstance = InstanceOf&lt;typeof UserModel&gt;; // UserModel

// 문자열에서 패턴 매칭: URL 경로의 :파라미터 이름 추출
type ExtractRouteParams&lt;T extends string&gt; =
  T extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractRouteParams&lt;Rest&gt;
    : T extends `${string}:${infer Param}`
    ? Param
    : never;

type Params = ExtractRouteParams&lt;"/users/:userId/posts/:postId"&gt;;
// "userId" | "postId"
        </code></pre>
      </section>

      <!-- Slide 6: Distributive Conditional Types -->
      <section data-narration="유니온 타입에 조건부 타입을 적용하면 각 멤버에 개별적으로 분배되어 적용됩니다. 코드에서 ToArray에 string 또는 number 유니온을 전달하면 string 배열 또는 number 배열 유니온이 됩니다. 이 원리로 Exclude는 유니온에서 특정 타입을 제거하고, Extract는 특정 타입만 추출합니다. 분배를 막으려면 대괄호로 감싸면 됩니다. 이것은 내장 유틸리티 타입의 핵심 동작 원리입니다.">
        <h2>분배 조건부 타입 (Distributive)</h2>
        <p>유니온 타입이 조건부 타입에 들어가면 <strong>각 멤버에 하나씩 분배</strong>되어 적용됩니다. 마치 "한 명씩 줄 서서 처리"하는 것과 같습니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
type ToArray&lt;T&gt; = T extends any ? T[] : never;

// 유니온이 분배됨!
type Result = ToArray&lt;string | number&gt;;
// = ToArray&lt;string&gt; | ToArray&lt;number&gt;
// = string[] | number[]
// (string | number)[]가 아님에 주의!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Exclude 구현 원리 (분배 활용)
// "T의 각 멤버를 하나씩 확인해서, U에 해당하면 제거(never)"
type MyExclude&lt;T, U&gt; = T extends U ? never : T;

type Ex1 = MyExclude&lt;"a" | "b" | "c", "a"&gt;;
// = ("a" extends "a" ? never : "a")
//   | ("b" extends "a" ? never : "b")
//   | ("c" extends "a" ? never : "c")
// = never | "b" | "c"
// = "b" | "c"

// Extract 구현 원리
type MyExtract&lt;T, U&gt; = T extends U ? T : never;

type Ex2 = MyExtract&lt;string | number | boolean, string | boolean&gt;;
// = string | boolean
        </code></pre>
        <div class="tip fragment">
          분배를 <strong>막으려면</strong> 대괄호로 감싸세요:<br>
          <code>type NoDistribute&lt;T&gt; = [T] extends [any] ? T[] : never;</code><br>
          <code>NoDistribute&lt;string | number&gt;</code> = <code>(string | number)[]</code>
        </div>
      </section>

      <!-- Slide 7: Mapped Types -->
      <section data-narration="매핑된 타입은 기존 타입의 각 속성을 순회하면서 새로운 타입을 생성합니다. in keyof 문법으로 모든 키를 반복하고, as 절로 키 이름을 변환할 수 있습니다. 코드에서 Getters 타입은 User의 각 속성을 getter 함수로 변환하여 getId, getName 같은 메서드 타입을 자동 생성합니다. 수정자 제어로 readonly나 선택적 속성을 추가하거나 제거하는 것도 가능합니다.">
        <h2>매핑된 타입 (Mapped Type)</h2>
        <p>기존 타입의 각 프로퍼티를 변환하여 새 타입을 생성</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 문법: { [K in keyof T]: 새로운_타입 }
// "T의 각 키(K)에 대해 새로운 타입으로 변환하라"
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// 모든 프로퍼티를 getter 함수로 변환
// as 절로 키 이름을 "getName", "getEmail" 등으로 변환
type Getters&lt;T&gt; = {
  [K in keyof T as `get${Capitalize&lt;string & K&gt;}`]: () => T[K];
};

type UserGetters = Getters&lt;User&gt;;
// {
//   getId: () => number;
//   getName: () => string;
//   getEmail: () => string;
//   getAge: () => number;
// }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 수정자 제어: +/- readonly, +/- ?
type Mutable&lt;T&gt; = {
  -readonly [K in keyof T]: T[K];  // readonly 제거
};

type Concrete&lt;T&gt; = {
  [K in keyof T]-?: T[K];  // 선택적(?) 제거
};

type ReadonlyUser = { readonly name: string; readonly age: number };
type MutableUser = Mutable&lt;ReadonlyUser&gt;;
// { name: string; age: number }  <-- readonly 제거됨!
        </code></pre>
      </section>

      <!-- Slide 8: Custom Utility Types (NEW) -->
      <section data-narration="매핑된 타입과 조건부 타입을 조합하면 실전에서 유용한 커스텀 유틸리티 타입을 직접 만들 수 있습니다. 코드에서 Nullable은 모든 속성에 null을 허용하고, Mutable은 readonly를 제거합니다. Optional은 특정 키만 선택적으로 만드는 고급 유틸리티로, Pick과 Omit, Partial을 교차 타입으로 결합합니다. 이런 패턴을 익히면 프로젝트에 맞는 맞춤형 유틸리티 타입을 자유롭게 설계할 수 있습니다.">
        <h2>커스텀 유틸리티 타입 직접 만들기</h2>
        <p>매핑된 타입과 조건부 타입을 조합하여 실전 유틸리티 타입을 구현하기</p>
        <pre><code class="typescript" data-trim data-noescape>
// 1. Nullable: 모든 속성에 null을 허용
type Nullable&lt;T&gt; = {
  [K in keyof T]: T[K] | null;
};

interface User { id: number; name: string; email: string; }
type NullableUser = Nullable&lt;User&gt;;
// { id: number | null; name: string | null; email: string | null }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 2. Mutable: readonly 속성을 모두 수정 가능하게
type Mutable&lt;T&gt; = {
  -readonly [K in keyof T]: T[K];
};

type FrozenUser = { readonly id: number; readonly name: string };
type EditableUser = Mutable&lt;FrozenUser&gt;;
// { id: number; name: string }  ← readonly 제거됨!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 3. Optional: 특정 키만 선택적으로 만들기
// Pick으로 선택한 키를 Partial로 만들고, 나머지는 Omit으로 유지
type Optional&lt;T, K extends keyof T&gt; =
  Omit&lt;T, K&gt; & Partial&lt;Pick&lt;T, K&gt;&gt;;

interface CreateUserDTO {
  name: string;
  email: string;
  age: number;
  bio: string;
}

// age와 bio만 선택적으로!
type FlexibleUser = Optional&lt;CreateUserDTO, "age" | "bio"&gt;;
// { name: string; email: string; age?: number; bio?: string }
        </code></pre>
        <div class="key-point fragment">
          <h3>설계 원칙</h3>
          <p>커스텀 유틸리티 타입은 기존 내장 타입(Partial, Pick, Omit 등)을 <strong>조합</strong>하여 만듭니다.
          복잡한 타입도 작은 단위로 분해하면 이해하기 쉽습니다.</p>
        </div>
      </section>

      <!-- Slide 9: Mapped Types - Advanced -->
      <section data-narration="매핑된 타입 심화에서는 값의 타입에 따라 속성을 필터링하는 패턴을 다룹니다. 코드에서 PickByType은 as 절에서 값이 지정된 타입에 해당하지 않으면 never를 반환하여 해당 키를 제거합니다. EventMap은 각 속성 이름을 onChange 형태로 변환하고, 콜백 함수의 매개변수 타입도 원래 속성의 타입에 맞춰 자동으로 생성합니다. 이런 패턴은 폼 상태 관리나 이벤트 시스템 구축에 활용됩니다.">
        <h2>매핑된 타입 심화</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 특정 타입의 프로퍼티만 선택
// "값이 ValueType에 해당하는 키만 남기고, 나머지는 never로 제거"
type PickByType&lt;T, ValueType&gt; = {
  [K in keyof T as T[K] extends ValueType ? K : never]: T[K];
};

interface Model {
  id: number;
  name: string;
  active: boolean;
  email: string;
  count: number;
}

type StringProps = PickByType&lt;Model, string&gt;;
// { name: string; email: string }

type NumberProps = PickByType&lt;Model, number&gt;;
// { id: number; count: number }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 이벤트 핸들러 맵 자동 생성
type EventMap&lt;T&gt; = {
  [K in keyof T as `on${Capitalize&lt;string & K&gt;}Change`]:
    (newValue: T[K], oldValue: T[K]) => void;
};

interface FormState {
  username: string;
  password: string;
  rememberMe: boolean;
}

type FormEvents = EventMap&lt;FormState&gt;;
// {
//   onUsernameChange: (newValue: string, oldValue: string) => void;
//   onPasswordChange: (newValue: string, oldValue: string) => void;
//   onRememberMeChange: (newValue: boolean, oldValue: boolean) => void;
// }
        </code></pre>
      </section>

      <!-- Slide 10: Template Literal Types -->
      <section data-narration="템플릿 리터럴 타입은 문자열 리터럴 타입을 조합하여 새로운 문자열 타입을 만듭니다. 코드에서 Color와 Size 유니온을 백틱으로 조합하면 red-sm부터 blue-lg까지 총 9개의 문자열 조합이 자동 생성됩니다. Uppercase, Lowercase, Capitalize 같은 내장 문자열 변환 유틸리티도 제공됩니다. CSS 속성명이나 API 엔드포인트처럼 문자열 패턴이 있는 곳에서 타입 안전성을 제공합니다.">
        <h2>템플릿 리터럴 타입 (Template Literal Type)</h2>
        <p>문자열 리터럴 타입을 조합하여 새로운 문자열 타입 생성. JavaScript의 템플릿 리터럴(<code>`Hello ${name}`</code>)을 타입 세계에 가져온 것입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 사용
type Greeting = `Hello, ${string}!`;
const g1: Greeting = "Hello, World!";  // OK
// const g2: Greeting = "Hi, World!";  // Error!

// 유니온과 조합 -> 모든 조합이 자동 생성
type Color = "red" | "green" | "blue";
type Size = "sm" | "md" | "lg";

type ClassName = `${Color}-${Size}`;
// "red-sm" | "red-md" | "red-lg"
// | "green-sm" | "green-md" | "green-lg"
// | "blue-sm" | "blue-md" | "blue-lg"
// 총 9개의 조합!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 내장 문자열 변환 유틸리티
type Upper = Uppercase&lt;"hello"&gt;;       // "HELLO"
type Lower = Lowercase&lt;"HELLO"&gt;;       // "hello"
type Cap = Capitalize&lt;"hello"&gt;;        // "Hello"
type Uncap = Uncapitalize&lt;"Hello"&gt;;    // "hello"

// CSS 프로퍼티 타입 생성 예제
type CSSProperty = "margin" | "padding" | "border";
type Direction = "top" | "right" | "bottom" | "left";

type CSSDirectionalProp = `${CSSProperty}-${Direction}`;
// "margin-top" | "margin-right" | ... | "border-left"
// 총 12개!
        </code></pre>
      </section>

      <!-- Slide 11: Template Literal Types - Advanced -->
      <section data-narration="템플릿 리터럴 타입의 실전 활용을 살펴봅시다. 코드에서 EventName 타입은 객체의 각 키에 Changed 접미사를 붙여 이벤트 이름 유니온을 자동 생성합니다. PathOf 타입은 중첩 객체의 모든 점 표기법 경로를 문자열 리터럴 유니온으로 표현합니다. 예를 들어 Config 타입에서 db.host, db.credentials.user 같은 모든 가능한 경로를 타입으로 추출하여 안전한 설정 접근을 보장합니다.">
        <h2>템플릿 리터럴 타입 실전</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 타입 안전한 이벤트 시스템
type EventName&lt;T&gt; = {
  [K in keyof T & string]: `${K}Changed`
}[keyof T & string];

interface UserState {
  name: string;
  age: number;
  active: boolean;
}

type UserEvents = EventName&lt;UserState&gt;;
// "nameChanged" | "ageChanged" | "activeChanged"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 점 표기법(dot notation) 경로 타입: 중첩 객체의 경로를 문자열로 표현
type PathOf&lt;T, Prefix extends string = ""&gt; = {
  [K in keyof T & string]: T[K] extends object
    ? `${Prefix}${K}` | PathOf&lt;T[K], `${Prefix}${K}.`&gt;
    : `${Prefix}${K}`;
}[keyof T & string];

interface Config {
  db: {
    host: string;
    port: number;
    credentials: {
      user: string;
      password: string;
    };
  };
  cache: {
    ttl: number;
  };
}

type ConfigPath = PathOf&lt;Config&gt;;
// "db" | "db.host" | "db.port" | "db.credentials"
// | "db.credentials.user" | "db.credentials.password"
// | "cache" | "cache.ttl"
        </code></pre>
      </section>

      <!-- Slide 12: Key Remapping in Mapped Types -->
      <section data-narration="매핑된 타입에서 as 절을 사용하면 키 이름을 자유롭게 변환하거나 필터링할 수 있습니다. 코드에서 PrefixKeys는 모든 키에 접두사를 붙이고, OmitByType은 as 절에서 값 타입이 U에 해당하면 never를 반환하여 해당 키를 완전히 제거합니다. Mixed 인터페이스에서 string 타입 속성만 제거하면 age와 active만 남게 됩니다. 이 패턴은 API 응답 타입을 변환하거나 특정 조건의 속성만 추출할 때 유용합니다.">
        <h2>키 재매핑 (Key Remapping)</h2>
        <p><code>as</code> 절로 매핑된 타입의 키(프로퍼티 이름)를 변환</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 키 재매핑
type PrefixKeys&lt;T, P extends string&gt; = {
  [K in keyof T as `${P}_${string & K}`]: T[K];
};

interface API {
  getUser: () => User;
  getPost: () => Post;
}

type PrefixedAPI = PrefixKeys&lt;API, "api"&gt;;
// { api_getUser: () => User; api_getPost: () => Post }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 키 필터링: as 절에서 never를 반환하면 해당 키가 제거됨
type RemoveReadonly&lt;T&gt; = {
  [K in keyof T as K extends `readonly_${string}` ? never : K]: T[K];
};

// 특정 타입의 프로퍼티만 제거 (값이 U 타입이면 never로 키 삭제)
type OmitByType&lt;T, U&gt; = {
  [K in keyof T as T[K] extends U ? never : K]: T[K];
};

interface Mixed {
  name: string;
  age: number;
  active: boolean;
  email: string;
}

type WithoutStrings = OmitByType&lt;Mixed, string&gt;;
// { age: number; active: boolean }

type WithoutNumbers = OmitByType&lt;Mixed, number&gt;;
// { name: string; active: boolean; email: string }
        </code></pre>
      </section>

      <!-- Slide 13: Built-in Utility Types Deep Dive -->
      <section data-narration="타입스크립트가 제공하는 내장 유틸리티 타입의 동작 원리를 살펴봅시다. ReturnType은 typeof와 함께 사용하여 함수의 반환 타입을 추출하고, Parameters는 매개변수를 튜플로 추출합니다. 코드에서 createUser 함수의 반환 타입을 별도의 인터페이스 없이 자동으로 추출하는 모습을 보여줍니다. Awaited는 중첩된 Promise를 재귀적으로 풀어 최종 값의 타입을 얻으며, 비동기 코드에서 매우 유용합니다.">
        <h2>내장 유틸리티 타입 심화</h2>
        <pre><code class="typescript" data-trim data-noescape>
// ReturnType: 함수의 반환 타입 추출
function createUser(name: string, age: number) {
  return { id: Math.random(), name, age, createdAt: new Date() };
}
type User = ReturnType&lt;typeof createUser&gt;;
// { id: number; name: string; age: number; createdAt: Date }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Parameters: 함수 매개변수 타입을 튜플로 추출
type CreateUserParams = Parameters&lt;typeof createUser&gt;;
// [name: string, age: number]

// ConstructorParameters: 생성자 매개변수 추출
class HttpClient {
  constructor(baseUrl: string, timeout: number, headers?: Record&lt;string, string&gt;) {}
}
type HttpClientArgs = ConstructorParameters&lt;typeof HttpClient&gt;;
// [baseUrl: string, timeout: number, headers?: Record&lt;string, string&gt;]
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Awaited: Promise를 재귀적으로 풀기 (TS 4.5+)
type A1 = Awaited&lt;Promise&lt;string&gt;&gt;;                    // string
type A2 = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;;           // number
type A3 = Awaited&lt;string | Promise&lt;number&gt;&gt;;            // string | number

// ThisParameterType / OmitThisParameter
function greet(this: { name: string }, greeting: string) {
  return `${greeting}, ${this.name}!`;
}
type ThisType = ThisParameterType&lt;typeof greet&gt;; // { name: string }
type WithoutThis = OmitThisParameter&lt;typeof greet&gt;; // (greeting: string) => string
        </code></pre>
      </section>

      <!-- Slide 14: Utility Types Table -->
      <section data-narration="고급 유틸리티 타입을 한눈에 정리해 봅시다. ReturnType은 함수의 반환 타입을 추출하고, Parameters는 매개변수를 튜플로 변환합니다. ConstructorParameters와 InstanceType은 클래스 관련 타입을 다루며, Awaited는 Promise를 재귀적으로 풀어줍니다. Uppercase와 Capitalize는 문자열 리터럴 타입을 대문자로 변환합니다. 이 표를 참고하여 상황에 맞는 유틸리티를 선택하세요.">
        <h2>고급 유틸리티 타입 한눈에 보기</h2>
        <table class="compare-table" style="font-size: 0.65em;">
          <thead>
            <tr>
              <th>유틸리티 타입</th>
              <th>설명</th>
              <th>입력 / 출력</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fragment">
              <td><code>ReturnType&lt;F&gt;</code></td>
              <td>함수 반환 타입</td>
              <td><code>() => string</code> &rarr; <code>string</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Parameters&lt;F&gt;</code></td>
              <td>함수 매개변수 튜플</td>
              <td><code>(a: string) => void</code> &rarr; <code>[string]</code></td>
            </tr>
            <tr class="fragment">
              <td><code>ConstructorParameters&lt;C&gt;</code></td>
              <td>생성자 매개변수 튜플</td>
              <td>클래스의 constructor 매개변수</td>
            </tr>
            <tr class="fragment">
              <td><code>InstanceType&lt;C&gt;</code></td>
              <td>클래스 인스턴스 타입</td>
              <td><code>typeof MyClass</code> &rarr; <code>MyClass</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Awaited&lt;T&gt;</code></td>
              <td>Promise 풀기</td>
              <td><code>Promise&lt;string&gt;</code> &rarr; <code>string</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Uppercase&lt;S&gt;</code></td>
              <td>문자열 대문자 변환</td>
              <td><code>"hello"</code> &rarr; <code>"HELLO"</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Capitalize&lt;S&gt;</code></td>
              <td>첫 글자 대문자</td>
              <td><code>"hello"</code> &rarr; <code>"Hello"</code></td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 15: Recursive Types -->
      <section data-narration="재귀 타입은 자기 자신을 참조하여 중첩된 데이터 구조를 표현합니다. 코드에서 JSONValue 타입은 문자열, 숫자, 불리언, null에 더해 JSONValue의 배열과 객체를 포함하므로 무한히 중첩 가능합니다. TreeNode는 파일과 폴더를 판별 유니온으로 구분하며, 폴더의 children이 다시 TreeNode 배열을 가져 트리 구조를 형성합니다. 재귀 타입은 JSON 파싱, DOM 구조, 설정 파일 등 다양한 곳에서 활용됩니다.">
        <h2>재귀 타입 (Recursive Type)</h2>
        <p>자기 자신을 참조하는 타입으로 트리 구조 등을 표현. "폴더 안에 폴더가 있는" 것처럼 중첩되는 구조를 타입으로 표현할 수 있습니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// JSON 값 타입 (재귀적 정의)
// JSONValue 안에 JSONValue가 또 들어갈 수 있음 (자기 자신 참조!)
type JSONValue =
  | string                         // 문자열
  | number                         // 숫자
  | boolean                        // 참/거짓
  | null                           // 없음
  | JSONValue[]                    // JSON 값의 배열 (재귀!)
  | { [key: string]: JSONValue };  // JSON 값의 객체 (재귀!)

const data: JSONValue = {
  name: "홍길동",
  age: 30,
  hobbies: ["코딩", "독서"],
  address: {
    city: "서울",
    zip: "12345",
    coordinates: [37.5665, 126.9780]
  }
};
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 파일 시스템 트리
interface FileNode {
  name: string;
  type: "file";
  size: number;
}

interface FolderNode {
  name: string;
  type: "folder";
  children: TreeNode[];  // 재귀!
}

type TreeNode = FileNode | FolderNode;

const project: TreeNode = {
  name: "src", type: "folder",
  children: [
    { name: "index.ts", type: "file", size: 1024 },
    { name: "utils", type: "folder", children: [
      { name: "helper.ts", type: "file", size: 512 }
    ]}
  ]
};
        </code></pre>
      </section>

      <!-- Slide 16: Recursive Type Utilities -->
      <section data-narration="재귀 타입을 활용하면 중첩된 객체의 모든 레벨에 변환을 적용하는 유틸리티 타입을 만들 수 있습니다. 코드에서 DeepReadonly는 배열이면 읽기 전용 배열로, 객체이면 각 속성에 재귀적으로 readonly를 적용하고, 원시 타입이면 그대로 반환합니다. DeepPartial은 모든 중첩 속성을 선택적으로 만들어 설정 병합 함수에서 유용하게 사용됩니다. 내장 Readonly와 Partial은 1단계만 적용되지만, 이 재귀 버전은 모든 깊이에 적용됩니다.">
        <h2>재귀 타입 유틸리티</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 깊은 읽기전용 (Deep Readonly)
// 일반 Readonly는 1단계만 적용되지만, 이것은 모든 중첩 레벨에 적용
type DeepReadonly&lt;T&gt; =
  T extends (infer U)[]                              // 배열이면?
    ? ReadonlyArray&lt;DeepReadonly&lt;U&gt;&gt;                  // 읽기전용 배열로 + 요소도 재귀
    : T extends object                                // 객체면?
    ? { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; } // 각 프로퍼티에 재귀 적용
    : T;                                              // 원시 타입이면 그대로

interface Config {
  db: { host: string; ports: number[] };
  features: { dark: boolean };
}

type FrozenConfig = DeepReadonly&lt;Config&gt;;
// {
//   readonly db: {
//     readonly host: string;
//     readonly ports: ReadonlyArray&lt;number&gt;
//   };
//   readonly features: { readonly dark: boolean };
// }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 깊은 Partial (Deep Partial)
type DeepPartial&lt;T&gt; = T extends object ? {
  [K in keyof T]?: DeepPartial&lt;T[K]&gt;;
} : T;

type PartialConfig = DeepPartial&lt;Config&gt;;
// db?, db.host?, db.ports?, features?, features.dark?
// 모든 중첩 프로퍼티가 선택적으로!

// 설정 병합에 유용
function mergeConfig(
  defaults: Config,
  overrides: DeepPartial&lt;Config&gt;
): Config {
  // 깊은 병합 로직...
  return { ...defaults, ...overrides } as Config;
}
        </code></pre>
      </section>

      <!-- Slide 17: Branded Types / Opaque Types -->
      <section data-narration="브랜디드 타입은 구조적으로 같은 타입을 의미적으로 구분하는 기법입니다. 타입스크립트는 구조가 같으면 같은 타입으로 취급하므로, UserId와 PostId가 둘 다 number여도 구분이 안 됩니다. 코드에서 Brand 제네릭 타입은 보이지 않는 브랜드 태그를 교차 타입으로 추가하여 타입을 구분합니다. 팩토리 함수 createUserId와 createPostId를 통해서만 브랜디드 값을 생성할 수 있어 타입 혼용을 컴파일 타임에 방지합니다.">
        <h2>브랜디드 타입 (Branded Type)</h2>
        <p>구조적 타입 시스템에서 <strong>명목적 타입</strong>(이름이 다르면 다른 타입)을 흉내내는 기법</p>
        <div class="tip" style="margin-bottom: 0.3em; font-size: 0.7em;">
          <strong>왜 이게 필요한가?</strong> TypeScript에서는 구조(모양)가 같으면 같은 타입으로 취급합니다. 하지만 "사용자 ID"와 "게시글 ID"는 둘 다 숫자여도 섞이면 안 됩니다. 브랜디드 타입은 이런 혼동을 막아줍니다.
        </div>
        <pre><code class="typescript" data-trim data-noescape>
// 문제: 구조가 같으면 같은 타입으로 취급됨
type UserId = number;   // 사용자 ID
type PostId = number;   // 게시글 ID (둘 다 그냥 number!)

function getUser(id: UserId) { /* ... */ }
function getPost(id: PostId) { /* ... */ }

const userId: UserId = 1;
const postId: PostId = 2;
getUser(postId); // 에러 없음! 하지만 논리적 버그!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 해결: 브랜디드 타입으로 구별
// 보이지 않는 "브랜드 태그"를 붙여서 타입을 구분
type Brand&lt;T, B extends string&gt; = T & { readonly __brand: B };

type UserId = Brand&lt;number, "UserId"&gt;;
type PostId = Brand&lt;number, "PostId"&gt;;

// 생성 함수 (팩토리)
function createUserId(id: number): UserId {
  return id as UserId;
}
function createPostId(id: number): PostId {
  return id as PostId;
}

function getUser(id: UserId) { /* ... */ }

const userId = createUserId(1);
const postId = createPostId(2);

getUser(userId);  // OK!
// getUser(postId);  // Error! PostId는 UserId에 할당 불가!
// getUser(42);      // Error! number는 UserId에 할당 불가!
        </code></pre>
      </section>

      <!-- Slide 18: Branded Types - Practical -->
      <section data-narration="브랜디드 타입을 실전에서 활용하면 검증된 값과 검증되지 않은 값을 타입 레벨에서 구분할 수 있습니다. 코드에서 Email, PositiveNumber, NonEmptyString은 각각 검증 함수를 통과해야만 해당 브랜드를 획득합니다. sendEmail 함수는 Email 타입만 받으므로, 검증되지 않은 일반 문자열을 전달하면 컴파일 에러가 발생합니다. 이 패턴은 런타임 에러를 컴파일 타임으로 앞당겨 코드 안전성을 크게 높입니다.">
        <h2>브랜디드 타입 실전 활용</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 유효성이 검증된 값을 타입으로 보장하는 실전 패턴
type Brand&lt;T, B extends string&gt; = T & { readonly __brand: B };

type Email = Brand&lt;string, "Email"&gt;;              // 검증된 이메일
type PositiveNumber = Brand&lt;number, "PositiveNumber"&gt;; // 양수만
type NonEmptyString = Brand&lt;string, "NonEmptyString"&gt;; // 비어있지 않은 문자열

// 검증 함수 = 브랜드를 부여하는 함수 (검증 통과해야만 타입 획득)
function validateEmail(input: string): Email {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(input)) {
    throw new Error(`유효하지 않은 이메일: ${input}`);
  }
  return input as Email;
}

function toPositive(n: number): PositiveNumber {
  if (n <= 0) throw new Error("양수여야 합니다");
  return n as PositiveNumber;
}

// 검증된 값만 받는 함수
function sendEmail(to: Email, subject: string) {
  // to는 이미 검증된 이메일 주소!
  console.log(`메일 발송: ${to}`);
}

const email = validateEmail("user@example.com"); // Email
sendEmail(email, "안녕하세요");                    // OK!
// sendEmail("not-validated", "테스트");           // Error!
        </code></pre>
        <div class="key-point fragment">
          <h3>핵심 장점</h3>
          <p>"검증되지 않은 값"과 "검증된 값"을 <strong>타입 레벨에서 구분</strong>하여<br>
          런타임 (Runtime, 실행 시점) 에러를 컴파일 타임 (Compile Time, 코드 변환 시점)에 방지합니다.</p>
        </div>
      </section>

      <!-- Slide 19: Type-Level Programming -->
      <section data-narration="타입 레벨 프로그래밍은 타입 시스템 자체를 프로그래밍 언어처럼 사용하는 고급 기법입니다. 코드에서 CamelToKebab 타입은 문자열의 각 문자를 재귀적으로 순회하며 대문자를 만나면 하이픈과 소문자로 변환합니다. BuildTuple과 Add는 튜플의 길이를 이용하여 타입 레벨에서 덧셈을 수행합니다. Reverse는 배열을 재귀적으로 뒤집습니다. 이런 기법은 강력하지만 팀원 모두가 이해할 수 있는 수준을 유지하는 것이 중요합니다.">
        <h2>타입 레벨 프로그래밍</h2>
        <p>타입 시스템 자체를 프로그래밍 언어처럼 활용하기. 값이 아닌 <strong>타입</strong>을 대상으로 조건문, 반복, 재귀 등을 수행합니다. 실행 시점(런타임)이 아닌 코드 작성 시점(컴파일 타임)에 모든 계산이 이루어집니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 타입 레벨 문자열 조작: camelCase -> kebab-case 변환
// 대문자를 만나면 앞에 "-"를 붙이고 소문자로 변환
type CamelToKebab&lt;S extends string&gt; =
  S extends `${infer Head}${infer Tail}`
    ? Head extends Uppercase&lt;Head&gt;
      ? `-${Lowercase&lt;Head&gt;}${CamelToKebab&lt;Tail&gt;}`
      : `${Head}${CamelToKebab&lt;Tail&gt;}`
    : S;

type K1 = CamelToKebab&lt;"backgroundColor"&gt;;  // "background-color"
type K2 = CamelToKebab&lt;"fontSize"&gt;;          // "font-size"
type K3 = CamelToKebab&lt;"borderTopWidth"&gt;;    // "border-top-width"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 타입 레벨 덧셈 (튜플 길이를 이용한 트릭)
// 길이가 N인 튜플(배열)을 만들어서 길이로 숫자를 표현
type BuildTuple&lt;N extends number, T extends any[] = []&gt; =
  T["length"] extends N ? T : BuildTuple&lt;N, [...T, any]&gt;;

// 두 튜플을 합치면 길이가 합산됨 = 덧셈!
type Add&lt;A extends number, B extends number&gt; =
  [...BuildTuple&lt;A&gt;, ...BuildTuple&lt;B&gt;]["length"];

type Sum = Add&lt;3, 4&gt;;  // 7 (타입 레벨에서 계산!)

// 타입 레벨 배열 뒤집기 (재귀 활용)
type Reverse&lt;T extends any[]&gt; =
  T extends [infer First, ...infer Rest]
    ? [...Reverse&lt;Rest&gt;, First]  // 나머지를 뒤집고 첫 번째를 맨 뒤에
    : [];

type Rev = Reverse&lt;[1, 2, 3, 4]&gt;; // [4, 3, 2, 1]
        </code></pre>
        <div class="tip fragment">
          타입 레벨 프로그래밍은 강력하지만, 복잡도를 적절히 관리하세요.
          팀원 모두가 이해할 수 있는 수준을 유지하는 것이 중요합니다.
        </div>
      </section>

      <!-- Slide 20: Summary -->
      <section data-narration="챕터 8을 마치겠습니다. 가장 중요한 포인트는 조건부 타입과 infer로 타입을 추출하는 패턴, 그리고 매핑된 타입으로 속성을 일괄 변환하는 기법입니다. 실전에서는 내장 유틸리티 타입을 적극 활용하되, 필요하면 커스텀 유틸리티를 직접 만들어 보세요. 다음 챕터에서는 모듈과 네임스페이스를 통한 코드 구조화를 학습합니다.">
        <h2>Chapter 8 요약</h2>
        <div class="key-point">
          <h3>핵심 정리</h3>
          <ul>
            <li class="fragment"><strong>조건부 타입</strong>: <code>T extends U ? X : Y</code> - 타입 레벨 분기</li>
            <li class="fragment"><strong>infer</strong>: 조건부 타입 내에서 타입 추출 (함수 반환값, Promise 등)</li>
            <li class="fragment"><strong>분배 조건부 타입</strong>: 유니온 멤버에 자동으로 분배 적용</li>
            <li class="fragment"><strong>매핑된 타입</strong>: <code>[K in keyof T]</code>로 프로퍼티 일괄 변환</li>
            <li class="fragment"><strong>템플릿 리터럴 타입</strong>: 문자열 타입의 패턴 매칭과 조합</li>
            <li class="fragment"><strong>키 재매핑</strong>: <code>as</code>로 키 이름 변환 및 필터링</li>
            <li class="fragment"><strong>재귀 타입</strong>: DeepReadonly, DeepPartial 등 깊은 변환</li>
            <li class="fragment"><strong>브랜디드 타입</strong>: 구조적 타입 시스템에서 명목적 구별</li>
          </ul>
        </div>
        <br>
        <p class="fragment">
          <a href="07-type-narrowing.html" style="color: #888; font-size: 0.8em;">
            &larr; 이전: Chapter 7 - 타입 좁히기
          </a>
        </p>
      </section>

    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
