<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Chapter 8: 고급 타입 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-narration="챕터 8, 고급 타입입니다. 타입스크립트의 강력한 타입 레벨 프로그래밍을 배워보겠습니다.">
        <div class="chapter-number">Chapter 8</div>
        <h1>고급 타입</h1>
        <p class="subtitle">타입 시스템의 깊은 세계로</p>
        <br>
        <p style="font-size:0.6em; color:#888;">
          <span class="badge badge-blue">조건부 타입 (Conditional Type)</span>
          <span class="badge badge-green">매핑된 타입 (Mapped Type)</span>
          <span class="badge badge-orange">템플릿 리터럴 타입 (Template Literal Type)</span>
          <span class="badge badge-red">타입 레벨 프로그래밍</span>
        </p>
        <div class="tip" style="font-size:0.55em; margin-top: 1em;">
          이 장은 고급 내용입니다. 처음에 완벽히 이해하지 못해도 괜찮습니다. 필요할 때 다시 돌아와서 참고하세요.
        </div>
      </section>

      <!-- Slide 2: Conditional Types -->
      <section data-narration="조건부 타입은 삼항 연산자와 비슷하게, 조건에 따라 다른 타입을 반환합니다. extends 키워드를 사용하여 타입 간의 관계를 검사합니다.">
        <h2>조건부 타입 (Conditional Type)</h2>
        <p>타입 레벨(타입을 다루는 차원)의 삼항 연산자: <code>T extends U ? X : Y</code></p>
        <div class="tip" style="margin-bottom: 0.3em; font-size: 0.7em;">
          <strong>왜 이게 필요한가?</strong> 입력 타입에 따라 출력 타입을 자동으로 바꾸고 싶을 때 사용합니다. 예: "문자열을 넣으면 문자열을 반환하고, 숫자를 넣으면 숫자를 반환하는 함수"를 타입으로 표현할 수 있습니다.
        </div>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 문법: "T가 string에 해당하면 true, 아니면 false"
type IsString&lt;T&gt; = T extends string ? true : false;

type A = IsString&lt;string&gt;;    // true
type B = IsString&lt;number&gt;;    // false
type C = IsString&lt;"hello"&gt;;   // true (리터럴도 string을 확장)
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 중첩 조건부 타입
type TypeName&lt;T&gt; =
  T extends string ? "string" :
  T extends number ? "number" :
  T extends boolean ? "boolean" :
  T extends undefined ? "undefined" :
  T extends Function ? "function" :
  "object";

type T1 = TypeName&lt;string&gt;;       // "string"
type T2 = TypeName&lt;() => void&gt;;   // "function"
type T3 = TypeName&lt;string[]&gt;;     // "object"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: 배열이면 요소 타입 추출, 아니면 그대로
// infer U = "U라는 타입을 여기서 추출(추론)해라"
type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T;

type Str = Flatten&lt;string[]&gt;;     // string
type Num = Flatten&lt;number&gt;;       // number (배열이 아니므로 그대로)
        </code></pre>
      </section>

      <!-- Slide 3: infer Keyword -->
      <section data-narration="infer 키워드는 조건부 타입 안에서 타입을 추출하는 데 사용됩니다. 함수의 반환 타입이나 프로미스의 내부 타입을 꺼내올 수 있습니다.">
        <h2><code>infer</code> 키워드 (타입 추론/추출)</h2>
        <p>조건부 타입 안에서 타입을 <strong>추출(추론)</strong>하는 키워드. <code>infer R</code>은 "여기에 해당하는 타입을 R이라고 부르겠다"는 뜻입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 함수의 반환 타입 추출 (ReturnType의 내부 구현 원리)
// "T가 함수라면, 그 반환 타입을 R로 추출해라"
type MyReturnType&lt;T&gt; = T extends (...args: any[]) => infer R ? R : never;

type R1 = MyReturnType&lt;() => string&gt;;          // string
type R2 = MyReturnType&lt;(x: number) => boolean&gt;; // boolean
type R3 = MyReturnType&lt;string&gt;;                 // never
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 함수의 매개변수 타입 추출 (Parameters의 내부 구현 원리)
// "T가 함수라면, 그 매개변수 타입들을 P로 추출해라"
type MyParameters&lt;T&gt; = T extends (...args: infer P) => any ? P : never;

type P1 = MyParameters&lt;(a: string, b: number) => void&gt;;
// [a: string, b: number]
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Promise 내부 타입 추출
type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;

type V1 = UnwrapPromise&lt;Promise&lt;string&gt;&gt;;   // string
type V2 = UnwrapPromise&lt;Promise&lt;number[]&gt;&gt;; // number[]
type V3 = UnwrapPromise&lt;string&gt;;             // string (Promise가 아님)

// 중첩 Promise도 재귀적으로 풀기 (자기 자신을 다시 호출)
type DeepUnwrap&lt;T&gt; = T extends Promise&lt;infer U&gt; ? DeepUnwrap&lt;U&gt; : T;

type V4 = DeepUnwrap&lt;Promise&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;&gt;; // number
        </code></pre>
      </section>

      <!-- Slide 4: More infer Patterns -->
      <section data-narration="infer를 활용하면 함수의 매개변수 타입, 배열의 요소 타입, 프로미스의 결과 타입 등을 동적으로 추출할 수 있습니다.">
        <h2><code>infer</code> 활용 패턴</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 배열의 첫 번째 요소 타입 추출
// [infer F, ...any[]] = "첫 번째를 F로, 나머지는 아무거나"
type First&lt;T extends any[]&gt; = T extends [infer F, ...any[]] ? F : never;

type F1 = First&lt;[string, number, boolean]&gt;;  // string
type F2 = First&lt;[42, "hello"]&gt;;              // 42
type F3 = First&lt;[]&gt;;                          // never
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 배열의 마지막 요소 타입 추출
type Last&lt;T extends any[]&gt; = T extends [...any[], infer L] ? L : never;

type L1 = Last&lt;[string, number, boolean]&gt;;  // boolean
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 생성자의 인스턴스 타입 추출
type InstanceOf&lt;T&gt; = T extends new (...args: any[]) => infer I ? I : never;

class UserModel {
  constructor(public name: string) {}
}

type UserInstance = InstanceOf&lt;typeof UserModel&gt;; // UserModel

// 문자열에서 패턴 매칭: URL 경로의 :파라미터 이름 추출
type ExtractRouteParams&lt;T extends string&gt; =
  T extends `${string}:${infer Param}/${infer Rest}`
    ? Param | ExtractRouteParams&lt;Rest&gt;
    : T extends `${string}:${infer Param}`
    ? Param
    : never;

type Params = ExtractRouteParams&lt;"/users/:userId/posts/:postId"&gt;;
// "userId" | "postId"
        </code></pre>
      </section>

      <!-- Slide 5: Distributive Conditional Types -->
      <section data-narration="유니온 타입에 조건부 타입을 적용하면 각 멤버에 개별적으로 조건이 적용됩니다. 이것을 분배 조건부 타입이라고 합니다.">
        <h2>분배 조건부 타입 (Distributive)</h2>
        <p>유니온 타입이 조건부 타입에 들어가면 <strong>각 멤버에 하나씩 분배</strong>되어 적용됩니다. 마치 "한 명씩 줄 서서 처리"하는 것과 같습니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
type ToArray&lt;T&gt; = T extends any ? T[] : never;

// 유니온이 분배됨!
type Result = ToArray&lt;string | number&gt;;
// = ToArray&lt;string&gt; | ToArray&lt;number&gt;
// = string[] | number[]
// (string | number)[]가 아님에 주의!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Exclude 구현 원리 (분배 활용)
// "T의 각 멤버를 하나씩 확인해서, U에 해당하면 제거(never)"
type MyExclude&lt;T, U&gt; = T extends U ? never : T;

type Ex1 = MyExclude&lt;"a" | "b" | "c", "a"&gt;;
// = ("a" extends "a" ? never : "a")
//   | ("b" extends "a" ? never : "b")
//   | ("c" extends "a" ? never : "c")
// = never | "b" | "c"
// = "b" | "c"

// Extract 구현 원리
type MyExtract&lt;T, U&gt; = T extends U ? T : never;

type Ex2 = MyExtract&lt;string | number | boolean, string | boolean&gt;;
// = string | boolean
        </code></pre>
        <div class="tip fragment">
          분배를 <strong>막으려면</strong> 대괄호로 감싸세요:<br>
          <code>type NoDistribute&lt;T&gt; = [T] extends [any] ? T[] : never;</code><br>
          <code>NoDistribute&lt;string | number&gt;</code> = <code>(string | number)[]</code>
        </div>
      </section>

      <!-- Slide 6: Mapped Types -->
      <section data-narration="매핑된 타입은 기존 타입의 각 속성을 순회하면서 새로운 타입을 생성합니다. in 키워드와 keyof를 조합하여 속성을 변환합니다.">
        <h2>매핑된 타입 (Mapped Type)</h2>
        <p>기존 타입의 각 프로퍼티를 변환하여 새 타입을 생성</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 문법: { [K in keyof T]: 새로운_타입 }
// "T의 각 키(K)에 대해 새로운 타입으로 변환하라"
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// 모든 프로퍼티를 getter 함수로 변환
// as 절로 키 이름을 "getName", "getEmail" 등으로 변환
type Getters&lt;T&gt; = {
  [K in keyof T as `get${Capitalize&lt;string & K&gt;}`]: () => T[K];
};

type UserGetters = Getters&lt;User&gt;;
// {
//   getId: () => number;
//   getName: () => string;
//   getEmail: () => string;
//   getAge: () => number;
// }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 수정자 제어: +/- readonly, +/- ?
type Mutable&lt;T&gt; = {
  -readonly [K in keyof T]: T[K];  // readonly 제거
};

type Concrete&lt;T&gt; = {
  [K in keyof T]-?: T[K];  // 선택적(?) 제거
};

type ReadonlyUser = { readonly name: string; readonly age: number };
type MutableUser = Mutable&lt;ReadonlyUser&gt;;
// { name: string; age: number }  <-- readonly 제거됨!
        </code></pre>
      </section>

      <!-- Slide 7: Mapped Types - Advanced -->
      <section data-narration="매핑된 타입에서 속성의 modifier를 추가하거나 제거할 수 있습니다. 더하기와 빼기 기호를 사용하여 readonly나 선택적 속성을 조절합니다.">
        <h2>매핑된 타입 심화</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 특정 타입의 프로퍼티만 선택
// "값이 ValueType에 해당하는 키만 남기고, 나머지는 never로 제거"
type PickByType&lt;T, ValueType&gt; = {
  [K in keyof T as T[K] extends ValueType ? K : never]: T[K];
};

interface Model {
  id: number;
  name: string;
  active: boolean;
  email: string;
  count: number;
}

type StringProps = PickByType&lt;Model, string&gt;;
// { name: string; email: string }

type NumberProps = PickByType&lt;Model, number&gt;;
// { id: number; count: number }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 이벤트 핸들러 맵 자동 생성
type EventMap&lt;T&gt; = {
  [K in keyof T as `on${Capitalize&lt;string & K&gt;}Change`]:
    (newValue: T[K], oldValue: T[K]) => void;
};

interface FormState {
  username: string;
  password: string;
  rememberMe: boolean;
}

type FormEvents = EventMap&lt;FormState&gt;;
// {
//   onUsernameChange: (newValue: string, oldValue: string) => void;
//   onPasswordChange: (newValue: string, oldValue: string) => void;
//   onRememberMeChange: (newValue: boolean, oldValue: boolean) => void;
// }
        </code></pre>
      </section>

      <!-- Slide 8: Template Literal Types -->
      <section data-narration="템플릿 리터럴 타입은 문자열 리터럴 타입을 조합하여 새로운 문자열 타입을 만듭니다. 백틱 안에 타입을 삽입하여 패턴을 정의할 수 있습니다.">
        <h2>템플릿 리터럴 타입 (Template Literal Type)</h2>
        <p>문자열 리터럴 타입을 조합하여 새로운 문자열 타입 생성. JavaScript의 템플릿 리터럴(<code>`Hello ${name}`</code>)을 타입 세계에 가져온 것입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 사용
type Greeting = `Hello, ${string}!`;
const g1: Greeting = "Hello, World!";  // OK
// const g2: Greeting = "Hi, World!";  // Error!

// 유니온과 조합 -> 모든 조합이 자동 생성
type Color = "red" | "green" | "blue";
type Size = "sm" | "md" | "lg";

type ClassName = `${Color}-${Size}`;
// "red-sm" | "red-md" | "red-lg"
// | "green-sm" | "green-md" | "green-lg"
// | "blue-sm" | "blue-md" | "blue-lg"
// 총 9개의 조합!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 내장 문자열 변환 유틸리티
type Upper = Uppercase&lt;"hello"&gt;;       // "HELLO"
type Lower = Lowercase&lt;"HELLO"&gt;;       // "hello"
type Cap = Capitalize&lt;"hello"&gt;;        // "Hello"
type Uncap = Uncapitalize&lt;"Hello"&gt;;    // "hello"

// CSS 프로퍼티 타입 생성 예제
type CSSProperty = "margin" | "padding" | "border";
type Direction = "top" | "right" | "bottom" | "left";

type CSSDirectionalProp = `${CSSProperty}-${Direction}`;
// "margin-top" | "margin-right" | ... | "border-left"
// 총 12개!
        </code></pre>
      </section>

      <!-- Slide 9: Template Literal Types - Advanced -->
      <section data-narration="템플릿 리터럴 타입은 CSS 속성명, API 엔드포인트, 이벤트 이름 등 문자열 패턴이 있는 곳에서 타입 안전성을 제공합니다.">
        <h2>템플릿 리터럴 타입 실전</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 타입 안전한 이벤트 시스템
type EventName&lt;T&gt; = {
  [K in keyof T & string]: `${K}Changed`
}[keyof T & string];

interface UserState {
  name: string;
  age: number;
  active: boolean;
}

type UserEvents = EventName&lt;UserState&gt;;
// "nameChanged" | "ageChanged" | "activeChanged"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 점 표기법(dot notation) 경로 타입: 중첩 객체의 경로를 문자열로 표현
type PathOf&lt;T, Prefix extends string = ""&gt; = {
  [K in keyof T & string]: T[K] extends object
    ? `${Prefix}${K}` | PathOf&lt;T[K], `${Prefix}${K}.`&gt;
    : `${Prefix}${K}`;
}[keyof T & string];

interface Config {
  db: {
    host: string;
    port: number;
    credentials: {
      user: string;
      password: string;
    };
  };
  cache: {
    ttl: number;
  };
}

type ConfigPath = PathOf&lt;Config&gt;;
// "db" | "db.host" | "db.port" | "db.credentials"
// | "db.credentials.user" | "db.credentials.password"
// | "cache" | "cache.ttl"
        </code></pre>
      </section>

      <!-- Slide 10: Key Remapping in Mapped Types -->
      <section data-narration="매핑된 타입에서 as 절을 사용하면 키를 변환할 수 있습니다. 기존 키에 접두사를 붙이거나, 특정 키를 필터링하는 등의 작업이 가능합니다.">
        <h2>키 재매핑 (Key Remapping)</h2>
        <p><code>as</code> 절로 매핑된 타입의 키(프로퍼티 이름)를 변환</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 키 재매핑
type PrefixKeys&lt;T, P extends string&gt; = {
  [K in keyof T as `${P}_${string & K}`]: T[K];
};

interface API {
  getUser: () => User;
  getPost: () => Post;
}

type PrefixedAPI = PrefixKeys&lt;API, "api"&gt;;
// { api_getUser: () => User; api_getPost: () => Post }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 키 필터링: as 절에서 never를 반환하면 해당 키가 제거됨
type RemoveReadonly&lt;T&gt; = {
  [K in keyof T as K extends `readonly_${string}` ? never : K]: T[K];
};

// 특정 타입의 프로퍼티만 제거 (값이 U 타입이면 never로 키 삭제)
type OmitByType&lt;T, U&gt; = {
  [K in keyof T as T[K] extends U ? never : K]: T[K];
};

interface Mixed {
  name: string;
  age: number;
  active: boolean;
  email: string;
}

type WithoutStrings = OmitByType&lt;Mixed, string&gt;;
// { age: number; active: boolean }

type WithoutNumbers = OmitByType&lt;Mixed, number&gt;;
// { name: string; active: boolean; email: string }
        </code></pre>
      </section>

      <!-- Slide 11: Built-in Utility Types Deep Dive -->
      <section data-narration="Exclude, Extract, NonNullable, Parameters, ReturnType 등 타입스크립트가 제공하는 내장 유틸리티 타입의 동작 원리를 살펴봅시다.">
        <h2>내장 유틸리티 타입 심화</h2>
        <pre><code class="typescript" data-trim data-noescape>
// ReturnType: 함수의 반환 타입 추출
function createUser(name: string, age: number) {
  return { id: Math.random(), name, age, createdAt: new Date() };
}
type User = ReturnType&lt;typeof createUser&gt;;
// { id: number; name: string; age: number; createdAt: Date }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Parameters: 함수 매개변수 타입을 튜플로 추출
type CreateUserParams = Parameters&lt;typeof createUser&gt;;
// [name: string, age: number]

// ConstructorParameters: 생성자 매개변수 추출
class HttpClient {
  constructor(baseUrl: string, timeout: number, headers?: Record&lt;string, string&gt;) {}
}
type HttpClientArgs = ConstructorParameters&lt;typeof HttpClient&gt;;
// [baseUrl: string, timeout: number, headers?: Record&lt;string, string&gt;]
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Awaited: Promise를 재귀적으로 풀기 (TS 4.5+)
type A1 = Awaited&lt;Promise&lt;string&gt;&gt;;                    // string
type A2 = Awaited&lt;Promise&lt;Promise&lt;number&gt;&gt;&gt;;           // number
type A3 = Awaited&lt;string | Promise&lt;number&gt;&gt;;            // string | number

// ThisParameterType / OmitThisParameter
function greet(this: { name: string }, greeting: string) {
  return `${greeting}, ${this.name}!`;
}
type ThisType = ThisParameterType&lt;typeof greet&gt;; // { name: string }
type WithoutThis = OmitThisParameter&lt;typeof greet&gt;; // (greeting: string) => string
        </code></pre>
      </section>

      <!-- Slide 12: Utility Types Table -->
      <section data-narration="문자열 조작 타입인 Uppercase, Lowercase, Capitalize와 함수 관련 타입인 Parameters, ReturnType 등을 정리해 봅시다.">
        <h2>고급 유틸리티 타입 한눈에 보기</h2>
        <table class="compare-table" style="font-size: 0.65em;">
          <thead>
            <tr>
              <th>유틸리티 타입</th>
              <th>설명</th>
              <th>입력 / 출력</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fragment">
              <td><code>ReturnType&lt;F&gt;</code></td>
              <td>함수 반환 타입</td>
              <td><code>() => string</code> &rarr; <code>string</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Parameters&lt;F&gt;</code></td>
              <td>함수 매개변수 튜플</td>
              <td><code>(a: string) => void</code> &rarr; <code>[string]</code></td>
            </tr>
            <tr class="fragment">
              <td><code>ConstructorParameters&lt;C&gt;</code></td>
              <td>생성자 매개변수 튜플</td>
              <td>클래스의 constructor 매개변수</td>
            </tr>
            <tr class="fragment">
              <td><code>InstanceType&lt;C&gt;</code></td>
              <td>클래스 인스턴스 타입</td>
              <td><code>typeof MyClass</code> &rarr; <code>MyClass</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Awaited&lt;T&gt;</code></td>
              <td>Promise 풀기</td>
              <td><code>Promise&lt;string&gt;</code> &rarr; <code>string</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Uppercase&lt;S&gt;</code></td>
              <td>문자열 대문자 변환</td>
              <td><code>"hello"</code> &rarr; <code>"HELLO"</code></td>
            </tr>
            <tr class="fragment">
              <td><code>Capitalize&lt;S&gt;</code></td>
              <td>첫 글자 대문자</td>
              <td><code>"hello"</code> &rarr; <code>"Hello"</code></td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 13: Recursive Types -->
      <section data-narration="재귀 타입은 자기 자신을 참조하는 타입입니다. JSON 값이나 트리 구조처럼 중첩된 데이터를 표현할 때 사용됩니다.">
        <h2>재귀 타입 (Recursive Type)</h2>
        <p>자기 자신을 참조하는 타입으로 트리 구조 등을 표현. "폴더 안에 폴더가 있는" 것처럼 중첩되는 구조를 타입으로 표현할 수 있습니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// JSON 값 타입 (재귀적 정의)
// JSONValue 안에 JSONValue가 또 들어갈 수 있음 (자기 자신 참조!)
type JSONValue =
  | string                         // 문자열
  | number                         // 숫자
  | boolean                        // 참/거짓
  | null                           // 없음
  | JSONValue[]                    // JSON 값의 배열 (재귀!)
  | { [key: string]: JSONValue };  // JSON 값의 객체 (재귀!)

const data: JSONValue = {
  name: "홍길동",
  age: 30,
  hobbies: ["코딩", "독서"],
  address: {
    city: "서울",
    zip: "12345",
    coordinates: [37.5665, 126.9780]
  }
};
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 파일 시스템 트리
interface FileNode {
  name: string;
  type: "file";
  size: number;
}

interface FolderNode {
  name: string;
  type: "folder";
  children: TreeNode[];  // 재귀!
}

type TreeNode = FileNode | FolderNode;

const project: TreeNode = {
  name: "src", type: "folder",
  children: [
    { name: "index.ts", type: "file", size: 1024 },
    { name: "utils", type: "folder", children: [
      { name: "helper.ts", type: "file", size: 512 }
    ]}
  ]
};
        </code></pre>
      </section>

      <!-- Slide 14: Recursive Type Utilities -->
      <section data-narration="DeepReadonly나 DeepPartial처럼 재귀적으로 중첩된 객체의 모든 속성을 변환하는 유틸리티 타입을 만들 수 있습니다.">
        <h2>재귀 타입 유틸리티</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 깊은 읽기전용 (Deep Readonly)
// 일반 Readonly는 1단계만 적용되지만, 이것은 모든 중첩 레벨에 적용
type DeepReadonly&lt;T&gt; =
  T extends (infer U)[]                              // 배열이면?
    ? ReadonlyArray&lt;DeepReadonly&lt;U&gt;&gt;                  // 읽기전용 배열로 + 요소도 재귀
    : T extends object                                // 객체면?
    ? { readonly [K in keyof T]: DeepReadonly&lt;T[K]&gt; } // 각 프로퍼티에 재귀 적용
    : T;                                              // 원시 타입이면 그대로

interface Config {
  db: { host: string; ports: number[] };
  features: { dark: boolean };
}

type FrozenConfig = DeepReadonly&lt;Config&gt;;
// {
//   readonly db: {
//     readonly host: string;
//     readonly ports: ReadonlyArray&lt;number&gt;
//   };
//   readonly features: { readonly dark: boolean };
// }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 깊은 Partial (Deep Partial)
type DeepPartial&lt;T&gt; = T extends object ? {
  [K in keyof T]?: DeepPartial&lt;T[K]&gt;;
} : T;

type PartialConfig = DeepPartial&lt;Config&gt;;
// db?, db.host?, db.ports?, features?, features.dark?
// 모든 중첩 프로퍼티가 선택적으로!

// 설정 병합에 유용
function mergeConfig(
  defaults: Config,
  overrides: DeepPartial&lt;Config&gt;
): Config {
  // 깊은 병합 로직...
  return { ...defaults, ...overrides } as Config;
}
        </code></pre>
      </section>

      <!-- Slide 15: Branded Types / Opaque Types -->
      <section data-narration="브랜디드 타입은 구조적으로 같은 타입을 의미적으로 구분하는 기법입니다. 사용자 ID와 주문 ID가 둘 다 string이지만 혼용을 방지할 수 있습니다.">
        <h2>브랜디드 타입 (Branded Type)</h2>
        <p>구조적 타입 시스템에서 <strong>명목적 타입</strong>(이름이 다르면 다른 타입)을 흉내내는 기법</p>
        <div class="tip" style="margin-bottom: 0.3em; font-size: 0.7em;">
          <strong>왜 이게 필요한가?</strong> TypeScript에서는 구조(모양)가 같으면 같은 타입으로 취급합니다. 하지만 "사용자 ID"와 "게시글 ID"는 둘 다 숫자여도 섞이면 안 됩니다. 브랜디드 타입은 이런 혼동을 막아줍니다.
        </div>
        <pre><code class="typescript" data-trim data-noescape>
// 문제: 구조가 같으면 같은 타입으로 취급됨
type UserId = number;   // 사용자 ID
type PostId = number;   // 게시글 ID (둘 다 그냥 number!)

function getUser(id: UserId) { /* ... */ }
function getPost(id: PostId) { /* ... */ }

const userId: UserId = 1;
const postId: PostId = 2;
getUser(postId); // 에러 없음! 하지만 논리적 버그!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 해결: 브랜디드 타입으로 구별
// 보이지 않는 "브랜드 태그"를 붙여서 타입을 구분
type Brand&lt;T, B extends string&gt; = T & { readonly __brand: B };

type UserId = Brand&lt;number, "UserId"&gt;;
type PostId = Brand&lt;number, "PostId"&gt;;

// 생성 함수 (팩토리)
function createUserId(id: number): UserId {
  return id as UserId;
}
function createPostId(id: number): PostId {
  return id as PostId;
}

function getUser(id: UserId) { /* ... */ }

const userId = createUserId(1);
const postId = createPostId(2);

getUser(userId);  // OK!
// getUser(postId);  // Error! PostId는 UserId에 할당 불가!
// getUser(42);      // Error! number는 UserId에 할당 불가!
        </code></pre>
      </section>

      <!-- Slide 16: Branded Types - Practical -->
      <section data-narration="브랜디드 타입을 실전에서 활용하면 단위가 다른 숫자나 의미가 다른 문자열을 컴파일 타임에 구분할 수 있어 실수를 방지합니다.">
        <h2>브랜디드 타입 실전 활용</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 유효성이 검증된 값을 타입으로 보장하는 실전 패턴
type Brand&lt;T, B extends string&gt; = T & { readonly __brand: B };

type Email = Brand&lt;string, "Email"&gt;;              // 검증된 이메일
type PositiveNumber = Brand&lt;number, "PositiveNumber"&gt;; // 양수만
type NonEmptyString = Brand&lt;string, "NonEmptyString"&gt;; // 비어있지 않은 문자열

// 검증 함수 = 브랜드를 부여하는 함수 (검증 통과해야만 타입 획득)
function validateEmail(input: string): Email {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(input)) {
    throw new Error(`유효하지 않은 이메일: ${input}`);
  }
  return input as Email;
}

function toPositive(n: number): PositiveNumber {
  if (n <= 0) throw new Error("양수여야 합니다");
  return n as PositiveNumber;
}

// 검증된 값만 받는 함수
function sendEmail(to: Email, subject: string) {
  // to는 이미 검증된 이메일 주소!
  console.log(`메일 발송: ${to}`);
}

const email = validateEmail("user@example.com"); // Email
sendEmail(email, "안녕하세요");                    // OK!
// sendEmail("not-validated", "테스트");           // Error!
        </code></pre>
        <div class="key-point fragment">
          <h3>핵심 장점</h3>
          <p>"검증되지 않은 값"과 "검증된 값"을 <strong>타입 레벨에서 구분</strong>하여<br>
          런타임 (Runtime, 실행 시점) 에러를 컴파일 타임 (Compile Time, 코드 변환 시점)에 방지합니다.</p>
        </div>
      </section>

      <!-- Slide 17: Type-Level Programming -->
      <section data-narration="타입 레벨 프로그래밍은 타입 시스템 자체를 프로그래밍 언어처럼 사용하는 고급 기법입니다. 조건부 타입, 매핑된 타입, 재귀 타입을 조합하여 복잡한 타입 변환을 구현합니다.">
        <h2>타입 레벨 프로그래밍</h2>
        <p>타입 시스템 자체를 프로그래밍 언어처럼 활용하기. 값이 아닌 <strong>타입</strong>을 대상으로 조건문, 반복, 재귀 등을 수행합니다. 실행 시점(런타임)이 아닌 코드 작성 시점(컴파일 타임)에 모든 계산이 이루어집니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 타입 레벨 문자열 조작: camelCase -> kebab-case 변환
// 대문자를 만나면 앞에 "-"를 붙이고 소문자로 변환
type CamelToKebab&lt;S extends string&gt; =
  S extends `${infer Head}${infer Tail}`
    ? Head extends Uppercase&lt;Head&gt;
      ? `-${Lowercase&lt;Head&gt;}${CamelToKebab&lt;Tail&gt;}`
      : `${Head}${CamelToKebab&lt;Tail&gt;}`
    : S;

type K1 = CamelToKebab&lt;"backgroundColor"&gt;;  // "background-color"
type K2 = CamelToKebab&lt;"fontSize"&gt;;          // "font-size"
type K3 = CamelToKebab&lt;"borderTopWidth"&gt;;    // "border-top-width"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 타입 레벨 덧셈 (튜플 길이를 이용한 트릭)
// 길이가 N인 튜플(배열)을 만들어서 길이로 숫자를 표현
type BuildTuple&lt;N extends number, T extends any[] = []&gt; =
  T["length"] extends N ? T : BuildTuple&lt;N, [...T, any]&gt;;

// 두 튜플을 합치면 길이가 합산됨 = 덧셈!
type Add&lt;A extends number, B extends number&gt; =
  [...BuildTuple&lt;A&gt;, ...BuildTuple&lt;B&gt;]["length"];

type Sum = Add&lt;3, 4&gt;;  // 7 (타입 레벨에서 계산!)

// 타입 레벨 배열 뒤집기 (재귀 활용)
type Reverse&lt;T extends any[]&gt; =
  T extends [infer First, ...infer Rest]
    ? [...Reverse&lt;Rest&gt;, First]  // 나머지를 뒤집고 첫 번째를 맨 뒤에
    : [];

type Rev = Reverse&lt;[1, 2, 3, 4]&gt;; // [4, 3, 2, 1]
        </code></pre>
        <div class="tip fragment">
          타입 레벨 프로그래밍은 강력하지만, 복잡도를 적절히 관리하세요.
          팀원 모두가 이해할 수 있는 수준을 유지하는 것이 중요합니다.
        </div>
      </section>

      <!-- Slide 18: Summary -->
      <section data-narration="챕터 8을 마치겠습니다. 조건부 타입, infer, 매핑된 타입, 템플릿 리터럴 타입, 재귀 타입, 브랜디드 타입까지 고급 타입 시스템의 핵심을 학습했습니다.">
        <h2>Chapter 8 요약</h2>
        <div class="key-point">
          <h3>핵심 정리</h3>
          <ul>
            <li class="fragment"><strong>조건부 타입</strong>: <code>T extends U ? X : Y</code> - 타입 레벨 분기</li>
            <li class="fragment"><strong>infer</strong>: 조건부 타입 내에서 타입 추출 (함수 반환값, Promise 등)</li>
            <li class="fragment"><strong>분배 조건부 타입</strong>: 유니온 멤버에 자동으로 분배 적용</li>
            <li class="fragment"><strong>매핑된 타입</strong>: <code>[K in keyof T]</code>로 프로퍼티 일괄 변환</li>
            <li class="fragment"><strong>템플릿 리터럴 타입</strong>: 문자열 타입의 패턴 매칭과 조합</li>
            <li class="fragment"><strong>키 재매핑</strong>: <code>as</code>로 키 이름 변환 및 필터링</li>
            <li class="fragment"><strong>재귀 타입</strong>: DeepReadonly, DeepPartial 등 깊은 변환</li>
            <li class="fragment"><strong>브랜디드 타입</strong>: 구조적 타입 시스템에서 명목적 구별</li>
          </ul>
        </div>
        <br>
        <p class="fragment">
          <a href="07-type-narrowing.html" style="color: #888; font-size: 0.8em;">
            &larr; 이전: Chapter 7 - 타입 좁히기
          </a>
        </p>
      </section>

    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
