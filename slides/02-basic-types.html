<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 2: 기본 타입 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 2, 기본 타입입니다. 타입스크립트의 핵심 타입 시스템을 완전히 이해해 봅시다.">
        <span class="chapter-number">Chapter 02</span>
        <h1>기본 타입</h1>
        <p class="subtitle">TypeScript(TS)의 핵심 타입 (Type) 시스템 완전 이해</p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.6em;">&#8592; 목차로 돌아가기</a></p>
      </section>

      <!-- Slide 2: Type Overview -->
      <section data-transition="slide" data-narration="타입스크립트에는 다양한 타입이 있습니다. string, number, boolean 같은 원시 타입부터 배열, 튜플, enum, any, unknown, never 같은 특수 타입까지 살펴보겠습니다.">
        <h2>TypeScript 타입 전체 지도</h2>
        <div style="text-align: center;">
          <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0;">
            <span class="badge badge-blue">string</span>
            <span class="badge badge-blue">number</span>
            <span class="badge badge-blue">boolean</span>
            <span class="badge badge-green">array</span>
            <span class="badge badge-green">tuple (튜플)</span>
            <span class="badge badge-green">enum (열거형)</span>
            <span class="badge badge-orange">any</span>
            <span class="badge badge-orange">unknown</span>
            <span class="badge badge-red">void</span>
            <span class="badge badge-red">null</span>
            <span class="badge badge-red">undefined</span>
            <span class="badge badge-red">never</span>
          </div>
        </div>
        <div class="key-point">
          <h3>이번 챕터에서 배울 내용</h3>
          <p>12가지 기본 타입을 완벽하게 이해하고,<br>
          각 타입이 <strong>언제, 왜</strong> 사용되는지 학습합니다.</p>
        </div>
      </section>

      <!-- Slide 3: Primitive Types - string -->
      <section data-transition="slide" data-narration="string 타입은 문자열을 나타냅니다. 작은따옴표, 큰따옴표, 백틱 모두 사용할 수 있으며, 백틱을 사용하면 템플릿 리터럴로 변수를 삽입할 수 있습니다.">
        <h2>원시 타입: string</h2>
        <pre><code class="language-typescript">// 문자열 타입
let firstName: string = "홍길동";
let greeting: string = `안녕하세요, ${firstName}님!`;

// 템플릿 리터럴 (Literal, 고정된 값)도 string
let multiLine: string = `
  여러 줄의
  문자열도
  가능합니다.
`;

// string 메서드 자동완성 지원
firstName.toUpperCase();   // IDE가 모든 string 메서드를 제안
firstName.includes("홍");  // boolean 반환 타입도 자동 추론</code></pre>

        <div class="warning">
          <strong>주의:</strong> <code>String</code>(대문자)은 래퍼 (Wrapper) 객체 타입으로, JavaScript가 내부적으로 사용하는 특수 객체입니다.
          코드 작성 시에는 항상 소문자 <code>string</code>을 사용하세요.
        </div>
      </section>

      <!-- Slide 4: Primitive Types - number, boolean -->
      <section data-transition="slide" data-narration="number 타입은 정수와 소수점을 모두 포함하며, 자바스크립트와 마찬가지로 별도의 int나 float 구분이 없습니다. boolean 타입은 true 또는 false 값만 가질 수 있습니다.">
        <h2>원시 타입: number, boolean</h2>
        <div class="two-columns">
          <div>
            <h3 style="font-size: 1em;">number</h3>
            <pre><code class="language-typescript">// 모든 숫자는 number (정수/실수 구분 없음)
let integer: number = 42;
let float: number = 3.14;
let negative: number = -10;

// 다양한 표기법
let hex: number = 0xff;       // 16진수
let binary: number = 0b1010;  // 2진수
let octal: number = 0o744;    // 8진수
let big: number = 1_000_000;  // 구분자

// 특수 값
let inf: number = Infinity;
let nan: number = NaN;</code></pre>
          </div>
          <div>
            <h3 style="font-size: 1em;">boolean</h3>
            <pre><code class="language-typescript">// true 또는 false만 가능
let isDone: boolean = false;
let isActive: boolean = true;

// 비교 연산 결과도 boolean
let isAdult: boolean = 20 >= 18;
let hasPermission = true; // 추론

// 조건문에서 활용
function checkAge(age: number): boolean {
  return age >= 18;
}

// boolean은 논리 연산 가능
let canAccess = isActive && hasPermission;</code></pre>
          </div>
        </div>
      </section>

      <!-- Slide 5: Arrays -->
      <section data-transition="slide" data-narration="배열 타입은 number 대괄호처럼 요소 타입 뒤에 대괄호를 붙이거나, Array 제네릭 형태로 선언할 수 있습니다. 두 표현은 동일합니다.">
        <h2>배열 (Arrays)</h2>
        <pre><code class="language-typescript">// 방법 1: 타입[] 표기법 (권장)
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob", "Charlie"];

// 방법 2: Array&lt;타입&gt; 제네릭 표기법
let scores: Array&lt;number&gt; = [90, 85, 92];
let flags: Array&lt;boolean&gt; = [true, false, true];

// 배열 타입 안전성
numbers.push(6);       // OK
numbers.push("seven"); // Error! string은 안 됨

// 배열 메서드 (Method, 객체에 속한 함수)도 타입 추론 (Type Inference)
const doubled = numbers.map(n => n * 2);    // number[] - 각 요소를 2배로
const filtered = names.filter(n => n.length > 3);  // string[] - 3글자 초과만
const found = numbers.find(n => n > 3);     // number | undefined - 못 찾을 수도 있음</code></pre>

        <div class="fragment tip">
          <strong>Tip:</strong> <code>find()</code>의 반환 타입이 <code>number | undefined</code>인 이유는
          요소를 찾지 못할 수 있기 때문입니다.
        </div>
      </section>

      <!-- Slide 6: Readonly Array -->
      <section data-transition="slide" data-narration="readonly 키워드를 사용하면 배열의 요소를 수정할 수 없는 읽기 전용 배열을 만들 수 있습니다. push, pop 같은 변경 메서드가 차단됩니다.">
        <h2>읽기 전용 배열</h2>
        <pre><code class="language-typescript">// readonly 배열 - 수정 불가
const colors: readonly string[] = ["red", "green", "blue"];

colors.push("yellow");   // Error! readonly 배열에 push 불가
colors[0] = "black";     // Error! 요소 변경 불가

// ReadonlyArray 제네릭
const points: ReadonlyArray&lt;number&gt; = [1, 2, 3];

// as const - 모든 요소를 리터럴 타입으로 고정
const DIRECTIONS = ["north", "south", "east", "west"] as const;
// 타입: readonly ["north", "south", "east", "west"]

type Direction = typeof DIRECTIONS[number];
// 타입: "north" | "south" | "east" | "west"</code></pre>
        <div class="key-point">
          <h3>핵심 포인트</h3>
          <p><code>as const</code>는 배열을 <strong>읽기 전용 튜플 (Tuple, 고정 길이 배열)</strong>로 만들어
          각 요소가 리터럴 타입이 됩니다.</p>
        </div>
      </section>

      <!-- Slide 7: Tuples -->
      <section data-transition="slide" data-narration="튜플은 각 요소의 타입과 개수가 고정된 배열입니다. 예를 들어 string과 number 쌍을 하나의 변수에 담을 수 있으며, 순서가 중요합니다.">
        <h2>튜플 (Tuples)</h2>
        <p>고정된 길이와 각 위치별 타입이 정해진 배열</p>
        <pre><code class="language-typescript">// 기본 튜플 - 각 위치의 타입이 다름
let person: [string, number] = ["홍길동", 25];

// 각 요소 접근 시 올바른 타입으로 추론
let name = person[0];   // string
let age = person[1];    // number

// 타입 에러
person = [25, "홍길동"];     // Error! 순서가 다름
person = ["홍길동"];         // Error! 길이가 다름

// 구조 분해 할당과 함께 사용
const [userName, userAge] = person;
// userName: string, userAge: number

// 실용적인 예: React의 useState가 튜플을 반환
// const [count, setCount] = useState(0);
// 타입: [number, Dispatch&lt;SetStateAction&lt;number&gt;&gt;]</code></pre>
      </section>

      <!-- Slide 8: Tuples Advanced -->
      <section data-transition="slide" data-narration="튜플은 함수에서 여러 값을 반환하거나, 구조 분해 할당과 함께 사용할 때 유용합니다. 리액트의 useState 훅이 대표적인 튜플 활용 예입니다.">
        <h2>튜플 활용 패턴</h2>
        <pre><code class="language-typescript">// 선택적 요소가 있는 튜플
type Point2D = [number, number];
type Point3D = [number, number, number?];  // z는 선택적

const p1: Point2D = [10, 20];
const p2: Point3D = [10, 20, 30];
const p3: Point3D = [10, 20];       // OK - z 생략 가능

// 이름이 있는 튜플 (가독성 향상)
type UserEntry = [name: string, age: number, active: boolean];

const entry: UserEntry = ["Kim", 30, true];

// 나머지 요소가 있는 튜플
type StringNumberBooleans = [string, number, ...boolean[]];

const data: StringNumberBooleans = ["hello", 1, true, false, true];

// 함수에서 여러 값 반환
function getMinMax(nums: number[]): [min: number, max: number] {
  return [Math.min(...nums), Math.max(...nums)];
}
const [min, max] = getMinMax([3, 1, 4, 1, 5]);</code></pre>
      </section>

      <!-- Slide 9: Enums - Numeric -->
      <section data-transition="slide" data-narration="enum은 관련된 상수들을 그룹으로 묶어주는 타입입니다. 숫자형 enum은 자동으로 0부터 순서대로 값이 할당되며, 시작 값을 지정할 수도 있습니다.">
        <h2>열거형 (Enum) - 숫자형</h2>
        <p style="font-size: 0.85em; color: #aaa;">열거형이란 관련된 상수들을 하나의 그룹으로 묶어 이름을 붙인 것입니다. 예: 방향(상/하/좌/우)</p>
        <pre><code class="language-typescript">// 숫자형 enum - 기본값은 0부터 자동 증가
enum Direction {
  Up,      // 0
  Down,    // 1
  Left,    // 2
  Right    // 3
}

let dir: Direction = Direction.Up;
console.log(dir);              // 0
console.log(Direction[0]);     // "Up" (역방향 매핑)

// 시작 값을 지정할 수도 있음
enum StatusCode {
  OK = 200,
  NotFound = 404,
  InternalError = 500
}

function handleResponse(code: StatusCode) {
  if (code === StatusCode.OK) {
    console.log("성공!");
  }
}

handleResponse(StatusCode.OK);       // OK
handleResponse(200);                 // OK (숫자도 허용 - 주의!)</code></pre>
      </section>

      <!-- Slide 10: Enums - String & Const -->
      <section data-transition="slide" data-narration="문자열 enum은 각 멤버에 문자열 값을 직접 지정합니다. const enum은 컴파일 시 인라인으로 대체되어 더 효율적인 코드를 생성합니다.">
        <h2>문자열 열거형 &amp; const enum</h2>
        <div class="two-columns">
          <div>
            <h3 style="font-size: 0.95em; color: var(--ts-blue);">문자열 enum</h3>
            <pre><code class="language-typescript">// 문자열 enum - 더 안전
enum Theme {
  Light = "LIGHT",
  Dark  = "DARK",
  Auto  = "AUTO"
}

let current: Theme = Theme.Dark;
// current === "DARK"

// 숫자와 달리 역방향 매핑 없음
// Theme["DARK"] -> undefined</code></pre>
          </div>
          <div>
            <h3 style="font-size: 0.95em; color: var(--ts-green);">const enum</h3>
            <pre><code class="language-typescript">// const enum - 컴파일 (Compile) 시 값이 직접 삽입됨
const enum Color {
  Red   = "RED",
  Green = "GREEN",
  Blue  = "BLUE"
}

let c = Color.Red;
// 컴파일 결과: let c = "RED";
// enum 객체가 생성되지 않음!

// 장점: 번들 (Bundle, 최종 파일) 크기 감소
// 단점: 역방향 매핑 (값으로 이름 찾기) 불가</code></pre>
          </div>
        </div>

        <div class="fragment tip">
          <strong>Best Practice:</strong> 문자열 enum을 사용하면 디버깅이 쉽고 타입 안전성이 높아집니다.
          성능이 중요하면 <code>const enum</code>을 고려하세요.
        </div>
      </section>

      <!-- Slide 11: Enum alternatives -->
      <section data-transition="slide" data-narration="as const 패턴은 enum의 대안으로, 일반 객체에 as const를 붙여 읽기 전용 상수로 만드는 방법입니다. 트리 셰이킹이 잘 되어 번들 크기 최적화에 유리합니다.">
        <h2>Enum 대안: as const 패턴</h2>
        <p>최근 트렌드는 enum 대신 <code>as const</code> 객체를 선호합니다.</p>
        <pre><code class="language-typescript">// as const 객체 패턴 (enum 대안)
const Status = {
  Active: "ACTIVE",
  Inactive: "INACTIVE",
  Pending: "PENDING",
} as const;

// 유니온 (Union) 타입으로 추출
type Status = typeof Status[keyof typeof Status];
// "ACTIVE" | "INACTIVE" | "PENDING"

function setStatus(status: Status) {
  console.log(status);
}

setStatus(Status.Active);    // OK
setStatus("ACTIVE");         // OK
setStatus("INVALID");        // Error!</code></pre>

        <div class="key-point">
          <h3>왜 as const를 선호하는가?</h3>
          <p>트리 쉐이킹 (Tree Shaking, 사용하지 않는 코드 자동 제거) 가능, JavaScript(JS)와의 호환성, 더 유연한 타입 추출</p>
        </div>
      </section>

      <!-- Slide 12: any vs unknown -->
      <section data-transition="slide" data-narration="any는 모든 타입 검사를 무시하므로 위험하고, unknown은 사용하기 전에 타입 검사를 강제하므로 안전합니다. 타입을 모를 때는 any 대신 unknown을 사용하세요.">
        <h2>any vs unknown</h2>
        <div class="two-columns">
          <div>
            <h3 style="color: var(--ts-red); font-size: 1em;">any - 위험한 탈출구</h3>
            <pre><code class="language-typescript">// any: 모든 타입 허용, 체크 없음
let anything: any = "hello";
anything = 42;
anything = true;

// 위험! 아무 연산이나 가능
anything.foo.bar;     // OK (런타임 (Runtime, 실행 중) 에러)
anything();           // OK (런타임 에러)
anything.toFixed(2);  // OK (런타임 에러)

// 다른 타입에 할당도 가능!
let num: number = anything; // OK!</code></pre>
          </div>
          <div>
            <h3 style="color: var(--ts-green); font-size: 1em;">unknown - 안전한 대안</h3>
            <pre><code class="language-typescript">// unknown: 모든 타입 허용, 체크 필수
let something: unknown = "hello";
something = 42;
something = true;

// 안전! 직접 사용 불가
something.foo;        // Error!
something();          // Error!
something.toFixed(2); // Error!

// 타입 확인 후에만 사용 가능
if (typeof something === "number") {
  something.toFixed(2); // OK!
}</code></pre>
          </div>
        </div>

        <div class="fragment warning">
          <strong>규칙:</strong> <code>any</code> 대신 <code>unknown</code>을 사용하세요.
          타입 안전성을 유지하면서 유연성을 확보할 수 있습니다.
        </div>
      </section>

      <!-- Slide 13: void, null, undefined -->
      <section data-transition="slide" data-narration="void는 반환값이 없는 함수에 사용되고, null과 undefined는 각각 값이 없음과 정의되지 않음을 나타냅니다. strictNullChecks를 켜면 이들을 엄격하게 구분합니다.">
        <h2>void, null, undefined</h2>
        <pre><code class="language-typescript">// void - 반환값이 없는 함수
function logMessage(msg: string): void {
  console.log(msg);
  // return 없음 또는 return;
}

// undefined - 값이 할당되지 않은 상태
let u: undefined = undefined;

function findUser(id: number): string | undefined {
  // 사용자를 찾지 못하면 undefined 반환
  const users = ["Alice", "Bob"];
  return users[id];
}

// null - 의도적으로 "값 없음"을 표현
let n: null = null;

function getElement(id: string): HTMLElement | null {
  return document.getElementById(id);  // 없으면 null
}

// strictNullChecks가 true일 때 (권장 설정)
let userName: string = null;          // Error! string에 null 불가
let nullableName: string | null = null; // OK! 유니온으로 null 허용</code></pre>
      </section>

      <!-- Slide 14: never type -->
      <section data-transition="slide" data-narration="never는 절대 발생하지 않는 값의 타입입니다. 항상 에러를 던지거나 무한 루프를 도는 함수의 반환 타입이 never입니다.">
        <h2>never 타입</h2>
        <div class="key-point">
          <h3>핵심 개념</h3>
          <p><code>never</code>는 <strong>절대 발생하지 않는 값</strong>의 타입입니다.<br>
          함수가 정상적으로 종료되지 않거나, 도달 불가능한 코드에서 사용됩니다.</p>
        </div>
        <pre><code class="language-typescript">// 항상 에러를 던지는 함수
function throwError(message: string): never {
  throw new Error(message);
}

// 무한 루프
function infiniteLoop(): never {
  while (true) { }
}

// 가장 유용한 패턴: 완전성 검사 (Exhaustive Check, 모든 경우를 빠짐없이 처리했는지 확인)
type Shape = "circle" | "square" | "triangle";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":    return Math.PI * 10 * 10;
    case "square":    return 10 * 10;
    case "triangle":  return (10 * 10) / 2;
    default:
      // shape가 never 타입이면 모든 케이스를 처리한 것
      const _exhaustive: never = shape;
      return _exhaustive;
  }
}</code></pre>
      </section>

      <!-- Slide 15: never exhaustive check -->
      <section data-transition="slide" data-narration="never를 활용하면 switch문에서 모든 경우를 처리했는지 컴파일 타임에 검증할 수 있습니다. 새로운 타입이 추가되면 즉시 에러가 발생하여 누락을 방지합니다.">
        <h2>never를 활용한 안전 장치</h2>
        <p>새로운 타입이 추가되면 컴파일 에러로 알려줍니다</p>
        <pre><code class="language-typescript">// Shape에 "pentagon"을 추가하면?
type Shape = "circle" | "square" | "triangle" | "pentagon";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":    return Math.PI * 10 * 10;
    case "square":    return 10 * 10;
    case "triangle":  return (10 * 10) / 2;
    // case "pentagon" 빠뜨림!
    default:
      const _exhaustive: never = shape;
      // Error! Type '"pentagon"' is not assignable to type 'never'
      // -> pentagon 케이스를 처리하지 않았다고 알려줌!
      return _exhaustive;
  }
}</code></pre>
        <div class="tip">
          <strong>Tip:</strong> 이 패턴은 유니온 타입에 새 멤버를 추가할 때 빠뜨린 처리를
          컴파일 (Compile) 시점에 잡아주는 강력한 안전 장치입니다.
        </div>
      </section>

      <!-- Slide 16: Type Assertions -->
      <section data-transition="slide" data-narration="타입 단언은 개발자가 타입스크립트보다 타입을 더 잘 알 때 사용합니다. as 키워드를 사용하며, DOM 요소 접근 시 자주 활용됩니다. 하지만 남용하면 위험합니다.">
        <h2>타입 단언 (Type Assertion)</h2>
        <p>개발자가 컴파일러 (Compiler)보다 타입을 더 잘 아는 경우 사용합니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">"이 값은 이 타입이 확실해!"라고 TypeScript에게 직접 알려주는 방법입니다.</span></p>
        <pre><code class="language-typescript">// as 구문 (권장)
const input = document.getElementById("myInput") as HTMLInputElement;
input.value = "Hello";  // HTMLInputElement로 단언했으므로 .value 접근 가능

// 앵글 브래킷 구문 (JSX에서는 사용 불가)
const canvas = &lt;HTMLCanvasElement&gt;document.getElementById("myCanvas");

// JSON 파싱 결과에 타입 지정
interface Config {
  host: string;
  port: number;
}
const config = JSON.parse(rawData) as Config;

// 이중 단언 (최후의 수단!)
const value = "hello" as unknown as number;  // 위험하지만 가능</code></pre>

        <div class="fragment warning">
          <strong>Warning:</strong> 타입 단언은 타입 체크를 <strong>우회</strong>합니다.
          런타임 에러의 원인이 될 수 있으니 신중하게 사용하세요.
        </div>
      </section>

      <!-- Slide 17: Literal Types -->
      <section data-transition="slide" data-narration="리터럴 타입은 정확한 값 하나만 허용하는 타입입니다. 문자열, 숫자, 불린 리터럴 타입을 유니온으로 조합하면 특정 값만 허용하는 타입을 만들 수 있습니다.">
        <h2>리터럴 타입 (Literal Type)</h2>
        <p style="font-size: 0.85em; color: #aaa;">리터럴이란 코드에 직접 쓴 고정된 값을 말합니다. 리터럴 타입은 "정확히 이 값만 허용"하는 타입입니다.</p>
        <pre><code class="language-typescript">// 리터럴 타입: 특정 값만 허용
let direction: "up" | "down" | "left" | "right";

direction = "up";      // OK
direction = "diagonal"; // Error! 허용된 값이 아님

// 숫자 리터럴 타입
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;
let roll: DiceRoll = 3;   // OK
let roll2: DiceRoll = 7;  // Error!

// boolean 리터럴 타입
type True = true;

// const 변수는 자동으로 리터럴 타입
const PI = 3.14;        // 타입: 3.14 (number가 아님!)
let mutable = 3.14;     // 타입: number

// 함수 매개변수에서 활용
function setAlignment(align: "left" | "center" | "right") {
  // align은 정확히 3가지 값만 가능
}
setAlignment("center"); // OK
setAlignment("top");    // Error!</code></pre>
      </section>

      <!-- Slide 18: Union Types -->
      <section data-transition="slide" data-narration="유니온 타입은 여러 타입 중 하나일 수 있음을 나타냅니다. 세로 막대 기호로 타입을 연결하며, 사용 시에는 타입 좁히기를 통해 정확한 타입을 확인해야 합니다.">
        <h2>유니온 타입 (Union Type)</h2>
        <p style="font-size: 0.85em; color: #aaa;">유니온이란 "합집합"이라는 뜻으로, 여러 타입 중 하나가 될 수 있다는 의미입니다. <code>|</code> 기호로 연결합니다.</p>
        <pre><code class="language-typescript">// 여러 타입 중 하나가 될 수 있음
let id: string | number;
id = "abc-123";   // OK
id = 42;          // OK
id = true;        // Error!

// 유니온 타입과 타입 가드 (Type Guard, 타입을 확인하여 좁혀나가는 기법)
function printId(id: string | number) {
  if (typeof id === "string") {
    // 이 블록에서 id는 string (typeof로 타입을 확인했으므로)
    console.log(id.toUpperCase());
  } else {
    // 이 블록에서 id는 number
    console.log(id.toFixed(2));
  }
}

// 유니온 타입의 공통 멤버만 접근 가능
function getLength(value: string | number[]) {
  // string과 number[] 모두 .length가 있음
  return value.length;  // OK
}

// 실용적 예: API 응답 타입
type ApiResponse =
  | { status: "success"; data: string }
  | { status: "error"; message: string };</code></pre>
      </section>

      <!-- Slide 19: Summary Table -->
      <section data-transition="slide" data-narration="챕터 2를 정리하겠습니다. 원시 타입, 배열, 튜플, enum, any와 unknown, never, 타입 단언, 리터럴 타입, 유니온 타입까지 기본 타입 시스템을 모두 살펴보았습니다.">
        <h2>Chapter 2 정리</h2>
        <table class="compare-table" style="font-size: 0.75em;">
          <thead>
            <tr>
              <th>타입</th>
              <th>설명</th>
              <th>예시</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><code>string</code></td><td>문자열</td><td><code>"hello"</code></td></tr>
            <tr><td><code>number</code></td><td>숫자 (정수/실수)</td><td><code>42, 3.14</code></td></tr>
            <tr><td><code>boolean</code></td><td>참/거짓</td><td><code>true, false</code></td></tr>
            <tr><td><code>array</code></td><td>배열</td><td><code>number[], Array&lt;string&gt;</code></td></tr>
            <tr><td><code>tuple</code></td><td>고정 길이 배열</td><td><code>[string, number]</code></td></tr>
            <tr><td><code>enum</code></td><td>열거형</td><td><code>enum Color { Red }</code></td></tr>
            <tr><td><code>any</code></td><td>모든 타입 (위험)</td><td>사용 자제</td></tr>
            <tr><td><code>unknown</code></td><td>안전한 any</td><td>타입 체크 후 사용</td></tr>
            <tr><td><code>void</code></td><td>반환값 없음</td><td><code>(): void</code></td></tr>
            <tr><td><code>never</code></td><td>도달 불가</td><td>에러, 완전성 검사</td></tr>
            <tr><td>리터럴</td><td>특정 값</td><td><code>"up" | "down"</code></td></tr>
            <tr><td>유니온</td><td>여러 타입 중 하나</td><td><code>string | number</code></td></tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 20: Next Chapter -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 2를 마치셨습니다. 수고하셨습니다! 다음 챕터에서는 함수의 타입 시스템을 학습합니다.">
        <span class="chapter-number">Next</span>
        <h1>수고하셨습니다!</h1>
        <br>
        <p>
          <a href="03-functions.html" style="color: var(--ts-blue); font-size: 1.2em;">
            다음 챕터: 함수 &#8594;
          </a>
        </p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.7em;">&#8592; 목차로 돌아가기</a></p>
      </section>

    </div>
  </div>

  <div class="nav-footer">
    <a href="../index.html" style="color: #888;">TypeScript 완전 정복</a> | Chapter 02
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
