<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 2: 기본 타입 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 2, 기본 타입입니다. 이 챕터에서는 string, number, boolean 같은 원시 타입부터 배열, 튜플, enum, any, unknown, never 같은 특수 타입까지 12가지 기본 타입을 완전히 이해합니다. 타입 시스템은 타입스크립트의 핵심이므로 하나하나 정확히 익혀두세요. 실무에서 매일 사용하는 필수 지식입니다.">
        <span class="chapter-number">Chapter 02</span>
        <h1>기본 타입</h1>
        <p class="subtitle">TypeScript(TS)의 핵심 타입 (Type) 시스템 완전 이해</p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.6em;">&#8592; 목차로 돌아가기</a></p>
      </section>

      <!-- Slide 2: Type Overview -->
      <section data-transition="slide" data-narration="타입스크립트의 타입 전체 지도를 살펴봅시다. 파란색 뱃지는 string, number, boolean 원시 타입이고, 초록색은 배열, 튜플, enum 같은 컬렉션 타입입니다. 주황색의 any와 unknown은 유연한 타입이고, 빨간색의 void, null, undefined, never는 특수 타입입니다. 이번 챕터에서 이 12가지 타입이 언제, 왜 사용되는지 하나씩 학습합니다.">
        <h2>TypeScript 타입 전체 지도</h2>
        <div style="text-align: center;">
          <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 20px 0;">
            <span class="badge badge-blue">string</span>
            <span class="badge badge-blue">number</span>
            <span class="badge badge-blue">boolean</span>
            <span class="badge badge-green">array</span>
            <span class="badge badge-green">tuple (튜플)</span>
            <span class="badge badge-green">enum (열거형)</span>
            <span class="badge badge-orange">any</span>
            <span class="badge badge-orange">unknown</span>
            <span class="badge badge-red">void</span>
            <span class="badge badge-red">null</span>
            <span class="badge badge-red">undefined</span>
            <span class="badge badge-red">never</span>
          </div>
        </div>
        <div class="key-point">
          <h3>이번 챕터에서 배울 내용</h3>
          <p>12가지 기본 타입을 완벽하게 이해하고,<br>
          각 타입이 <strong>언제, 왜</strong> 사용되는지 학습합니다.</p>
        </div>
      </section>

      <!-- Slide 3: Primitive Types - string -->
      <section data-transition="slide" data-narration="string 타입은 문자열을 나타냅니다. 코드에서 보듯이 firstName에 문자열을 할당하고, 백틱을 사용한 템플릿 리터럴로 변수를 삽입할 수 있습니다. 여러 줄 문자열도 백틱으로 작성 가능합니다. string 타입으로 선언하면 IDE에서 toUpperCase, includes 같은 문자열 메서드를 자동 완성해줍니다. 주의할 점은 대문자 String은 래퍼 객체이므로, 항상 소문자 string을 사용해야 합니다.">
        <h2>원시 타입: string</h2>
        <pre><code class="language-typescript">// 문자열 타입
let firstName: string = "홍길동";
let greeting: string = `안녕하세요, ${firstName}님!`;

// 템플릿 리터럴 (Literal, 고정된 값)도 string
let multiLine: string = `
  여러 줄의
  문자열도
  가능합니다.
`;

// string 메서드 자동완성 지원
firstName.toUpperCase();   // IDE가 모든 string 메서드를 제안
firstName.includes("홍");  // boolean 반환 타입도 자동 추론</code></pre>

        <div class="warning">
          <strong>주의:</strong> <code>String</code>(대문자)은 래퍼 (Wrapper) 객체 타입으로, JavaScript가 내부적으로 사용하는 특수 객체입니다.
          코드 작성 시에는 항상 소문자 <code>string</code>을 사용하세요.
        </div>
      </section>

      <!-- Slide 4: Let vs Const Type Inference -->
      <section data-transition="slide" data-narration="원시 타입에서 let과 const의 타입 추론 차이를 이해하는 것이 중요합니다. 코드에서 let x에 hello를 할당하면 string으로 넓게 추론되어 나중에 다른 문자열을 넣을 수 있습니다. 반면 const y에 hello를 할당하면 정확히 hello라는 리터럴 타입으로 좁게 추론됩니다. 이는 const가 재할당 불가이므로 값이 변하지 않기 때문입니다. 이 차이를 이해하면 타입 시스템을 더 효과적으로 활용할 수 있습니다.">
        <h2>원시 타입 추론: let vs const</h2>
        <div class="key-point">
          <h3>핵심 개념</h3>
          <p><code>let</code>은 <strong>넓은 타입</strong>으로, <code>const</code>는 <strong>좁은 리터럴 타입</strong>으로 추론됩니다.</p>
        </div>
        <pre><code class="language-typescript">// let: 재할당 가능 → 넓은 타입으로 추론
let x = "hello";      // 타입: string (모든 문자열 가능)
x = "world";          // OK - 다른 문자열 할당 가능

let count = 42;        // 타입: number
count = 100;           // OK - 다른 숫자 할당 가능

// const: 재할당 불가 → 좁은 리터럴 타입으로 추론
const y = "hello";     // 타입: "hello" (정확히 이 값만)
const PI = 3.14;       // 타입: 3.14 (number가 아님!)
const flag = true;     // 타입: true (boolean이 아님!)

// 실전에서의 차이
let status = "active";        // string → "inactive" 등 다른 값 가능
const STATUS = "active";      // "active" → 정확히 이 값만 허용

// 객체의 경우 const여도 속성은 변경 가능
const user = { name: "Kim" }; // 타입: { name: string } (리터럴 아님!)
user.name = "Lee";            // OK - 속성은 변경 가능</code></pre>

        <div class="fragment tip">
          <strong>Tip:</strong> 변하지 않는 상수는 <code>const</code>로 선언하면 타입이 자동으로 좁아져 더 안전한 코드가 됩니다.
        </div>
      </section>

      <!-- Slide 5: Primitive Types - number, boolean -->
      <section data-transition="slide" data-narration="number 타입은 정수와 소수점 숫자를 모두 포함하며, 자바스크립트와 마찬가지로 별도의 int나 float 구분이 없습니다. 16진수, 2진수, 8진수 표기법과 구분자 언더스코어도 지원합니다. boolean 타입은 true 또는 false 값만 가질 수 있으며, 비교 연산의 결과도 boolean으로 추론됩니다. 논리 연산자로 여러 boolean 값을 조합할 수 있습니다.">
        <h2>원시 타입: number, boolean</h2>
        <div class="two-columns">
          <div>
            <h3 style="font-size: 1em;">number</h3>
            <pre><code class="language-typescript">// 모든 숫자는 number (정수/실수 구분 없음)
let integer: number = 42;
let float: number = 3.14;
let negative: number = -10;

// 다양한 표기법
let hex: number = 0xff;       // 16진수
let binary: number = 0b1010;  // 2진수
let octal: number = 0o744;    // 8진수
let big: number = 1_000_000;  // 구분자

// 특수 값
let inf: number = Infinity;
let nan: number = NaN;</code></pre>
          </div>
          <div>
            <h3 style="font-size: 1em;">boolean</h3>
            <pre><code class="language-typescript">// true 또는 false만 가능
let isDone: boolean = false;
let isActive: boolean = true;

// 비교 연산 결과도 boolean
let isAdult: boolean = 20 >= 18;
let hasPermission = true; // 추론

// 조건문에서 활용
function checkAge(age: number): boolean {
  return age >= 18;
}

// boolean은 논리 연산 가능
let canAccess = isActive && hasPermission;</code></pre>
          </div>
        </div>
      </section>

      <!-- Slide 5: Arrays -->
      <section data-transition="slide" data-narration="배열 타입은 두 가지 방법으로 선언할 수 있습니다. 코드에서 number 대괄호 표기법과 Array 제네릭 표기법을 보여주고 있는데, 둘은 완전히 동일합니다. numbers 배열에 문자열 seven을 넣으려 하면 에러가 발생합니다. map, filter, find 같은 배열 메서드의 반환 타입도 자동 추론되며, find는 요소를 못 찾을 수 있어서 undefined와의 유니온 타입을 반환합니다.">
        <h2>배열 (Arrays)</h2>
        <pre><code class="language-typescript">// 방법 1: 타입[] 표기법 (권장)
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob", "Charlie"];

// 방법 2: Array&lt;타입&gt; 제네릭 표기법
let scores: Array&lt;number&gt; = [90, 85, 92];
let flags: Array&lt;boolean&gt; = [true, false, true];

// 배열 타입 안전성
numbers.push(6);       // OK
numbers.push("seven"); // Error! string은 안 됨

// 배열 메서드 (Method, 객체에 속한 함수)도 타입 추론 (Type Inference)
const doubled = numbers.map(n => n * 2);    // number[] - 각 요소를 2배로
const filtered = names.filter(n => n.length > 3);  // string[] - 3글자 초과만
const found = numbers.find(n => n > 3);     // number | undefined - 못 찾을 수도 있음</code></pre>

        <div class="fragment tip">
          <strong>Tip:</strong> <code>find()</code>의 반환 타입이 <code>number | undefined</code>인 이유는
          요소를 찾지 못할 수 있기 때문입니다.
        </div>
      </section>

      <!-- Slide 6: Readonly Array -->
      <section data-transition="slide" data-narration="readonly 키워드를 배열 타입 앞에 붙이면 읽기 전용 배열이 됩니다. 코드에서 colors 배열에 push나 인덱스 할당을 시도하면 에러가 발생합니다. ReadonlyArray 제네릭 형태도 동일한 효과입니다. 특히 as const를 사용하면 배열이 읽기 전용 튜플이 되어 각 요소가 정확한 리터럴 타입이 됩니다. typeof와 인덱스 접근을 조합하면 유니온 타입을 추출할 수 있어 실무에서 매우 유용합니다.">
        <h2>읽기 전용 배열</h2>
        <pre><code class="language-typescript">// readonly 배열 - 수정 불가
const colors: readonly string[] = ["red", "green", "blue"];

colors.push("yellow");   // Error! readonly 배열에 push 불가
colors[0] = "black";     // Error! 요소 변경 불가

// ReadonlyArray 제네릭
const points: ReadonlyArray&lt;number&gt; = [1, 2, 3];

// as const - 모든 요소를 리터럴 타입으로 고정
const DIRECTIONS = ["north", "south", "east", "west"] as const;
// 타입: readonly ["north", "south", "east", "west"]

type Direction = typeof DIRECTIONS[number];
// 타입: "north" | "south" | "east" | "west"</code></pre>
        <div class="key-point">
          <h3>핵심 포인트</h3>
          <p><code>as const</code>는 배열을 <strong>읽기 전용 튜플 (Tuple, 고정 길이 배열)</strong>로 만들어
          각 요소가 리터럴 타입이 됩니다.</p>
        </div>
      </section>

      <!-- Slide 7: Tuples -->
      <section data-transition="slide" data-narration="튜플은 각 요소의 타입과 개수가 고정된 배열입니다. 코드에서 person을 string과 number 쌍으로 선언하면, 첫 번째 요소는 반드시 문자열이고 두 번째는 숫자여야 합니다. 순서가 바뀌거나 길이가 다르면 에러가 발생합니다. 구조 분해 할당으로 각 요소를 꺼내면 자동으로 올바른 타입이 추론됩니다. 리액트의 useState 훅이 튜플을 반환하는 대표적인 예입니다.">
        <h2>튜플 (Tuples)</h2>
        <p>고정된 길이와 각 위치별 타입이 정해진 배열</p>
        <pre><code class="language-typescript">// 기본 튜플 - 각 위치의 타입이 다름
let person: [string, number] = ["홍길동", 25];

// 각 요소 접근 시 올바른 타입으로 추론
let name = person[0];   // string
let age = person[1];    // number

// 타입 에러
person = [25, "홍길동"];     // Error! 순서가 다름
person = ["홍길동"];         // Error! 길이가 다름

// 구조 분해 할당과 함께 사용
const [userName, userAge] = person;
// userName: string, userAge: number

// 실용적인 예: React의 useState가 튜플을 반환
// const [count, setCount] = useState(0);
// 타입: [number, Dispatch&lt;SetStateAction&lt;number&gt;&gt;]</code></pre>
      </section>

      <!-- Slide 8: Tuples Advanced -->
      <section data-transition="slide" data-narration="튜플의 다양한 활용 패턴을 살펴봅시다. Point3D처럼 세 번째 요소에 물음표를 붙이면 선택적 요소가 됩니다. UserEntry처럼 이름을 붙이면 가독성이 향상됩니다. 나머지 요소를 사용하면 고정 요소 뒤에 가변 길이 요소를 둘 수 있습니다. getMinMax 함수처럼 여러 값을 반환할 때 튜플을 사용하면 구조 분해 할당으로 깔끔하게 결과를 받을 수 있습니다.">
        <h2>튜플 활용 패턴</h2>
        <pre><code class="language-typescript">// 선택적 요소가 있는 튜플
type Point2D = [number, number];
type Point3D = [number, number, number?];  // z는 선택적

const p1: Point2D = [10, 20];
const p2: Point3D = [10, 20, 30];
const p3: Point3D = [10, 20];       // OK - z 생략 가능

// 이름이 있는 튜플 (가독성 향상)
type UserEntry = [name: string, age: number, active: boolean];

const entry: UserEntry = ["Kim", 30, true];

// 나머지 요소가 있는 튜플
type StringNumberBooleans = [string, number, ...boolean[]];

const data: StringNumberBooleans = ["hello", 1, true, false, true];

// 함수에서 여러 값 반환
function getMinMax(nums: number[]): [min: number, max: number] {
  return [Math.min(...nums), Math.max(...nums)];
}
const [min, max] = getMinMax([3, 1, 4, 1, 5]);</code></pre>
      </section>

      <!-- Slide 9: Enums - Numeric -->
      <section data-transition="slide" data-narration="enum은 관련된 상수들을 하나의 그룹으로 묶어주는 타입입니다. 코드에서 Direction enum은 Up부터 0, 1, 2, 3으로 자동 증가합니다. Direction 대괄호 0으로 역방향 매핑도 가능합니다. StatusCode처럼 시작 값을 직접 지정할 수도 있습니다. 다만 숫자형 enum은 handleResponse에 200 같은 숫자를 직접 넣어도 허용되므로 타입 안전성이 완벽하지 않다는 점에 주의하세요.">
        <h2>열거형 (Enum) - 숫자형</h2>
        <p style="font-size: 0.85em; color: #aaa;">열거형이란 관련된 상수들을 하나의 그룹으로 묶어 이름을 붙인 것입니다. 예: 방향(상/하/좌/우)</p>
        <pre><code class="language-typescript">// 숫자형 enum - 기본값은 0부터 자동 증가
enum Direction {
  Up,      // 0
  Down,    // 1
  Left,    // 2
  Right    // 3
}

let dir: Direction = Direction.Up;
console.log(dir);              // 0
console.log(Direction[0]);     // "Up" (역방향 매핑)

// 시작 값을 지정할 수도 있음
enum StatusCode {
  OK = 200,
  NotFound = 404,
  InternalError = 500
}

function handleResponse(code: StatusCode) {
  if (code === StatusCode.OK) {
    console.log("성공!");
  }
}

handleResponse(StatusCode.OK);       // OK
handleResponse(200);                 // OK (숫자도 허용 - 주의!)</code></pre>
      </section>

      <!-- Slide 10: Enums - String & Const -->
      <section data-transition="slide" data-narration="왼쪽 코드에서 문자열 enum은 Theme의 각 멤버에 LIGHT, DARK, AUTO 문자열을 직접 지정합니다. 숫자형과 달리 역방향 매핑이 없어 더 안전합니다. 오른쪽의 const enum은 컴파일 시 Color.Red가 그대로 RED 문자열로 대체되어 enum 객체가 생성되지 않습니다. 번들 크기가 줄어드는 장점이 있지만 역방향 매핑이 불가합니다. 디버깅 편의성을 위해 문자열 enum을 사용하는 것이 일반적입니다.">
        <h2>문자열 열거형 &amp; const enum</h2>
        <div class="two-columns">
          <div>
            <h3 style="font-size: 0.95em; color: var(--ts-blue);">문자열 enum</h3>
            <pre><code class="language-typescript">// 문자열 enum - 더 안전
enum Theme {
  Light = "LIGHT",
  Dark  = "DARK",
  Auto  = "AUTO"
}

let current: Theme = Theme.Dark;
// current === "DARK"

// 숫자와 달리 역방향 매핑 없음
// Theme["DARK"] -> undefined</code></pre>
          </div>
          <div>
            <h3 style="font-size: 0.95em; color: var(--ts-green);">const enum</h3>
            <pre><code class="language-typescript">// const enum - 컴파일 (Compile) 시 값이 직접 삽입됨
const enum Color {
  Red   = "RED",
  Green = "GREEN",
  Blue  = "BLUE"
}

let c = Color.Red;
// 컴파일 결과: let c = "RED";
// enum 객체가 생성되지 않음!

// 장점: 번들 (Bundle, 최종 파일) 크기 감소
// 단점: 역방향 매핑 (값으로 이름 찾기) 불가</code></pre>
          </div>
        </div>

        <div class="fragment tip">
          <strong>Best Practice:</strong> 문자열 enum을 사용하면 디버깅이 쉽고 타입 안전성이 높아집니다.
          성능이 중요하면 <code>const enum</code>을 고려하세요.
        </div>
      </section>

      <!-- Slide 11: Enum alternatives -->
      <section data-transition="slide" data-narration="최근에는 enum 대신 as const 객체 패턴을 선호합니다. 코드에서 Status 객체에 as const를 붙이면 모든 속성이 읽기 전용 리터럴 타입이 됩니다. typeof와 keyof를 조합하면 ACTIVE, INACTIVE, PENDING 유니온 타입을 추출할 수 있습니다. 이 패턴은 트리 쉐이킹이 잘 되어 번들 크기 최적화에 유리하고, 자바스크립트와의 호환성도 좋으며, 타입 추출이 더 유연합니다.">
        <h2>Enum 대안: as const 패턴</h2>
        <p>최근 트렌드는 enum 대신 <code>as const</code> 객체를 선호합니다.</p>
        <pre><code class="language-typescript">// as const 객체 패턴 (enum 대안)
const Status = {
  Active: "ACTIVE",
  Inactive: "INACTIVE",
  Pending: "PENDING",
} as const;

// 유니온 (Union) 타입으로 추출
type Status = typeof Status[keyof typeof Status];
// "ACTIVE" | "INACTIVE" | "PENDING"

function setStatus(status: Status) {
  console.log(status);
}

setStatus(Status.Active);    // OK
setStatus("ACTIVE");         // OK
setStatus("INVALID");        // Error!</code></pre>

        <div class="key-point">
          <h3>왜 as const를 선호하는가?</h3>
          <p>트리 쉐이킹 (Tree Shaking, 사용하지 않는 코드 자동 제거) 가능, JavaScript(JS)와의 호환성, 더 유연한 타입 추출</p>
        </div>
      </section>

      <!-- Slide 12: any vs unknown -->
      <section data-transition="slide" data-narration="왼쪽 코드에서 any 타입은 모든 연산을 허용하여 foo.bar 접근이나 함수 호출도 에러 없이 통과시키지만, 런타임에서 크래시가 발생합니다. 오른쪽의 unknown 타입은 모든 값을 받을 수 있지만 직접 사용하면 에러가 발생합니다. typeof로 타입을 확인한 후에만 해당 타입의 메서드를 사용할 수 있습니다. 타입을 모를 때는 반드시 any 대신 unknown을 사용하여 타입 안전성을 유지하세요.">
        <h2>any vs unknown</h2>
        <div class="two-columns">
          <div>
            <h3 style="color: var(--ts-red); font-size: 1em;">any - 위험한 탈출구</h3>
            <pre><code class="language-typescript">// any: 모든 타입 허용, 체크 없음
let anything: any = "hello";
anything = 42;
anything = true;

// 위험! 아무 연산이나 가능
anything.foo.bar;     // OK (런타임 (Runtime, 실행 중) 에러)
anything();           // OK (런타임 에러)
anything.toFixed(2);  // OK (런타임 에러)

// 다른 타입에 할당도 가능!
let num: number = anything; // OK!</code></pre>
          </div>
          <div>
            <h3 style="color: var(--ts-green); font-size: 1em;">unknown - 안전한 대안</h3>
            <pre><code class="language-typescript">// unknown: 모든 타입 허용, 체크 필수
let something: unknown = "hello";
something = 42;
something = true;

// 안전! 직접 사용 불가
something.foo;        // Error!
something();          // Error!
something.toFixed(2); // Error!

// 타입 확인 후에만 사용 가능
if (typeof something === "number") {
  something.toFixed(2); // OK!
}</code></pre>
          </div>
        </div>

        <div class="fragment warning">
          <strong>규칙:</strong> <code>any</code> 대신 <code>unknown</code>을 사용하세요.
          타입 안전성을 유지하면서 유연성을 확보할 수 있습니다.
        </div>
      </section>

      <!-- Slide 13: unknown practical usage -->
      <section data-transition="slide" data-narration="unknown 타입의 실전 활용을 살펴봅시다. JSON.parse의 결과는 타입이 불확실하므로 unknown으로 받는 것이 안전합니다. 코드에서 parseJSON 함수는 결과를 unknown으로 반환하고, 사용하는 쪽에서 typeof나 in 연산자로 타입을 확인한 후 안전하게 접근합니다. API 응답 처리에서도 동일한 패턴을 사용합니다. 이렇게 타입 좁히기를 거치면 런타임 에러를 방지하면서 유연한 코드를 작성할 수 있습니다.">
        <h2>unknown 실전 활용</h2>
        <p>JSON.parse 결과, API 응답 등 타입이 불확실한 데이터를 안전하게 다루는 방법</p>
        <pre><code class="language-typescript">// JSON.parse 결과를 unknown으로 안전하게 처리
function parseJSON(text: string): unknown {
  return JSON.parse(text);
}

const data = parseJSON('{"name": "Kim", "age": 25}');

// 직접 접근 불가 - 에러!
// console.log(data.name);

// 타입 좁히기 (Type Narrowing)로 안전하게 접근
if (typeof data === "object" && data !== null && "name" in data) {
  console.log((data as { name: string }).name); // "Kim"
}

// API 응답 처리 패턴
async function fetchUser(id: number): Promise&lt;unknown&gt; {
  const response = await fetch(`/api/users/${id}`);
  return response.json(); // 결과 타입이 불확실
}

// 사용 시 타입 가드로 검증
async function displayUser(id: number) {
  const result = await fetchUser(id);
  if (typeof result === "object" && result !== null
      && "name" in result && "age" in result) {
    const user = result as { name: string; age: number };
    console.log(`${user.name}, ${user.age}세`);
  }
}</code></pre>
      </section>

      <!-- Slide 14: void, null, undefined -->
      <section data-transition="slide" data-narration="void는 반환값이 없는 함수에 사용됩니다. 코드에서 logMessage 함수처럼 console.log만 실행하고 값을 반환하지 않는 경우입니다. undefined는 값이 할당되지 않은 상태로, findUser 함수에서 사용자를 못 찾으면 undefined를 반환합니다. null은 의도적으로 값이 없음을 표현하며, getElementById가 대표적입니다. strictNullChecks를 켜면 string에 null을 넣을 수 없고, 유니온으로 명시해야 합니다.">
        <h2>void, null, undefined</h2>
        <pre><code class="language-typescript">// void - 반환값이 없는 함수
function logMessage(msg: string): void {
  console.log(msg);
  // return 없음 또는 return;
}

// undefined - 값이 할당되지 않은 상태
let u: undefined = undefined;

function findUser(id: number): string | undefined {
  // 사용자를 찾지 못하면 undefined 반환
  const users = ["Alice", "Bob"];
  return users[id];
}

// null - 의도적으로 "값 없음"을 표현
let n: null = null;

function getElement(id: string): HTMLElement | null {
  return document.getElementById(id);  // 없으면 null
}

// strictNullChecks가 true일 때 (권장 설정)
let userName: string = null;          // Error! string에 null 불가
let nullableName: string | null = null; // OK! 유니온으로 null 허용</code></pre>
      </section>

      <!-- Slide 14: never type -->
      <section data-transition="slide" data-narration="never는 절대 발생하지 않는 값의 타입입니다. 코드에서 throwError 함수는 항상 에러를 던지므로 정상적으로 반환되지 않아 never 타입입니다. infiniteLoop도 마찬가지입니다. 가장 유용한 패턴은 완전성 검사로, switch문의 default에서 shape를 never에 할당하면 모든 케이스를 빠짐없이 처리했는지 컴파일 시점에 검증할 수 있습니다.">
        <h2>never 타입</h2>
        <div class="key-point">
          <h3>핵심 개념</h3>
          <p><code>never</code>는 <strong>절대 발생하지 않는 값</strong>의 타입입니다.<br>
          함수가 정상적으로 종료되지 않거나, 도달 불가능한 코드에서 사용됩니다.</p>
        </div>
        <pre><code class="language-typescript">// 항상 에러를 던지는 함수
function throwError(message: string): never {
  throw new Error(message);
}

// 무한 루프
function infiniteLoop(): never {
  while (true) { }
}

// 가장 유용한 패턴: 완전성 검사 (Exhaustive Check, 모든 경우를 빠짐없이 처리했는지 확인)
type Shape = "circle" | "square" | "triangle";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":    return Math.PI * 10 * 10;
    case "square":    return 10 * 10;
    case "triangle":  return (10 * 10) / 2;
    default:
      // shape가 never 타입이면 모든 케이스를 처리한 것
      const _exhaustive: never = shape;
      return _exhaustive;
  }
}</code></pre>
      </section>

      <!-- Slide 15: never exhaustive check -->
      <section data-transition="slide" data-narration="코드에서 Shape 유니온에 pentagon을 추가했는데, switch문에서 pentagon 케이스를 처리하지 않으면 default에서 shape가 pentagon 타입이 됩니다. 이를 never에 할당하려 하면 컴파일 에러가 발생하여 누락된 케이스를 즉시 알 수 있습니다. 이 패턴은 유니온 타입에 새 멤버를 추가할 때 관련 코드를 빠짐없이 수정하도록 강제하는 강력한 안전 장치입니다. 대규모 프로젝트에서 특히 유용합니다.">
        <h2>never를 활용한 안전 장치</h2>
        <p>새로운 타입이 추가되면 컴파일 에러로 알려줍니다</p>
        <pre><code class="language-typescript">// Shape에 "pentagon"을 추가하면?
type Shape = "circle" | "square" | "triangle" | "pentagon";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle":    return Math.PI * 10 * 10;
    case "square":    return 10 * 10;
    case "triangle":  return (10 * 10) / 2;
    // case "pentagon" 빠뜨림!
    default:
      const _exhaustive: never = shape;
      // Error! Type '"pentagon"' is not assignable to type 'never'
      // -> pentagon 케이스를 처리하지 않았다고 알려줌!
      return _exhaustive;
  }
}</code></pre>
        <div class="tip">
          <strong>Tip:</strong> 이 패턴은 유니온 타입에 새 멤버를 추가할 때 빠뜨린 처리를
          컴파일 (Compile) 시점에 잡아주는 강력한 안전 장치입니다.
        </div>
      </section>

      <!-- Slide 16: Type Assertions -->
      <section data-transition="slide" data-narration="타입 단언은 개발자가 컴파일러보다 타입을 더 잘 아는 경우에 사용합니다. 코드에서 getElementById의 결과를 as HTMLInputElement로 단언하면 value 속성에 접근할 수 있습니다. JSON.parse 결과에 인터페이스 타입을 단언하는 것도 흔한 패턴입니다. 하지만 타입 단언은 타입 체크를 우회하므로 런타임 에러의 원인이 될 수 있습니다. 이중 단언은 최후의 수단으로만 사용하세요.">
        <h2>타입 단언 (Type Assertion)</h2>
        <p>개발자가 컴파일러 (Compiler)보다 타입을 더 잘 아는 경우 사용합니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">"이 값은 이 타입이 확실해!"라고 TypeScript에게 직접 알려주는 방법입니다.</span></p>
        <pre><code class="language-typescript">// as 구문 (권장)
const input = document.getElementById("myInput") as HTMLInputElement;
input.value = "Hello";  // HTMLInputElement로 단언했으므로 .value 접근 가능

// 앵글 브래킷 구문 (JSX에서는 사용 불가)
const canvas = &lt;HTMLCanvasElement&gt;document.getElementById("myCanvas");

// JSON 파싱 결과에 타입 지정
interface Config {
  host: string;
  port: number;
}
const config = JSON.parse(rawData) as Config;

// 이중 단언 (최후의 수단!)
const value = "hello" as unknown as number;  // 위험하지만 가능</code></pre>

        <div class="fragment warning">
          <strong>Warning:</strong> 타입 단언은 타입 체크를 <strong>우회</strong>합니다.
          런타임 에러의 원인이 될 수 있으니 신중하게 사용하세요.
        </div>
      </section>

      <!-- Slide 17: Literal Types -->
      <section data-transition="slide" data-narration="리터럴 타입은 정확한 값 하나만 허용하는 타입입니다. 코드에서 direction 변수는 up, down, left, right 네 가지 문자열만 허용하고, diagonal을 넣으면 에러입니다. DiceRoll 타입은 1부터 6까지의 숫자만 가능합니다. const 변수는 자동으로 리터럴 타입이 되어 PI의 타입이 number가 아닌 3.14가 됩니다. 함수 매개변수에서 허용 값을 제한할 때 매우 유용한 패턴입니다.">
        <h2>리터럴 타입 (Literal Type)</h2>
        <p style="font-size: 0.85em; color: #aaa;">리터럴이란 코드에 직접 쓴 고정된 값을 말합니다. 리터럴 타입은 "정확히 이 값만 허용"하는 타입입니다.</p>
        <pre><code class="language-typescript">// 리터럴 타입: 특정 값만 허용
let direction: "up" | "down" | "left" | "right";

direction = "up";      // OK
direction = "diagonal"; // Error! 허용된 값이 아님

// 숫자 리터럴 타입
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;
let roll: DiceRoll = 3;   // OK
let roll2: DiceRoll = 7;  // Error!

// boolean 리터럴 타입
type True = true;

// const 변수는 자동으로 리터럴 타입
const PI = 3.14;        // 타입: 3.14 (number가 아님!)
let mutable = 3.14;     // 타입: number

// 함수 매개변수에서 활용
function setAlignment(align: "left" | "center" | "right") {
  // align은 정확히 3가지 값만 가능
}
setAlignment("center"); // OK
setAlignment("top");    // Error!</code></pre>
      </section>

      <!-- Slide 18: Union Types -->
      <section data-transition="slide" data-narration="유니온 타입은 세로 막대 기호로 여러 타입을 연결하여, 그 중 하나가 될 수 있음을 나타냅니다. 코드에서 id는 string 또는 number 타입입니다. printId 함수에서 typeof로 타입을 확인하면 해당 블록 안에서 정확한 타입으로 좁혀져 toUpperCase나 toFixed 메서드를 사용할 수 있습니다. API 응답처럼 성공과 실패가 다른 구조를 가질 때 유니온 타입이 특히 유용합니다.">
        <h2>유니온 타입 (Union Type)</h2>
        <p style="font-size: 0.85em; color: #aaa;">유니온이란 "합집합"이라는 뜻으로, 여러 타입 중 하나가 될 수 있다는 의미입니다. <code>|</code> 기호로 연결합니다.</p>
        <pre><code class="language-typescript">// 여러 타입 중 하나가 될 수 있음
let id: string | number;
id = "abc-123";   // OK
id = 42;          // OK
id = true;        // Error!

// 유니온 타입과 타입 가드 (Type Guard, 타입을 확인하여 좁혀나가는 기법)
function printId(id: string | number) {
  if (typeof id === "string") {
    // 이 블록에서 id는 string (typeof로 타입을 확인했으므로)
    console.log(id.toUpperCase());
  } else {
    // 이 블록에서 id는 number
    console.log(id.toFixed(2));
  }
}

// 유니온 타입의 공통 멤버만 접근 가능
function getLength(value: string | number[]) {
  // string과 number[] 모두 .length가 있음
  return value.length;  // OK
}

// 실용적 예: API 응답 타입
type ApiResponse =
  | { status: "success"; data: string }
  | { status: "error"; message: string };</code></pre>
      </section>

      <!-- Slide 19: Summary Table -->
      <section data-transition="slide" data-narration="챕터 2를 정리하겠습니다. 표에서 보듯이 원시 타입 세 가지, 배열과 튜플, enum, any와 unknown, void와 never, 리터럴 타입과 유니온 타입까지 12가지 기본 타입을 모두 학습했습니다. 가장 중요한 포인트는 any 대신 unknown을 사용하고, never로 완전성 검사를 하며, 리터럴 타입과 유니온으로 정확한 타입을 표현하는 것입니다. 다음 챕터에서는 함수의 타입 시스템을 학습합니다.">
        <h2>Chapter 2 정리</h2>
        <table class="compare-table" style="font-size: 0.75em;">
          <thead>
            <tr>
              <th>타입</th>
              <th>설명</th>
              <th>예시</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><code>string</code></td><td>문자열</td><td><code>"hello"</code></td></tr>
            <tr><td><code>number</code></td><td>숫자 (정수/실수)</td><td><code>42, 3.14</code></td></tr>
            <tr><td><code>boolean</code></td><td>참/거짓</td><td><code>true, false</code></td></tr>
            <tr><td><code>array</code></td><td>배열</td><td><code>number[], Array&lt;string&gt;</code></td></tr>
            <tr><td><code>tuple</code></td><td>고정 길이 배열</td><td><code>[string, number]</code></td></tr>
            <tr><td><code>enum</code></td><td>열거형</td><td><code>enum Color { Red }</code></td></tr>
            <tr><td><code>any</code></td><td>모든 타입 (위험)</td><td>사용 자제</td></tr>
            <tr><td><code>unknown</code></td><td>안전한 any</td><td>타입 체크 후 사용</td></tr>
            <tr><td><code>void</code></td><td>반환값 없음</td><td><code>(): void</code></td></tr>
            <tr><td><code>never</code></td><td>도달 불가</td><td>에러, 완전성 검사</td></tr>
            <tr><td>리터럴</td><td>특정 값</td><td><code>"up" | "down"</code></td></tr>
            <tr><td>유니온</td><td>여러 타입 중 하나</td><td><code>string | number</code></td></tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 20: Next Chapter -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 2를 마치겠습니다. 가장 중요한 포인트는 타입을 정확하게 표현할수록 컴파일러가 더 많은 버그를 잡아준다는 것입니다. any는 최대한 피하고, unknown과 타입 좁히기를 활용하세요. 실무에서는 리터럴 타입과 유니온 조합을 가장 많이 사용합니다. 다음 챕터에서는 함수의 매개변수 타입, 오버로드, 제네릭 등 함수 타입 시스템을 학습합니다.">
        <span class="chapter-number">Next</span>
        <h1>수고하셨습니다!</h1>
        <br>
        <p>
          <a href="03-functions.html" style="color: var(--ts-blue); font-size: 1.2em;">
            다음 챕터: 함수 &#8594;
          </a>
        </p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.7em;">&#8592; 목차로 돌아가기</a></p>
      </section>

    </div>
  </div>

  <div class="nav-footer">
    <a href="../index.html" style="color: #888;">TypeScript 완전 정복</a> | Chapter 02
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
