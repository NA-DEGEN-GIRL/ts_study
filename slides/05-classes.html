<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Chapter 5: 클래스 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-narration="챕터 5, 클래스입니다. 타입스크립트에서 객체 지향 프로그래밍의 핵심인 클래스를 배워보겠습니다.">
        <div class="chapter-number">Chapter 5</div>
        <h1>클래스 (Class)</h1>
        <p class="subtitle">TypeScript의 객체지향 프로그래밍</p>
        <br>
        <p style="font-size:0.6em; color:#888;">
          <span class="badge badge-blue">OOP</span>
          <span class="badge badge-green">캡슐화 (Encapsulation)</span>
          <span class="badge badge-orange">상속 (Inheritance)</span>
          <span class="badge badge-red">추상화</span>
        </p>
      </section>

      <!-- Slide 2: Class Basics -->
      <section data-narration="클래스는 객체를 생성하기 위한 설계도입니다. 타입스크립트에서는 속성에 타입을 지정하고, 생성자에서 초기화하는 구조를 갖습니다.">
        <h2>클래스 기본 구조</h2>
        <p>프로퍼티, 생성자 (Constructor), 메서드로 구성됩니다</p>
        <div class="tip" style="margin-bottom: 0.5em;">
          <strong>왜 클래스가 필요한가?</strong> 관련된 데이터(프로퍼티)와 동작(메서드)을 하나로 묶어서 관리하면, 코드를 더 체계적으로 정리할 수 있습니다. 붕어빵 틀(클래스)로 붕어빵(인스턴스 (Instance, 클래스로 만든 실제 객체))을 찍어내는 것과 같습니다.
        </div>
        <pre><code class="typescript" data-trim data-noescape>
class User {
  // 프로퍼티 선언 (타입 필수!)
  name: string;
  email: string;
  age: number;

  // 생성자: 클래스로 객체를 만들 때 자동으로 호출되는 함수
  constructor(name: string, email: string, age: number) {
    this.name = name;
    this.email = email;
    this.age = age;
  }

  // 메서드: 클래스 안에 정의된 함수
  greet(): string {
    return `안녕하세요, ${this.name}입니다!`;
  }
}

// new 키워드로 인스턴스(실제 객체) 생성
const user = new User("홍길동", "hong@example.com", 30);
console.log(user.greet()); // "안녕하세요, 홍길동입니다!"
        </code></pre>
        <div class="tip fragment">
          TypeScript에서는 프로퍼티를 <strong>반드시 선언</strong>해야 합니다. JavaScript처럼 constructor에서 바로 할당하면 오류!
        </div>
      </section>

      <!-- Slide 3: Access Modifiers -->
      <section data-narration="접근 제어자에는 public, private, protected가 있습니다. public은 어디서나 접근 가능하고, private는 클래스 내부에서만, protected는 상속받은 클래스에서도 접근할 수 있습니다.">
        <h2>접근 제어자 (Access Modifier)</h2>
        <table class="compare-table">
          <thead>
            <tr>
              <th>제어자</th>
              <th>클래스 내부</th>
              <th>자식 클래스</th>
              <th>외부</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fragment">
              <td><span class="badge badge-green">public</span></td>
              <td>O</td>
              <td>O</td>
              <td>O</td>
            </tr>
            <tr class="fragment">
              <td><span class="badge badge-orange">protected</span></td>
              <td>O</td>
              <td>O</td>
              <td>X</td>
            </tr>
            <tr class="fragment">
              <td><span class="badge badge-red">private</span></td>
              <td>O</td>
              <td>X</td>
              <td>X</td>
            </tr>
          </tbody>
        </table>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
class BankAccount {
  public owner: string;         // 어디서든 접근 가능 (기본값)
  protected balance: number;    // 클래스와 자식에서만
  private pin: string;          // 이 클래스 내부에서만

  constructor(owner: string, balance: number, pin: string) {
    this.owner = owner;
    this.balance = balance;
    this.pin = pin;
  }
}
        </code></pre>
      </section>

      <!-- Slide 4: Access Modifiers in Action -->
      <section data-narration="접근 제어자를 실전에서 활용하는 방법을 살펴봅시다. 은행 계좌 클래스를 예로 들어 잔액을 private로 보호하고, 메서드를 통해서만 접근하는 패턴입니다.">
        <h2>접근 제어자 실전 예제</h2>
        <pre><code class="typescript" data-trim data-noescape>
class BankAccount {
  public owner: string;         // 공개: 어디서든 접근 가능
  protected balance: number;    // 보호: 이 클래스와 자식 클래스에서만
  private pin: string;          // 비공개: 이 클래스 내부에서만

  constructor(owner: string, balance: number, pin: string) {
    this.owner = owner;
    this.balance = balance;
    this.pin = pin;
  }

  // private 메서드: 클래스 내부에서만 호출 가능
  private verifyPin(inputPin: string): boolean {
    return this.pin === inputPin;
  }

  // public 메서드: 외부에서 호출 가능
  public withdraw(amount: number, inputPin: string): boolean {
    if (!this.verifyPin(inputPin)) return false;  // 내부에서 private 호출
    if (this.balance < amount) return false;
    this.balance -= amount;
    return true;
  }
}

// 상속: 부모 클래스의 기능을 물려받음
class SavingsAccount extends BankAccount {
  getBalance(): number {
    return this.balance;    // OK: protected는 자식에서 접근 가능
    // return this.pin;     // Error: private은 자식에서도 접근 불가!
  }
}

const account = new BankAccount("홍길동", 10000, "1234");
account.owner;              // OK: public이므로 외부에서 접근 가능
// account.balance;         // Error: protected - 외부 접근 불가
// account.pin;             // Error: private - 외부 접근 불가
        </code></pre>
      </section>

      <!-- Slide 5: readonly -->
      <section data-narration="readonly 키워드를 클래스 속성에 사용하면 생성자에서만 값을 설정할 수 있고, 이후에는 변경이 불가능합니다.">
        <h2><code>readonly</code> 프로퍼티</h2>
        <p>생성 시에만 값을 할당하고, 이후 변경 불가 (읽기 전용)</p>
        <pre><code class="typescript" data-trim data-noescape>
class Config {
  readonly apiUrl: string;
  readonly maxRetries: number;
  readonly createdAt: Date;

  constructor(apiUrl: string, maxRetries: number) {
    // 생성자에서만 할당 가능
    this.apiUrl = apiUrl;
    this.maxRetries = maxRetries;
    this.createdAt = new Date();
  }

  // updateUrl(url: string) {
  //   this.apiUrl = url;  // Error! readonly 변경 불가
  // }
}

const config = new Config("https://api.example.com", 3);
console.log(config.apiUrl);     // OK: 읽기는 가능
// config.apiUrl = "new-url";   // Error: readonly!
        </code></pre>
        <div class="key-point fragment">
          <h3>readonly vs const</h3>
          <p><code>const</code>는 변수에, <code>readonly</code>는 프로퍼티에 사용합니다.</p>
        </div>
      </section>

      <!-- Slide 6: Parameter Properties -->
      <section data-narration="매개변수 프로퍼티는 생성자의 매개변수에 접근 제어자를 붙여 속성 선언과 초기화를 동시에 하는 축약 문법입니다. 코드가 훨씬 간결해집니다.">
        <h2>매개변수 프로퍼티 (Parameter Properties)</h2>
        <p>생성자 매개변수에 접근 제한자를 붙이면 자동으로 프로퍼티 선언 + 할당!</p>
        <div class="two-columns">
          <div>
            <h3>기존 방식 (장황함)</h3>
            <pre><code class="typescript" data-trim data-noescape>
class User {
  public name: string;
  private email: string;
  readonly id: number;

  constructor(
    name: string,
    email: string,
    id: number
  ) {
    this.name = name;
    this.email = email;
    this.id = id;
  }
}
            </code></pre>
          </div>
          <div class="fragment">
            <h3>매개변수 프로퍼티 (간결!)</h3>
            <pre><code class="typescript" data-trim data-noescape>
class User {
  constructor(
    public name: string,
    private email: string,
    readonly id: number
  ) {
    // 자동으로 선언 + 할당!
    // 본문이 비어있어도 OK
  }
}
            </code></pre>
          </div>
        </div>
        <div class="tip fragment">
          두 코드는 <strong>완전히 동일</strong>합니다. 매개변수 프로퍼티를 사용하면 보일러플레이트를 크게 줄일 수 있습니다.
        </div>
      </section>

      <!-- Slide 7: Getters and Setters -->
      <section data-narration="게터와 세터를 사용하면 속성에 접근할 때 추가 로직을 실행할 수 있습니다. 값 검증이나 계산된 속성을 구현할 때 유용합니다.">
        <h2>게터/세터 (Getter/Setter)</h2>
        <p>프로퍼티 접근을 제어하고 유효성 검증 로직을 추가</p>
        <pre><code class="typescript" data-trim data-noescape>
class Temperature {
  private _celsius: number;

  constructor(celsius: number) {
    this._celsius = celsius;
  }

  // Getter: 프로퍼티처럼 읽기
  get fahrenheit(): number {
    return this._celsius * 9 / 5 + 32;
  }

  // Setter: 프로퍼티처럼 쓰기 + 유효성 검증
  set celsius(value: number) {
    if (value < -273.15) {
      throw new Error("절대영도 이하는 불가능합니다!");
    }
    this._celsius = value;
  }

  get celsius(): number {
    return this._celsius;
  }
}

const temp = new Temperature(100);
console.log(temp.fahrenheit);  // 212 (마치 프로퍼티처럼!)
temp.celsius = 0;              // setter 호출
// temp.celsius = -300;        // Error: 절대영도 이하!
        </code></pre>
        <div class="tip fragment">
          Getter만 있고 Setter가 없으면 자동으로 <strong>readonly</strong>가 됩니다.
        </div>
      </section>

      <!-- Slide 8: Static Members -->
      <section data-narration="static 키워드를 사용하면 인스턴스가 아닌 클래스 자체에 속하는 멤버를 정의할 수 있습니다. 유틸리티 함수나 공유 상수에 사용됩니다.">
        <h2>정적 멤버 (Static Member)</h2>
        <p>인스턴스가 아닌 <strong>클래스 자체</strong>에 속하는 멤버</p>
        <pre><code class="typescript" data-trim data-noescape>
class MathUtils {
  static readonly PI = 3.14159265;

  static circleArea(radius: number): number {
    return MathUtils.PI * radius ** 2;
  }

  static clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
  }
}

// new 없이 클래스 이름으로 직접 호출!
console.log(MathUtils.PI);              // 3.14159265
console.log(MathUtils.circleArea(5));   // 78.539...
console.log(MathUtils.clamp(15, 0, 10)); // 10
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: 싱글톤 패턴 (프로그램 전체에서 딱 하나만 존재하는 객체)
class Database {
  private static instance: Database;  // 유일한 인스턴스 저장

  // private 생성자: 외부에서 new로 생성 못하게 막음
  private constructor(private connectionString: string) {}

  // 유일한 인스턴스를 반환하는 정적 메서드
  static getInstance(): Database {
    if (!Database.instance) {
      Database.instance = new Database("mongodb://localhost:27017");
    }
    return Database.instance;
  }
}

const db1 = Database.getInstance();
const db2 = Database.getInstance();
console.log(db1 === db2); // true (항상 같은 인스턴스!)
        </code></pre>
      </section>

      <!-- Slide 9: Abstract Classes -->
      <section data-narration="추상 클래스는 직접 인스턴스를 만들 수 없고, 반드시 상속하여 추상 메서드를 구현해야 합니다. 공통 기능은 추상 클래스에서 구현하고, 세부 사항은 하위 클래스에 위임합니다.">
        <h2>추상 클래스 (Abstract Class)</h2>
        <p>직접 인스턴스화할 수 없고, 반드시 상속해서 구현 (Implements)해야 하는 클래스</p>
        <pre><code class="typescript" data-trim data-noescape>
abstract class Shape {
  constructor(public color: string) {}

  // 추상 메서드: 구현 없이 시그니처만 정의
  abstract getArea(): number;
  abstract getPerimeter(): number;

  // 일반 메서드: 공통 로직 제공
  describe(): string {
    return `${this.color} 도형 (면적: ${this.getArea().toFixed(2)})`;
  }
}

// const shape = new Shape("red"); // Error! 추상 클래스 인스턴스화 불가

class Circle extends Shape {
  constructor(color: string, public radius: number) {
    super(color);
  }

  // 반드시 구현해야 함!
  getArea(): number {
    return Math.PI * this.radius ** 2;
  }

  getPerimeter(): number {
    return 2 * Math.PI * this.radius;
  }
}

class Rectangle extends Shape {
  constructor(color: string, public width: number, public height: number) {
    super(color);
  }

  getArea(): number { return this.width * this.height; }
  getPerimeter(): number { return 2 * (this.width + this.height); }
}

const circle = new Circle("파랑", 5);
console.log(circle.describe()); // "파랑 도형 (면적: 78.54)"
        </code></pre>
      </section>

      <!-- Slide 10: Abstract vs Interface -->
      <section data-narration="추상 클래스는 구현 코드를 포함할 수 있지만, 인터페이스는 형태만 정의합니다. 추상 클래스는 단일 상속만 가능하고, 인터페이스는 여러 개를 동시에 구현할 수 있습니다.">
        <h2>추상 클래스 vs 인터페이스 (Interface)</h2>
        <table class="compare-table">
          <thead>
            <tr>
              <th>특성</th>
              <th>추상 클래스</th>
              <th>인터페이스</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fragment">
              <td>구현 코드 포함</td>
              <td>가능 (일반 메서드)</td>
              <td>불가능</td>
            </tr>
            <tr class="fragment">
              <td>다중 상속/구현</td>
              <td>단일 상속만</td>
              <td>다중 구현 가능</td>
            </tr>
            <tr class="fragment">
              <td>생성자</td>
              <td>가질 수 있음</td>
              <td>없음</td>
            </tr>
            <tr class="fragment">
              <td>접근 제한자</td>
              <td>사용 가능</td>
              <td>public만</td>
            </tr>
            <tr class="fragment">
              <td>런타임 (Runtime, 실행 시점) 존재</td>
              <td>JavaScript로 컴파일 (Compile, 코드 변환)됨</td>
              <td>컴파일 시 제거됨</td>
            </tr>
            <tr class="fragment">
              <td>사용 시기</td>
              <td>공통 구현 + 틀 제공</td>
              <td>계약(규격) 정의</td>
            </tr>
          </tbody>
        </table>
        <div class="key-point fragment">
          <h3>선택 기준</h3>
          <p>공통 로직이 있으면 <strong>추상 클래스</strong>, 순수하게 형태만 정의하면 <strong>인터페이스</strong></p>
        </div>
      </section>

      <!-- Slide 11: Implementing Interfaces -->
      <section data-narration="implements 키워드를 사용하면 클래스가 특정 인터페이스를 반드시 구현하도록 강제할 수 있습니다. 여러 인터페이스를 동시에 구현하는 것도 가능합니다.">
        <h2>인터페이스 구현 (<code>implements</code>)</h2>
        <p>클래스가 특정 인터페이스의 계약을 이행하도록 강제합니다. "이 클래스는 반드시 이 기능들을 가지고 있어야 한다"는 약속입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
interface Serializable {
  serialize(): string;
  deserialize(data: string): void;
}

interface Loggable {
  log(message: string): void;
}

// 다중 인터페이스 구현 가능!
class UserProfile implements Serializable, Loggable {
  constructor(
    public name: string,
    public email: string
  ) {}

  serialize(): string {
    return JSON.stringify({ name: this.name, email: this.email });
  }

  deserialize(data: string): void {
    const parsed = JSON.parse(data);
    this.name = parsed.name;
    this.email = parsed.email;
  }

  log(message: string): void {
    console.log(`[UserProfile] ${message}`);
  }
}

// 인터페이스 타입으로 사용 가능
function saveToFile(item: Serializable): void {
  const data = item.serialize();
  // 파일에 저장...
}
        </code></pre>
        <div class="warning fragment">
          <code>implements</code>는 타입 체크만 합니다. 인터페이스의 메서드를 구현하지 않으면 컴파일 에러!
        </div>
      </section>

      <!-- Slide 12: Class Expressions -->
      <section data-narration="클래스도 변수에 할당할 수 있는 표현식으로 사용할 수 있습니다. 팩토리 패턴이나 즉석에서 클래스를 생성할 때 활용됩니다.">
        <h2>클래스 표현식 (Class Expressions)</h2>
        <p>함수 표현식처럼 클래스도 표현식으로 사용 가능</p>
        <pre><code class="typescript" data-trim data-noescape>
// 이름 있는 클래스 표현식
const Animal = class AnimalClass {
  constructor(public name: string) {}

  speak(): string {
    return `${this.name}이(가) 소리를 냅니다.`;
  }
};

const dog = new Animal("멍멍이");
// new AnimalClass("..."); // Error: 외부에서 클래스 이름 접근 불가
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: 팩토리 패턴에서 유용
function createLogger(prefix: string) {
  return class {
    log(message: string) {
      console.log(`[${prefix}] ${message}`);
    }
  };
}

const AppLogger = createLogger("APP");
const DbLogger = createLogger("DB");

const logger = new AppLogger();
logger.log("서버 시작됨"); // [APP] 서버 시작됨
        </code></pre>
      </section>

      <!-- Slide 13: this Type -->
      <section data-narration="this 타입을 활용하면 메서드 체이닝이 가능한 클래스를 만들 수 있습니다. 상속받은 클래스에서도 올바른 타입이 유지됩니다.">
        <h2>this 타입</h2>
        <p><code>this</code>를 타입으로 사용하면 메서드 체이닝에 유용</p>
        <pre><code class="typescript" data-trim data-noescape>
class QueryBuilder {
  private conditions: string[] = [];
  private orderByField?: string;

  where(condition: string): this {
    this.conditions.push(condition);
    return this; // this 반환으로 체이닝
  }

  orderBy(field: string): this {
    this.orderByField = field;
    return this;
  }

  build(): string {
    let query = "SELECT * FROM table";
    if (this.conditions.length > 0) {
      query += " WHERE " + this.conditions.join(" AND ");
    }
    if (this.orderByField) {
      query += " ORDER BY " + this.orderByField;
    }
    return query;
  }
}

// 자식 클래스에서도 체이닝이 유지됨!
class AdvancedQueryBuilder extends QueryBuilder {
  private limitCount?: number;

  limit(count: number): this {
    this.limitCount = count;
    return this;
  }
}

const query = new AdvancedQueryBuilder()
  .where("age > 18")       // this = AdvancedQueryBuilder
  .where("active = true")  // this = AdvancedQueryBuilder
  .orderBy("name")         // this = AdvancedQueryBuilder
  .limit(10)               // this = AdvancedQueryBuilder
  .build();
        </code></pre>
      </section>

      <!-- Slide 14: Mixins Pattern -->
      <section data-narration="믹스인은 여러 클래스의 기능을 조합하는 패턴입니다. 타입스크립트에서는 함수를 사용하여 클래스에 기능을 추가하는 방식으로 구현합니다.">
        <h2>믹스인 (Mixin) 패턴</h2>
        <p>다중 상속 (Multiple Inheritance)의 대안 - 여러 클래스의 기능을 조합</p>
        <pre><code class="typescript" data-trim data-noescape>
// 믹스인을 위한 생성자 타입
type Constructor&lt;T = {}&gt; = new (...args: any[]) => T;

// 타임스탬프 믹스인
function Timestamped&lt;TBase extends Constructor&gt;(Base: TBase) {
  return class extends Base {
    createdAt = new Date();
    updatedAt = new Date();

    touch() {
      this.updatedAt = new Date();
    }
  };
}

// 소프트 삭제 믹스인
function SoftDeletable&lt;TBase extends Constructor&gt;(Base: TBase) {
  return class extends Base {
    isDeleted = false;
    deletedAt?: Date;

    softDelete() {
      this.isDeleted = true;
      this.deletedAt = new Date();
    }
  };
}

// 기본 클래스
class User {
  constructor(public name: string, public email: string) {}
}

// 믹스인 조합!
const EnhancedUser = SoftDeletable(Timestamped(User));

const user = new EnhancedUser("홍길동", "hong@mail.com");
user.touch();         // Timestamped 기능
user.softDelete();    // SoftDeletable 기능
console.log(user.createdAt, user.isDeleted); // 모든 기능 사용 가능
        </code></pre>
      </section>

      <!-- Slide 15: Real-World Example -->
      <section data-narration="이벤트 시스템을 클래스로 구현해 봅시다. 이벤트 등록, 발생, 해제 기능을 타입 안전하게 구현하는 실전 패턴입니다.">
        <h2>실전 예제: 이벤트 시스템</h2>
        <pre><code class="typescript" data-trim data-noescape>
type EventHandler&lt;T = any&gt; = (data: T) => void;

abstract class EventEmitter {
  private handlers: Map&lt;string, EventHandler[]&gt; = new Map();

  on(event: string, handler: EventHandler): void {
    const existing = this.handlers.get(event) || [];
    this.handlers.set(event, [...existing, handler]);
  }

  protected emit(event: string, data?: any): void {
    const handlers = this.handlers.get(event) || [];
    handlers.forEach(handler => handler(data));
  }

  off(event: string, handler: EventHandler): void {
    const existing = this.handlers.get(event) || [];
    this.handlers.set(event, existing.filter(h => h !== handler));
  }
}

class ShoppingCart extends EventEmitter {
  private items: Array&lt;{ name: string; price: number }&gt; = [];

  addItem(name: string, price: number): void {
    this.items.push({ name, price });
    this.emit("itemAdded", { name, price });
    this.emit("totalChanged", this.getTotal());
  }

  getTotal(): number {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  }
}

const cart = new ShoppingCart();
cart.on("itemAdded", (item) => console.log(`추가됨: ${item.name}`));
cart.on("totalChanged", (total) => console.log(`합계: ${total}원`));
cart.addItem("TypeScript 책", 35000);
        </code></pre>
      </section>

      <!-- Slide 16: Summary -->
      <section data-narration="챕터 5를 마치겠습니다. 클래스의 기본 구조부터 접근 제어자, 추상 클래스, 인터페이스 구현, 그리고 믹스인까지 객체 지향 프로그래밍의 핵심을 학습했습니다.">
        <h2>Chapter 5 요약</h2>
        <div class="key-point">
          <h3>핵심 정리</h3>
          <ul>
            <li class="fragment"><strong>클래스 기본</strong>: 프로퍼티 선언 필수, 생성자에서 초기화</li>
            <li class="fragment"><strong>접근 제어자</strong>: <code>public</code> / <code>protected</code> / <code>private</code>로 캡슐화</li>
            <li class="fragment"><strong>매개변수 프로퍼티</strong>: 생성자 매개변수에 제어자 = 자동 선언 + 할당</li>
            <li class="fragment"><strong>Getter/Setter</strong>: 프로퍼티 접근 제어 및 유효성 검증</li>
            <li class="fragment"><strong>static</strong>: 인스턴스 없이 클래스 레벨에서 접근</li>
            <li class="fragment"><strong>abstract</strong>: 구현을 강제하는 틀 제공 (인스턴스화 불가)</li>
            <li class="fragment"><strong>implements</strong>: 인터페이스 계약 이행</li>
            <li class="fragment"><strong>this 타입</strong>: 메서드 체이닝, 믹스인 등 고급 패턴</li>
          </ul>
        </div>
        <br>
        <p class="fragment">
          <a href="06-generics.html" style="color: var(--ts-blue);">
            다음 챕터: Chapter 6 - 제네릭 &rarr;
          </a>
        </p>
      </section>

    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
