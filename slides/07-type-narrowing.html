<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Chapter 7: 타입 좁히기 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-narration="챕터 7, 타입 좁히기입니다. 이 챕터에서는 유니온 타입에서 정확한 타입을 추론하는 다양한 기법, 판별 유니온 패턴, 그리고 완전성 검사를 학습합니다. 타입 좁히기는 타입 안전한 코드 작성의 핵심이며, 실전에서 런타임 에러를 방지하는 데 필수적입니다.">
        <div class="chapter-number">Chapter 7</div>
        <h1>타입 좁히기 (Type Narrowing)</h1>
        <p class="subtitle">넓은 타입을 좁은 타입으로</p>
        <br>
        <p style="font-size:0.6em; color:#888;">
          <span class="badge badge-blue">타입 가드 (Type Guard)</span>
          <span class="badge badge-green">판별 유니온 (Discriminated Union)</span>
          <span class="badge badge-orange">제어 흐름 분석</span>
        </p>
      </section>

      <!-- Slide 2: What is Type Narrowing? -->
      <section data-narration="타입 좁히기란 넓은 타입에서 더 구체적인 타입으로 범위를 줄이는 것입니다. 코드에서 printValue 함수는 string 또는 number 유니온을 받아, typeof 조건문으로 string일 때 toUpperCase를, number일 때 toFixed를 안전하게 호출합니다. 타입스크립트 컴파일러의 제어 흐름 분석이 이를 자동으로 처리합니다.">
        <h2>타입 좁히기란?</h2>
        <div class="tip" style="margin-bottom: 0.5em;">
          <strong>왜 이게 필요한가?</strong> TypeScript가 타입을 확실히 알 수 없을 때, 우리가 도와줘야 합니다. 예를 들어 <code>string | number</code> 타입인 값은 <code>.toUpperCase()</code>도 <code>.toFixed()</code>도 바로 쓸 수 없습니다. 어떤 타입인지 먼저 확인해야 합니다.
        </div>
        <p>넓은 타입(유니온 등)을 조건문을 통해 더 구체적인 타입으로 추론하는 과정</p>
        <pre><code class="typescript" data-trim data-noescape>
function printValue(value: string | number) {
  // 여기서 value는 string | number

  if (typeof value === "string") {
    // 이 블록 안에서 value는 string으로 좁혀짐!
    console.log(value.toUpperCase());   // OK
    console.log(value.padStart(10));    // OK
  } else {
    // 이 블록 안에서 value는 number로 좁혀짐!
    console.log(value.toFixed(2));      // OK
    console.log(value * 100);           // OK
  }
}
        </code></pre>
        <div class="key-point fragment">
          <h3>핵심 원리</h3>
          <p>TypeScript 컴파일러는 <strong>제어 흐름 분석(Control Flow Analysis)</strong>을 통해
          조건문 이후의 타입을 자동으로 좁힙니다. 개발자가 별도의 타입 단언 없이도 안전하게 코드 작성 가능!</p>
        </div>
      </section>

      <!-- Slide 3: typeof Guards -->
      <section data-narration="typeof 연산자는 가장 기본적인 타입 가드입니다. 코드에서 formatInput 함수는 string, number, boolean 유니온을 받아 typeof로 분기합니다. string이면 trim과 toLowerCase를, number이면 toLocaleString을 호출합니다. 단, typeof null은 object를 반환하는 자바스크립트 버그가 있으므로 null 체크 시 별도의 비교가 필요합니다.">
        <h2><code>typeof</code> 타입 가드</h2>
        <p>원시 타입 구별에 가장 기본적인 방법</p>
        <pre><code class="typescript" data-trim data-noescape>
// typeof가 반환하는 값들:
// "string" | "number" | "boolean" | "undefined"
// | "object" | "function" | "bigint" | "symbol"

function formatInput(input: string | number | boolean): string {
  if (typeof input === "string") {
    return input.trim().toLowerCase();    // string
  }
  if (typeof input === "number") {
    return input.toLocaleString("ko-KR"); // number
  }
  return input ? "참" : "거짓";           // boolean
}
        </code></pre>
        <div class="warning fragment">
          <strong>typeof 주의점!</strong>
          <pre><code class="typescript" data-trim data-noescape>
// typeof null === "object" (JavaScript의 역사적 버그!)
function process(value: string | null) {
  if (typeof value === "object") {
    // value는 여전히 null일 수 있음!
    // value.toUpperCase(); // 런타임 (Runtime, 실행 시점) 에러 가능!
  }
  if (value !== null) {
    value.toUpperCase(); // 안전!
  }
}
          </code></pre>
        </div>
      </section>

      <!-- Slide 4: Truthiness Narrowing -->
      <section data-narration="자바스크립트의 참과 거짓 판별을 활용한 좁히기입니다. if문에 값을 직접 넣으면 null, undefined, 빈 문자열 등 falsy 값이 자동으로 제외됩니다. 코드에서 getUserDisplayName 함수는 lastName이 truthy일 때만 성과 이름을 합칩니다. 배열 필터링에서는 타입 서술어를 함께 사용해야 정확한 타입 추론이 가능합니다.">
        <h2>Truthiness (참/거짓) 좁히기</h2>
        <p>falsy 값을 체크하여 타입을 좁히기</p>
        <pre><code class="typescript" data-trim data-noescape>
// JavaScript의 falsy 값들:
// 0, NaN, "" (빈 문자열), null, undefined, 0n (BigInt)

function printLength(str: string | null | undefined) {
  if (str) {
    // null, undefined, "" 모두 제거됨
    console.log(str.length);  // string (빈 문자열 아님)
  }
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: 선택적 값 처리
function getUserDisplayName(
  firstName: string,
  lastName?: string | null
): string {
  if (lastName) {
    return `${firstName} ${lastName}`;
  }
  return firstName;
}

// 배열 필터링에서 활용
const values: (string | null | undefined)[] =
  ["hello", null, "world", undefined, ""];

const filtered = values.filter(Boolean);
// 타입: (string | null | undefined)[]  <-- 아직 좁혀지지 않음

// 타입을 정확히 좁히려면:
const filtered2 = values.filter(
  (v): v is string => v != null && v !== ""
);
// 타입: string[]  <-- 정확!
        </code></pre>
      </section>

      <!-- Slide 5: Equality Narrowing -->
      <section data-narration="동등 연산자를 사용한 비교로도 타입을 좁힐 수 있습니다. 코드에서 compare 함수는 a와 b가 삼중 등호로 같으면 공통 타입인 string으로 좁혀집니다. 이중 등호로 null을 비교하면 undefined도 함께 체크되어 편리합니다. switch문도 각 case에서 리터럴 타입으로 좁히는 동등성 좁히기의 한 형태입니다.">
        <h2>동등성 좁히기 (Equality Narrowing)</h2>
        <p><code>===</code>, <code>!==</code>, <code>==</code>, <code>!=</code>로 타입을 좁히기</p>
        <pre><code class="typescript" data-trim data-noescape>
function compare(a: string | number, b: string | boolean) {
  if (a === b) {
    // a와 b가 같으려면 공통 타입인 string이어야 함!
    a.toUpperCase(); // OK: string
    b.toUpperCase(); // OK: string
  }
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// null / undefined 체크
function processValue(value: string | null | undefined) {
  // == null은 null과 undefined 둘 다 체크!
  if (value == null) {
    return; // value: null | undefined
  }
  // 여기서 value: string
  console.log(value.toUpperCase());
}

// switch문도 동등성 좁히기!
function getLabel(status: "active" | "inactive" | "pending"): string {
  switch (status) {
    case "active":
      return "활성"; // status: "active"
    case "inactive":
      return "비활성"; // status: "inactive"
    case "pending":
      return "대기중"; // status: "pending"
  }
}
        </code></pre>
      </section>

      <!-- Slide 6: The in Operator -->
      <section data-narration="in 연산자는 객체에 특정 속성이 존재하는지 런타임에서 확인합니다. 코드에서 move 함수는 fly 속성이 있으면 Bird로, 없으면 Fish로 좁힙니다. 실전에서는 API 응답의 성공과 실패를 error 속성 존재 여부로 구분하는 패턴이 매우 유용합니다. 공통 메서드인 layEggs는 좁히기 없이 바로 호출할 수 있습니다.">
        <h2>in 연산자</h2>
        <p>객체에 특정 프로퍼티가 있는지 확인하여 타입 좁히기</p>
        <pre><code class="typescript" data-trim data-noescape>
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function move(animal: Bird | Fish) {
  if ("fly" in animal) {
    // animal: Bird
    animal.fly();
  } else {
    // animal: Fish
    animal.swim();
  }

  // 공통 메서드는 좁히기 없이 호출 가능
  animal.layEggs();
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: API 에러 처리
interface SuccessResponse {
  status: "ok";
  data: any;
}

interface ErrorResponse {
  status: "error";
  error: string;
  code: number;
}

function handleResponse(res: SuccessResponse | ErrorResponse) {
  if ("error" in res) {
    // res: ErrorResponse
    console.error(`에러 ${res.code}: ${res.error}`);
  } else {
    // res: SuccessResponse
    console.log("성공:", res.data);
  }
}
        </code></pre>
      </section>

      <!-- Slide 7: instanceof -->
      <section data-narration="instanceof 연산자는 객체가 특정 클래스의 인스턴스인지 확인합니다. 코드에서 handleError 함수는 HttpError이면 statusCode에 접근하고, ValidationError이면 field에 접근합니다. 클래스 기반 에러 처리 패턴에서 핵심적으로 사용되며, Date나 RegExp 같은 내장 클래스에도 동일하게 적용됩니다.">
        <h2><code>instanceof</code> 체크</h2>
        <p>클래스 인스턴스 (Instance, 클래스로 만든 실제 객체) 여부를 판별하여 타입 좁히기</p>
        <pre><code class="typescript" data-trim data-noescape>
class HttpError extends Error {
  constructor(
    public statusCode: number,
    message: string
  ) {
    super(message);
  }
}

class ValidationError extends Error {
  constructor(
    public field: string,
    message: string
  ) {
    super(message);
  }
}

function handleError(error: Error) {
  if (error instanceof HttpError) {
    // error: HttpError
    console.log(`HTTP ${error.statusCode}: ${error.message}`);
  } else if (error instanceof ValidationError) {
    // error: ValidationError
    console.log(`필드 '${error.field}' 검증 실패: ${error.message}`);
  } else {
    // error: Error (일반 에러)
    console.log(`알 수 없는 에러: ${error.message}`);
  }
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Date 활용 예제
function formatDate(value: string | Date): string {
  if (value instanceof Date) {
    return value.toLocaleDateString("ko-KR"); // Date
  }
  return new Date(value).toLocaleDateString("ko-KR"); // string
}
        </code></pre>
      </section>

      <!-- Slide 8: Type Predicates -->
      <section data-narration="타입 서술어는 사용자 정의 타입 가드를 만드는 방법입니다. 함수의 반환 타입에 is 키워드를 사용하면, 해당 함수가 true를 반환할 때 타입이 좁혀집니다. 코드에서 isCat 함수는 meow 속성 존재 여부로 Cat 타입을 판별합니다. 배열 filter와 조합하면 정확한 타입의 배열을 얻을 수 있어 실전에서 매우 유용합니다.">
        <h2>타입 서술어 (Type Predicate)</h2>
        <p><code>is</code> 키워드로 커스텀 타입 가드 함수를 만들기. "이 함수가 true를 반환하면, 이 값은 반드시 이 타입이다"라고 TypeScript에게 알려주는 것입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
interface Cat {
  name: string;
  meow(): void;
}

interface Dog {
  name: string;
  bark(): void;
}

// 반환 타입이 "pet is Cat" - 타입 서술어!
// "이 함수가 true를 반환하면 pet은 Cat 타입이다"
function isCat(pet: Cat | Dog): pet is Cat {
  return "meow" in pet;  // meow 메서드가 있으면 Cat
}

function isDog(pet: Cat | Dog): pet is Dog {
  return "bark" in pet;
}

function interact(pet: Cat | Dog) {
  if (isCat(pet)) {
    pet.meow();  // pet: Cat
  } else {
    pet.bark();  // pet: Dog
  }
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: 배열 필터링에서 타입 좁히기
interface AdminUser { role: "admin"; permissions: string[]; }
interface RegularUser { role: "user"; subscription: string; }
type AppUser = AdminUser | RegularUser;

function isAdmin(user: AppUser): user is AdminUser {
  return user.role === "admin";
}

const users: AppUser[] = [
  { role: "admin", permissions: ["all"] },
  { role: "user", subscription: "free" },
  { role: "admin", permissions: ["read"] },
];

// filter + 타입 서술어 = 정확한 타입의 배열!
const admins: AdminUser[] = users.filter(isAdmin);
// admins 타입이 AdminUser[]로 정확히 추론됨!
        </code></pre>
      </section>

      <!-- Slide 9: Discriminated Unions -->
      <section data-narration="판별 유니온은 공통 리터럴 속성인 판별자로 타입을 구분하는 패턴입니다. 코드에서 Shape 유니온의 각 멤버는 kind라는 고유한 리터럴 값을 가지며, switch문에서 kind로 분기하면 각 블록 안에서 Circle, Rectangle, Triangle로 정확히 좁혀집니다. 이 패턴은 대규모 애플리케이션에서 안전한 분기 처리의 핵심입니다.">
        <h2>판별 유니온 (Discriminated Union)</h2>
        <p>공통 리터럴 프로퍼티(판별자)로 유니온 멤버를 구별하는 강력한 패턴. 각 타입에 "이름표"를 붙여놓고 그 이름표로 구분하는 방식입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 판별자(discriminant, 이름표 역할): kind 프로퍼티
interface Circle {
  kind: "circle";  // 리터럴 타입 = 이 이름표로 구분!
  radius: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Circle | Rectangle | Triangle;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      // shape: Circle
      return Math.PI * shape.radius ** 2;

    case "rectangle":
      // shape: Rectangle
      return shape.width * shape.height;

    case "triangle":
      // shape: Triangle
      return (shape.base * shape.height) / 2;
  }
}
        </code></pre>
      </section>

      <!-- Slide 10: Discriminated Unions - Real World -->
      <section data-narration="판별 유니온은 리덕스 액션 정의나 비동기 상태 관리에서 핵심적으로 사용됩니다. 코드에서 reducer 함수는 action.type으로 분기하여 각 케이스에서 data나 error 같은 고유 속성에 안전하게 접근합니다. AsyncState 제네릭 타입은 로딩, 성공, 에러 상태를 하나의 유니온으로 표현하여 상태 머신 패턴을 구현합니다.">
        <h2>판별 유니온 실전: Redux 액션 / 상태 머신</h2>
        <pre><code class="typescript" data-trim data-noescape>
// Redux 스타일 액션: type이 판별자(이름표) 역할
type Action =
  | { type: "FETCH_START" }                    // 데이터 가져오기 시작
  | { type: "FETCH_SUCCESS"; data: any[] }     // 성공: data 포함
  | { type: "FETCH_ERROR"; error: string }     // 실패: error 포함
  | { type: "RESET" };                         // 초기화

interface State {
  loading: boolean;
  data: any[];
  error: string | null;
}

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "FETCH_START":
      return { ...state, loading: true, error: null };

    case "FETCH_SUCCESS":
      return { loading: false, data: action.data, error: null };

    case "FETCH_ERROR":
      return { loading: false, data: [], error: action.error };

    case "RESET":
      return { loading: false, data: [], error: null };
  }
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 비동기 상태 표현 (로딩/성공/에러를 하나의 타입으로)
type AsyncState&lt;T&gt; =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string };

function renderUser(state: AsyncState&lt;User&gt;) {
  switch (state.status) {
    case "idle":    return "대기 중...";
    case "loading": return "로딩 중...";
    case "success": return `이름: ${state.data.name}`;  // data 접근 가능!
    case "error":   return `오류: ${state.error}`;      // error 접근 가능!
  }
}
        </code></pre>
      </section>

      <!-- Slide 11: Exhaustive Checking with never -->
      <section data-narration="완전성 검사는 모든 가능한 경우를 빠짐없이 처리했는지 확인하는 기법입니다. 코드에서 switch문의 default에 never 타입 변수를 할당하면, 모든 케이스가 처리되었을 때만 컴파일이 성공합니다. 새로운 Pentagon 타입을 추가하면 해당 케이스를 처리하지 않은 곳에서 컴파일 에러가 발생하여 누락을 즉시 발견할 수 있습니다.">
        <h2>완전성 검사 (Exhaustive Checking)</h2>
        <p><code>never</code> 타입으로 모든 경우를 처리했는지 컴파일 타임 (Compile Time, 코드 변환 시점)에 검증</p>
        <pre><code class="typescript" data-trim data-noescape>
type Shape = Circle | Rectangle | Triangle;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "rectangle":
      return shape.width * shape.height;
    case "triangle":
      return (shape.base * shape.height) / 2;
    default:
      // 모든 케이스를 처리했다면 여기 도달할 수 없음
      // shape는 never 타입(존재할 수 없는 타입)이 됨
      const _exhaustive: never = shape;
      return _exhaustive;
  }
}
        </code></pre>
        <div class="fragment">
          <pre><code class="typescript" data-trim data-noescape>
// 새 타입을 추가하면?
interface Pentagon {
  kind: "pentagon";
  sideLength: number;
}

type Shape = Circle | Rectangle | Triangle | Pentagon;
// 이제 default에서 컴파일 에러 발생!
// Type 'Pentagon' is not assignable to type 'never'
// -> Pentagon 케이스를 추가하라는 알림!
          </code></pre>
        </div>
        <div class="key-point fragment">
          <h3>왜 유용한가?</h3>
          <p>유니온 타입에 새 멤버를 추가할 때, <strong>처리하지 않은 곳을 컴파일러가 자동으로 찾아줍니다.</strong>
          대규모 코드베이스에서 누락을 방지하는 핵심 패턴!</p>
        </div>
      </section>

      <!-- Slide 12: Assertion Functions -->
      <section data-narration="단언 함수는 조건이 거짓이면 에러를 던지고, 참이면 이후 코드에서 타입을 좁히는 함수입니다. 코드에서 assertIsString은 값이 문자열이 아니면 예외를 발생시키고, 통과하면 이후 코드에서 string 타입으로 좁혀집니다. assertNotNull 제네릭 함수는 설정값 검증처럼 null 체크가 필요한 실전 상황에서 매우 유용합니다.">
        <h2>단언 함수 (Assertion Functions)</h2>
        <p>조건이 거짓이면 에러를 던지고, 참이면 타입을 좁힘</p>
        <pre><code class="typescript" data-trim data-noescape>
// asserts 키워드: "이 함수가 에러 없이 반환되면 조건이 참이다"
// 조건이 거짓이면 에러를 던져서 프로그램을 멈춤
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error(`Expected string, got ${typeof value}`);
  }
  // 에러가 안 났다면 value는 string이 확실!
}

function processInput(input: unknown) {
  assertIsString(input);   // 여기서 에러가 안 나면...
  // 이 줄에 도달했다면 input은 반드시 string!
  console.log(input.toUpperCase()); // OK: string으로 좁혀짐
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전: null 체크 단언
function assertNotNull&lt;T&gt;(
  value: T | null | undefined,
  message?: string
): asserts value is T {
  if (value == null) {
    throw new Error(message ?? "Value must not be null or undefined");
  }
}

interface Config {
  apiKey?: string;
  dbUrl?: string;
}

function initApp(config: Config) {
  assertNotNull(config.apiKey, "API 키가 필요합니다");
  assertNotNull(config.dbUrl, "DB URL이 필요합니다");

  // 여기서 apiKey와 dbUrl은 반드시 string!
  connectDB(config.dbUrl);     // OK: string
  setupAPI(config.apiKey);     // OK: string
}
        </code></pre>
      </section>

      <!-- Slide 13: Control Flow Analysis -->
      <section data-narration="타입스크립트는 코드의 제어 흐름을 분석하여 자동으로 타입을 좁힙니다. 코드에서 early return으로 null을 제거하면 이후 블록에서는 string 또는 number만 남고, typeof로 string을 제거하면 number만 남습니다. 변수에 값을 할당하면 해당 시점부터 할당된 타입으로 좁혀지며, 논리 연산자와 nullish coalescing도 타입 좁히기에 활용됩니다.">
        <h2>제어 흐름 분석 (Control Flow Analysis)</h2>
        <p>TypeScript가 코드 흐름을 추적하여 자동으로 타입을 좁히는 과정</p>
        <pre><code class="typescript" data-trim data-noescape>
function example(value: string | number | null) {
  // value: string | number | null

  if (value === null) {
    return; // 여기서 함수 종료 (early return)
  }
  // value: string | number (null 제거됨)

  if (typeof value === "string") {
    value; // string
    return;
  }
  // value: number (string도 제거됨)

  value; // number
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 할당에 의한 좁히기
function process() {
  let value: string | number;

  value = "hello";
  value.toUpperCase(); // OK: string으로 좁혀짐

  value = 42;
  value.toFixed();     // OK: number로 좁혀짐
}

// 논리 연산자와 좁히기
function greet(name: string | null) {
  // OR 연산자: null이면 기본값
  const displayName = name || "익명";
  // displayName: string

  // Nullish coalescing: null/undefined만 체크
  const safeName = name ?? "익명";
  // safeName: string
}
        </code></pre>
      </section>

      <!-- Slide 14: Narrowing Techniques Summary -->
      <section data-narration="타입 좁히기의 모든 기법을 정리해 보겠습니다. typeof는 원시 타입, instanceof는 클래스 인스턴스, in은 객체 속성 존재 여부에 사용합니다. 타입 서술어는 커스텀 로직에, 판별 유니온은 태그 기반 분기에 적합합니다. 상황에 맞는 기법을 선택하는 것이 중요하며, 여러 기법을 조합하면 더욱 강력한 타입 안전성을 확보할 수 있습니다.">
        <h2>타입 좁히기 기법 총정리</h2>
        <table class="compare-table" style="font-size: 0.7em;">
          <thead>
            <tr>
              <th>기법</th>
              <th>사용 대상</th>
              <th>예시</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fragment">
              <td><code>typeof</code></td>
              <td>원시 타입</td>
              <td><code>typeof x === "string"</code></td>
            </tr>
            <tr class="fragment">
              <td><code>instanceof</code></td>
              <td>클래스 인스턴스</td>
              <td><code>x instanceof Date</code></td>
            </tr>
            <tr class="fragment">
              <td><code>in</code></td>
              <td>객체 프로퍼티 존재</td>
              <td><code>"fly" in animal</code></td>
            </tr>
            <tr class="fragment">
              <td>동등성</td>
              <td>리터럴 / null 비교</td>
              <td><code>x === null</code></td>
            </tr>
            <tr class="fragment">
              <td>Truthiness</td>
              <td>falsy 값 제거</td>
              <td><code>if (x) { ... }</code></td>
            </tr>
            <tr class="fragment">
              <td>타입 서술어</td>
              <td>커스텀 타입 가드</td>
              <td><code>x is Cat</code></td>
            </tr>
            <tr class="fragment">
              <td>판별 유니온</td>
              <td>태그 기반 유니온</td>
              <td><code>switch (x.kind)</code></td>
            </tr>
            <tr class="fragment">
              <td>단언 함수</td>
              <td>에러 던지며 좁히기</td>
              <td><code>asserts x is T</code></td>
            </tr>
            <tr class="fragment">
              <td><code>never</code></td>
              <td>완전성 검사</td>
              <td><code>const _: never = x</code></td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 15: Summary -->
      <section data-narration="챕터 7을 마치겠습니다. 가장 중요한 포인트는 판별 유니온과 완전성 검사 조합으로, 이것만 잘 활용해도 대부분의 타입 안전성 문제를 해결할 수 있습니다. 실전에서는 상황에 맞는 타입 가드를 선택하고 여러 기법을 조합하세요. 다음 챕터에서는 조건부 타입과 매핑된 타입 등 고급 타입 시스템을 학습합니다.">
        <h2>Chapter 7 요약</h2>
        <div class="key-point">
          <h3>핵심 정리</h3>
          <ul>
            <li class="fragment"><strong>타입 좁히기</strong>: 넓은 타입을 조건문으로 좁혀 안전하게 사용</li>
            <li class="fragment"><strong>typeof / instanceof / in</strong>: 내장 타입 가드</li>
            <li class="fragment"><strong>타입 서술어 (is)</strong>: 커스텀 타입 가드로 복잡한 조건 처리</li>
            <li class="fragment"><strong>판별 유니온</strong>: 공통 리터럴 프로퍼티로 안전한 분기 처리</li>
            <li class="fragment"><strong>never + 완전성 검사</strong>: 모든 케이스 처리를 컴파일 타임에 보장</li>
            <li class="fragment"><strong>단언 함수</strong>: 실패 시 에러, 성공 시 타입 좁히기</li>
            <li class="fragment"><strong>제어 흐름 분석</strong>: TypeScript가 코드 경로를 추적하여 자동 추론</li>
          </ul>
        </div>
        <br>
        <p class="fragment">
          <a href="06-generics.html" style="color: #888; font-size: 0.8em;">
            &larr; 이전: Chapter 6 - 제네릭
          </a>
          &nbsp;&nbsp;|&nbsp;&nbsp;
          <a href="08-advanced-types.html" style="color: var(--ts-blue);">
            다음 챕터: Chapter 8 - 고급 타입 &rarr;
          </a>
        </p>
      </section>

    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
