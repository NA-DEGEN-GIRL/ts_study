<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Chapter 6: 제네릭 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-narration="챕터 6, 제네릭입니다. 이 챕터에서는 타입을 매개변수처럼 다루는 제네릭 함수, 인터페이스, 클래스를 학습하고, 제약 조건으로 허용 범위를 제한하는 방법과 Partial, Pick 같은 유틸리티 타입의 내부 원리를 살펴봅니다. 제네릭은 타입 안전성과 코드 재사용성을 동시에 확보하는 핵심 도구입니다. 라이브러리 설계, API 클라이언트, 상태 관리 등 실전에서 반드시 필요합니다.">
        <div class="chapter-number">Chapter 6</div>
        <h1>제네릭 (Generic)</h1>
        <p class="subtitle">타입을 매개변수로 만드는 마법</p>
        <br>
        <p style="font-size:0.6em; color:#888;">
          <span class="badge badge-blue">Generic Functions</span>
          <span class="badge badge-green">Constraints</span>
          <span class="badge badge-orange">Utility Types</span>
        </p>
      </section>

      <!-- Slide 2: Why Generics? -->
      <section data-narration="제네릭 없이는 모든 타입마다 같은 함수를 반복 작성하거나 any를 사용해야 합니다. identityNumber, identityString처럼 타입마다 함수를 만드는 것은 비효율적이고, any를 사용하면 타입 정보가 사라져 toFixed 같은 잘못된 호출을 막지 못합니다. 제네릭 함수 identity는 꺾쇠 T 안에 타입 매개변수를 선언하여, 호출할 때 전달된 값에 따라 T가 string이나 number로 자동 결정됩니다. 이를 통해 하나의 함수로 모든 타입을 처리하면서도 타입 안전성을 완벽하게 유지할 수 있습니다.">
        <h2>왜 제네릭이 필요한가?</h2>
        <div class="tip" style="margin-bottom: 0.5em;">
          제네릭은 <strong>내용물을 모르는 상자</strong>와 같습니다. 상자에 "사과"를 넣으면 사과 상자가 되고, "책"을 넣으면 책 상자가 됩니다. 마찬가지로 제네릭은 나중에 어떤 타입이 들어올지 미리 정하지 않고, 사용할 때 결정합니다.
        </div>
        <p>타입 안전성과 재사용성을 동시에 확보</p>
        <div class="two-columns">
          <div>
            <h3>문제 상황</h3>
            <pre><code class="typescript" data-trim data-noescape>
// 방법 1: 각 타입마다 함수를 만든다?
function identityNumber(arg: number): number {
  return arg;
}
function identityString(arg: string): string {
  return arg;
}
// ... 타입마다 계속 만들어야 함

// 방법 2: any를 사용한다?
function identityAny(arg: any): any {
  return arg;
}
// 타입 안전성이 사라짐!
const result = identityAny("hello");
result.toFixed(); // 런타임 (Runtime, 실행 시점) 에러!
            </code></pre>
          </div>
          <div class="fragment">
            <h3>제네릭으로 해결!</h3>
            <pre><code class="typescript" data-trim data-noescape>
// &lt;T&gt;는 "타입 매개변수" - 상자에 붙이는 라벨!
function identity&lt;T&gt;(arg: T): T {
  return arg;
}

// 타입 추론: TypeScript가 자동으로 T를 알아냄
const str = identity("hello");
// str: string (T가 string으로 결정됨)

const num = identity(42);
// num: number (T가 number로 결정됨)

// 명시적으로 타입을 지정할 수도 있음
const bool = identity&lt;boolean&gt;(true);
// bool: boolean

// 타입 안전성 보장!
str.toUpperCase(); // OK
num.toFixed();     // OK
            </code></pre>
          </div>
        </div>
      </section>

      <!-- Slide 3: Generic Mental Model (NEW) -->
      <section data-narration="제네릭에서 T가 어떻게 흘러가는지 단계별로 추적해 봅시다. identity 함수를 string 타입으로 호출하면, 먼저 T가 string으로 결정됩니다. 그러면 매개변수 arg의 타입이 string이 되고, 반환 타입도 string이 됩니다. 따라서 결과 변수 result의 타입이 string으로 확정됩니다. wrap 함수처럼 T가 number로 결정되면, 매개변수와 반환 객체의 value 속성 모두 number가 됩니다. 이처럼 T는 함수 정의 전체에 걸쳐 일관되게 하나의 타입으로 치환되어 흘러간다고 이해하면 됩니다. 이 멘탈 모델을 가지면 복잡한 제네릭도 쉽게 읽을 수 있습니다.">
        <h2>제네릭 멘탈 모델 - T가 흐르는 과정</h2>
        <div class="key-point">
          <h3>핵심 원리</h3>
          <p>제네릭의 T는 호출 시점에 <strong>하나의 구체적 타입으로 치환</strong>되어, 함수 전체에 일관되게 흘러갑니다.</p>
        </div>
        <pre><code class="typescript" data-trim data-noescape>
// 1단계: 제네릭 함수 정의 - T는 아직 미정
function identity&lt;T&gt;(arg: T): T {
  return arg;
}

// 2단계: 호출 시 T가 결정됨
const result = identity&lt;string&gt;("hello");
//                      ^^^^^^
// T = string으로 결정!

// 3단계: T가 string으로 치환되어 흐름
// identity&lt;string&gt;(arg: string): string
//                       ^^^^^^   ^^^^^^
// 매개변수 타입 = string, 반환 타입 = string

// 4단계: 결과 타입 확정
// result: string  →  toUpperCase() 호출 가능!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 또 다른 예: T = number로 흐르는 과정
function wrap&lt;T&gt;(value: T): { value: T } {
  return { value };
}

const wrapped = wrap(42);
// T = number  →  매개변수: number  →  반환: { value: number }
// wrapped.value는 number 타입!
        </code></pre>
      </section>

      <!-- Slide 4: Generic Functions -->
      <section data-narration="제네릭 함수는 꺾쇠괄호 안에 타입 매개변수를 선언하고, 호출 시점에 실제 타입이 결정됩니다. pair 함수는 T와 U 두 개의 타입 매개변수를 사용하여, 서로 다른 타입의 값 두 개를 튜플로 묶어 반환합니다. firstElement 함수는 T 타입 배열에서 첫 번째 요소를 반환하며, 배열이 비어있을 수 있으므로 T 또는 undefined를 반환합니다. map 함수는 Input과 Output 두 타입 매개변수로 배열 변환의 입력과 출력 타입을 각각 지정합니다. 관례적으로 T는 Type, K는 Key, V는 Value, E는 Element를 나타냅니다.">
        <h2>제네릭 함수</h2>
        <p><code>&lt;T&gt;</code>는 타입 변수 - 호출 시 실제 타입으로 치환됩니다</p>
        <pre><code class="typescript" data-trim data-noescape>
// 다중 타입 매개변수
function pair&lt;T, U&gt;(first: T, second: U): [T, U] {
  return [first, second];
}

const p1 = pair("이름", 30);        // [string, number]
const p2 = pair(true, [1, 2, 3]);   // [boolean, number[]]
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 배열 관련 유틸리티
function firstElement&lt;T&gt;(arr: T[]): T | undefined {
  return arr[0];
}

function map&lt;Input, Output&gt;(
  arr: Input[],
  fn: (item: Input) => Output
): Output[] {
  return arr.map(fn);
}

const names = firstElement(["Alice", "Bob"]);  // string | undefined
const lengths = map(["hello", "world"], s => s.length); // number[]
        </code></pre>
        <div class="tip fragment">
          관례: <code>T</code>(Type), <code>U</code>(Second type), <code>K</code>(Key), <code>V</code>(Value), <code>E</code>(Element)
        </div>
      </section>

      <!-- Slide 5: Generic Interfaces -->
      <section data-narration="인터페이스에도 제네릭을 적용하여 범용적인 구조를 정의할 수 있습니다. ApiResponse 제네릭 인터페이스는 success, data, error, timestamp 속성을 가지며, data의 타입만 T로 매개변수화되어 있습니다. 따라서 ApiResponse에 User를 전달하면 data가 User 타입이 되고, Product 배열을 전달하면 data가 Product 배열이 됩니다. 이처럼 공통 구조는 유지하면서 내부 데이터 타입만 바꿀 수 있어, API 응답 래퍼나 컬렉션 인터페이스를 설계할 때 코드 중복 없이 다양한 타입에 대응할 수 있습니다.">
        <h2>제네릭 인터페이스 (Interface)</h2>
        <pre><code class="typescript" data-trim data-noescape>
// API 응답을 위한 제네릭 인터페이스: 데이터 타입만 바뀌는 공통 구조
interface ApiResponse&lt;T&gt; {
  success: boolean;
  data: T;
  error?: string;
  timestamp: number;
}

interface User {
  id: number;
  name: string;
  email: string;
}

interface Product {
  id: number;
  title: string;
  price: number;
}

// 같은 구조, 다른 데이터 타입!
const userResponse: ApiResponse&lt;User&gt; = {
  success: true,
  data: { id: 1, name: "홍길동", email: "hong@mail.com" },
  timestamp: Date.now()
};

const productResponse: ApiResponse&lt;Product[]&gt; = {
  success: true,
  data: [
    { id: 1, title: "TypeScript 책", price: 35000 },
    { id: 2, title: "React 책", price: 30000 }
  ],
  timestamp: Date.now()
};
        </code></pre>
      </section>

      <!-- Slide 6: Generic Interfaces - Repository Pattern -->
      <section data-narration="레포지토리 패턴은 데이터 접근 로직을 추상화하는 디자인 패턴으로, 제네릭 인터페이스로 정의하면 어떤 엔티티 타입에도 재사용할 수 있습니다. Repository 인터페이스는 T와 ID 두 타입 매개변수를 받아 findById, findAll, create, update, delete 메서드를 정의합니다. UserRepository 클래스는 이를 User 타입으로 구현하여, 모든 메서드의 매개변수와 반환 타입이 User에 맞게 자동 결정됩니다. 같은 인터페이스로 ProductRepository, PostRepository 등을 만들 수 있어, 데이터 접근 계층을 일관성 있게 설계할 수 있습니다.">
        <h2>제네릭 인터페이스 실전: Repository 패턴</h2>
        <pre><code class="typescript" data-trim data-noescape>
interface Repository&lt;T, ID = number&gt; {
  findById(id: ID): Promise&lt;T | null&gt;;
  findAll(): Promise&lt;T[]&gt;;
  create(item: Omit&lt;T, "id"&gt;): Promise&lt;T&gt;;
  update(id: ID, item: Partial&lt;T&gt;): Promise&lt;T&gt;;
  delete(id: ID): Promise&lt;boolean&gt;;
}

interface User {
  id: number;
  name: string;
  email: string;
}

class UserRepository implements Repository&lt;User&gt; {
  private users: User[] = [];

  async findById(id: number): Promise&lt;User | null&gt; {
    return this.users.find(u => u.id === id) || null;
  }

  async findAll(): Promise&lt;User[]&gt; {
    return [...this.users];
  }

  async create(item: Omit&lt;User, "id"&gt;): Promise&lt;User&gt; {
    const user = { ...item, id: this.users.length + 1 };
    this.users.push(user);
    return user;
  }

  async update(id: number, item: Partial&lt;User&gt;): Promise&lt;User&gt; {
    const index = this.users.findIndex(u => u.id === id);
    this.users[index] = { ...this.users[index], ...item };
    return this.users[index];
  }

  async delete(id: number): Promise&lt;boolean&gt; {
    this.users = this.users.filter(u => u.id !== id);
    return true;
  }
}
        </code></pre>
      </section>

      <!-- Slide 7: Generic Classes -->
      <section data-narration="클래스에도 제네릭을 적용하여 어떤 타입에도 사용할 수 있는 자료 구조를 만들 수 있습니다. Stack 제네릭 클래스는 T 타입의 배열로 데이터를 저장하며, push는 T 타입 아이템을 추가하고, pop은 T 타입 또는 undefined를 반환합니다. numberStack을 number 타입으로 생성하면 숫자만 push할 수 있고 문자열을 넣으면 에러가 발생합니다. stringStack을 string 타입으로 생성하면 문자열 전용 스택이 됩니다. 이처럼 하나의 클래스 정의로 타입별 안전한 자료 구조를 만들어 코드 중복을 제거합니다.">
        <h2>제네릭 클래스</h2>
        <pre><code class="typescript" data-trim data-noescape>
// Stack&lt;T&gt;: T에 어떤 타입이든 넣을 수 있는 스택(쌓기) 자료구조
class Stack&lt;T&gt; {
  private items: T[] = [];  // T 타입의 배열로 데이터 저장

  push(item: T): void {     // 맨 위에 추가
    this.items.push(item);
  }

  pop(): T | undefined {    // 맨 위에서 꺼내기
    return this.items.pop();
  }

  peek(): T | undefined {   // 맨 위 확인 (꺼내지 않음)
    return this.items[this.items.length - 1];
  }

  get size(): number {       // 현재 저장된 개수
    return this.items.length;
  }

  isEmpty(): boolean {       // 비어있는지 확인
    return this.items.length === 0;
  }

  toArray(): T[] {           // 배열로 변환
    return [...this.items];
  }
}

// 타입별로 안전한 스택
const numberStack = new Stack&lt;number&gt;();
numberStack.push(1);
numberStack.push(2);
// numberStack.push("3"); // Error! number만 가능

const stringStack = new Stack&lt;string&gt;();
stringStack.push("hello");
const top = stringStack.peek(); // string | undefined
        </code></pre>
      </section>

      <!-- Slide 8: Generic Constraints -->
      <section data-narration="extends 키워드를 사용하면 제네릭 타입 매개변수에 제약 조건을 걸어, 특정 조건을 만족하는 타입만 허용할 수 있습니다. logLength 함수에서 T extends HasLength는 T가 반드시 length 속성을 가져야 한다는 뜻입니다. 따라서 string과 배열은 length가 있으므로 허용되지만, number는 length가 없어 에러가 발생합니다. getProperty 함수에서 K extends keyof T는 K가 T 객체의 키 중 하나여야 한다는 제약으로, 존재하지 않는 키를 전달하면 컴파일 시점에 차단됩니다. 이처럼 제약 조건으로 타입 안전성을 한층 강화할 수 있습니다.">
        <h2>제네릭 제약 조건 (Constraint)</h2>
        <p><code>extends</code> (확장/제한 키워드)로 타입 매개변수를 제한합니다. "이 타입은 최소한 이런 조건을 만족해야 한다"는 뜻입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// 문제: T가 어떤 타입인지 모르니 .length에 접근 불가
// function logLength&lt;T&gt;(arg: T): void {
//   console.log(arg.length); // Error: T에 length가 없을 수 있음
// }

// 해결: 제약조건으로 length가 있는 타입만 허용
interface HasLength {
  length: number;
}

function logLength&lt;T extends HasLength&gt;(arg: T): T {
  console.log(`길이: ${arg.length}`);
  return arg;
}

logLength("hello");        // OK: string에 length 있음
logLength([1, 2, 3]);      // OK: 배열에 length 있음
logLength({ length: 10 }); // OK: length 프로퍼티 있음
// logLength(123);          // Error: number에 length 없음
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// keyof: 객체 타입의 모든 키(프로퍼티 이름)를 유니온 타입으로 추출
// K extends keyof T = "K는 T의 키 중 하나여야 한다"
function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "홍길동", age: 30, email: "hong@mail.com" };
const name = getProperty(user, "name");   // string
const age = getProperty(user, "age");     // number
// getProperty(user, "phone");            // Error: "phone"은 keyof User가 아님
        </code></pre>
      </section>

      <!-- Slide 9: Common Constraint Patterns (NEW) -->
      <section data-narration="실무에서 자주 사용하는 제네릭 제약 조건 패턴들을 모아서 살펴봅시다. T extends string은 문자열 관련 타입만 허용하여 포맷 함수에 적합합니다. T extends object는 원시 타입을 제외한 객체만 받아 키 목록을 반환합니다. T extends 중괄호 id number 형태는 id 속성이 있는 객체만 허용하여 엔티티를 다루는 함수에 유용합니다. T extends 함수 시그니처 형태는 함수 타입만 받아 실행 시간을 측정하는 래퍼를 만들 수 있습니다. 이 네 가지 패턴을 숙지하면 대부분의 실전 상황에서 적절한 제약 조건을 설정할 수 있습니다.">
        <h2>자주 쓰는 제약 조건 패턴 모음</h2>
        <div class="tip" style="margin-bottom: 0.5em;">
          <strong>실전 패턴:</strong> 제약 조건은 "T가 최소한 무엇이어야 하는지"를 명시하여 타입 안전성을 높입니다.
        </div>
        <pre><code class="typescript" data-trim data-noescape>
// 패턴 1: T extends string - 문자열 관련 타입만 허용
function formatLabel&lt;T extends string&gt;(label: T): `[${T}]` {
  return `[${label}]` as `[${T}]`;
}
const tag = formatLabel("error"); // "[error]" (리터럴 타입!)

// 패턴 2: T extends object - 객체 타입만 허용 (원시 타입 제외)
function getKeys&lt;T extends object&gt;(obj: T): (keyof T)[] {
  return Object.keys(obj) as (keyof T)[];
}
getKeys({ name: "Kim", age: 30 }); // ("name" | "age")[]
// getKeys("hello");  // Error! string은 object가 아님

// 패턴 3: T extends { id: number } - 특정 속성을 가진 객체만 허용
function findById&lt;T extends { id: number }&gt;(items: T[], id: number): T | undefined {
  return items.find(item => item.id === id);
}

// 패턴 4: T extends (...args: any[]) => any - 함수 타입만 허용
function measureTime&lt;T extends (...args: any[]) => any&gt;(fn: T): T {
  return ((...args: any[]) => {
    const start = performance.now();
    const result = fn(...args);
    console.log(`실행 시간: ${performance.now() - start}ms`);
    return result;
  }) as T;
}
        </code></pre>
      </section>

      <!-- Slide 10: Type Parameters in Constraints -->
      <section data-narration="제네릭 제약 조건에서 다른 타입 매개변수를 참조하여 타입 간의 관계를 표현할 수 있습니다. pick 함수에서 K extends keyof T는 K가 T 객체의 키 중 하나여야 한다는 제약으로, 존재하지 않는 키를 전달하면 컴파일 에러가 발생합니다. user 객체에서 id, name, email만 안전하게 추출할 수 있고, phone 같은 없는 키를 시도하면 차단됩니다. assign 함수에서 U extends Partial T는 source가 target의 부분 집합이어야 한다는 제약으로, 엉뚱한 속성을 덮어쓰는 실수를 방지합니다. 이처럼 타입 매개변수 간 관계를 제약하면 더욱 정교한 타입 안전성을 확보합니다.">
        <h2>제약조건에서 타입 매개변수 사용</h2>
        <p>하나의 타입 매개변수를 다른 타입 매개변수의 제약에 활용</p>
        <pre><code class="typescript" data-trim data-noescape>
// K는 T의 키 중 하나여야 함
function pick&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): Pick&lt;T, K&gt; {
  const result = {} as Pick&lt;T, K&gt;;
  keys.forEach(key => {
    result[key] = obj[key];
  });
  return result;
}

const user = {
  id: 1,
  name: "홍길동",
  email: "hong@mail.com",
  password: "secret123"
};

// 안전하게 필요한 필드만 추출
const publicUser = pick(user, ["id", "name", "email"]);
// 타입: Pick&lt;typeof user, "id" | "name" | "email"&gt;
// { id: number; name: string; email: string }

// pick(user, ["phone"]); // Error: "phone"은 유효한 키가 아님
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 값 할당 시 타입 안전성
function assign&lt;T extends object, U extends Partial&lt;T&gt;&gt;(
  target: T,
  source: U
): T & U {
  return { ...target, ...source };
}

const updated = assign(
  { name: "홍길동", age: 30 },
  { age: 31 }  // OK: Partial&lt;T&gt;에 해당
);
// assign({ name: "홍길동" }, { foo: "bar" }); // Error!
        </code></pre>
      </section>

      <!-- Slide 11: Utility Types - Partial, Required, Readonly -->
      <section data-narration="Partial 유틸리티 타입은 모든 속성을 선택적으로 만들어 업데이트 함수에서 일부 필드만 전달할 수 있게 합니다. Required는 반대로 모든 선택적 속성을 필수로 변환하여, age처럼 물음표가 붙은 속성도 반드시 제공해야 합니다. Readonly는 모든 속성에 readonly를 추가하여 한 번 생성된 후 변경을 차단합니다. 이 세 가지 유틸리티 타입은 내부적으로 매핑된 타입과 제네릭을 조합하여 구현되어 있으며, 기존 인터페이스를 새로 정의하지 않고도 다양한 변형을 만들 수 있어 실무에서 가장 빈번하게 사용됩니다.">
        <h2>유틸리티 타입 (1): Partial, Required, Readonly</h2>
        <pre><code class="typescript" data-trim data-noescape>
interface User {
  id: number;
  name: string;
  email: string;
  age?: number;
}
        </code></pre>
        <div class="two-columns">
          <div class="fragment">
            <h3>Partial&lt;T&gt;</h3>
            <pre><code class="typescript" data-trim data-noescape>
// 모든 프로퍼티를 선택적으로
type PartialUser = Partial&lt;User&gt;;
// {
//   id?: number;
//   name?: string;
//   email?: string;
//   age?: number;
// }

// 업데이트 함수에 유용
function updateUser(
  id: number,
  updates: Partial&lt;User&gt;
) {
  // 일부 필드만 업데이트
}

updateUser(1, { name: "새이름" }); // OK!
            </code></pre>
          </div>
          <div class="fragment">
            <h3>Required&lt;T&gt; / Readonly&lt;T&gt;</h3>
            <pre><code class="typescript" data-trim data-noescape>
// 모든 프로퍼티를 필수로
type RequiredUser = Required&lt;User&gt;;
// age도 필수가 됨!

// 모든 프로퍼티를 읽기전용으로
type FrozenUser = Readonly&lt;User&gt;;
// {
//   readonly id: number;
//   readonly name: string;
//   readonly email: string;
//   readonly age?: number;
// }

const user: FrozenUser = {
  id: 1, name: "홍길동",
  email: "hong@mail.com"
};
// user.name = "변경"; // Error!
            </code></pre>
          </div>
        </div>
      </section>

      <!-- Slide 12: Utility Types - Record, Pick, Omit -->
      <section data-narration="Record 유틸리티 타입은 키 타입과 값 타입을 지정하여 사전 형태의 객체를 만듭니다. Roles 유니온의 각 값이 키가 되고 문자열 배열이 값이 되어, admin, editor, viewer 세 키가 반드시 존재해야 합니다. Pick은 기존 타입에서 원하는 속성만 골라 새 타입을 만들고, Omit은 특정 속성을 제외합니다. 이 코드에서 UserProfile은 id, name, email만 선택하고, UserWithoutPassword는 password만 제외합니다. 실전에서는 이들을 조합하여 CreateUserDTO처럼 생성 요청 타입, UpdateUserDTO처럼 수정 요청 타입을 효율적으로 정의합니다.">
        <h2>유틸리티 타입 (2): Record, Pick, Omit</h2>
        <pre><code class="typescript" data-trim data-noescape>
interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  role: "admin" | "user";
}
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Record&lt;K, V&gt;: 키 타입 K, 값 타입 V인 객체
type Roles = "admin" | "editor" | "viewer";
type RolePermissions = Record&lt;Roles, string[]&gt;;

const permissions: RolePermissions = {
  admin: ["read", "write", "delete"],
  editor: ["read", "write"],
  viewer: ["read"]
};
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// Pick&lt;T, K&gt;: T에서 K 프로퍼티만 선택
type UserProfile = Pick&lt;User, "id" | "name" | "email"&gt;;
// { id: number; name: string; email: string }

// Omit&lt;T, K&gt;: T에서 K 프로퍼티만 제외
type UserWithoutPassword = Omit&lt;User, "password"&gt;;
// { id: number; name: string; email: string; role: ... }

// 조합 활용: 생성 시 id 제외 + password 필수
type CreateUserDTO = Omit&lt;User, "id"&gt;;
type UpdateUserDTO = Partial&lt;Omit&lt;User, "id" | "password"&gt;&gt;;
        </code></pre>
      </section>

      <!-- Slide 13: Conditional Types with Generics -->
      <section data-narration="조건부 타입은 삼항 연산자처럼 T extends U 형태로 조건을 검사하여 참이면 X, 거짓이면 Y 타입을 반환합니다. IsString 타입은 T가 string에 해당하면 yes, 아니면 no를 반환합니다. 실전에서는 API 엔드포인트에 따라 반환 타입을 자동 결정하는 패턴이 매우 유용합니다. ResponseType 조건부 타입은 users이면 User 배열, posts이면 Post 배열, comments이면 Comment 배열을 반환합니다. fetchData 함수에 이를 적용하면, 엔드포인트 문자열만으로 반환 타입이 자동 결정되어 타입 캐스팅 없이 안전한 API 호출이 가능합니다.">
        <h2>조건부 타입 (Conditional Type)과 제네릭</h2>
        <p>삼항 연산자처럼 동작하는 타입 레벨(타입을 다루는 차원의) 조건문</p>
        <pre><code class="typescript" data-trim data-noescape>
// 기본 형태: T extends U ? X : Y
// "T가 U에 해당하면 X, 아니면 Y" (if-else와 비슷!)
type IsString&lt;T&gt; = T extends string ? "yes" : "no";

type A = IsString&lt;string&gt;;    // "yes"
type B = IsString&lt;number&gt;;    // "no"
type C = IsString&lt;"hello"&gt;;   // "yes"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 실전 활용: 응답 타입 결정
type ApiEndpoint = "users" | "posts" | "comments";

interface User { id: number; name: string; }
interface Post { id: number; title: string; }
interface Comment { id: number; body: string; }

type ResponseType&lt;T extends ApiEndpoint&gt; =
  T extends "users" ? User[] :
  T extends "posts" ? Post[] :
  T extends "comments" ? Comment[] :
  never;

// 엔드포인트에 따라 반환 타입이 자동 결정!
async function fetchData&lt;T extends ApiEndpoint&gt;(
  endpoint: T
): Promise&lt;ResponseType&lt;T&gt;&gt; {
  const response = await fetch(`/api/${endpoint}`);
  return response.json();
}

const users = await fetchData("users");     // User[]
const posts = await fetchData("posts");     // Post[]
        </code></pre>
      </section>

      <!-- Slide 14: keyof and typeof with Generics -->
      <section data-narration="keyof 연산자는 객체 타입의 모든 키를 문자열 리터럴 유니온 타입으로 추출합니다. Config 인터페이스에 keyof를 적용하면 host, port, debug 세 키의 유니온이 됩니다. typeof 연산자는 실제 자바스크립트 값에서 타입 정보를 추출하여, defaultConfig 객체의 구조를 타입으로 가져옵니다. as const와 함께 사용하면 리터럴 타입까지 보존됩니다. keyof와 typeof를 제네릭과 조합하면, getConfigValue 함수처럼 유효한 키만 매개변수로 받고 해당 키의 정확한 값 타입을 반환하는 완벽한 타입 안전 함수를 만들 수 있습니다.">
        <h2><code>keyof</code>와 <code>typeof</code> 활용</h2>
        <pre><code class="typescript" data-trim data-noescape>
// keyof (키 추출 연산자): 객체 타입의 모든 키를 유니온으로 추출
interface Config {
  host: string;
  port: number;
  debug: boolean;
}

type ConfigKey = keyof Config; // "host" | "port" | "debug"
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// typeof (타입 추출 연산자): 실제 값에서 타입 정보를 추출
const defaultConfig = {
  host: "localhost",
  port: 3000,
  debug: false
} as const;

type ConfigType = typeof defaultConfig;
// { readonly host: "localhost"; readonly port: 3000; readonly debug: false }
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// keyof + typeof + 제네릭 조합
function getConfigValue&lt;K extends keyof typeof defaultConfig&gt;(
  key: K
): typeof defaultConfig[K] {
  return defaultConfig[key];
}

const host = getConfigValue("host");   // "localhost" (리터럴 타입!)
const port = getConfigValue("port");   // 3000
// getConfigValue("unknown");          // Error!
        </code></pre>
      </section>

      <!-- Slide 15: Mapped Types -->
      <section data-narration="매핑된 타입은 기존 타입의 각 속성을 순회하면서 변환하는 타입으로, in keyof 문법을 사용합니다. MyPartial은 T의 각 키 K에 대해 물음표를 붙여 선택적으로 만들고, MyReadonly는 readonly를 추가하고, MyRequired는 마이너스 물음표로 선택적 표시를 제거하여 필수로 만듭니다. 이것이 Partial, Readonly, Required 유틸리티 타입의 실제 내부 구현 원리입니다. 커스텀 매핑으로 Nullable은 각 속성에 null을 추가하고, Async는 각 속성을 Promise로 감싸는 새로운 변환을 만듭니다. 매핑된 타입을 이해하면 유틸리티 타입을 직접 설계할 수 있습니다.">
        <h2>매핑된 타입 (Mapped Type) 기초</h2>
        <p>기존 타입을 변환하여 새 타입을 생성합니다. "기존 타입의 각 프로퍼티에 대해 이런 변환을 적용하라"는 뜻입니다.</p>
        <pre><code class="typescript" data-trim data-noescape>
// Partial의 내부 구현 원리
// [K in keyof T] = "T의 각 키 K에 대해"
// ?: 선택적으로 만듦, T[K]: 원래 타입 유지
type MyPartial&lt;T&gt; = {
  [K in keyof T]?: T[K];
};

// Readonly의 내부 구현 원리
type MyReadonly&lt;T&gt; = {
  readonly [K in keyof T]: T[K];  // 각 키에 readonly 추가
};

// Required의 내부 구현 원리
type MyRequired&lt;T&gt; = {
  [K in keyof T]-?: T[K];  // -?로 선택적(?) 표시를 제거 = 필수로 만듦
};
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 커스텀 매핑: 모든 프로퍼티를 nullable로
type Nullable&lt;T&gt; = {
  [K in keyof T]: T[K] | null;
};

interface User {
  name: string;
  age: number;
}

type NullableUser = Nullable&lt;User&gt;;
// { name: string | null; age: number | null }

// 모든 프로퍼티를 Promise로 감싸기
type Async&lt;T&gt; = {
  [K in keyof T]: Promise&lt;T[K]&gt;;
};

type AsyncUser = Async&lt;User&gt;;
// { name: Promise&lt;string&gt;; age: Promise&lt;number&gt; }
        </code></pre>
      </section>

      <!-- Slide 16: Utility Types Overview Table -->
      <section data-narration="타입스크립트가 기본 제공하는 주요 유틸리티 타입을 한눈에 정리합니다. Partial은 모든 속성을 선택적으로, Required는 필수로, Readonly는 읽기 전용으로 변환합니다. Record는 키와 값 타입으로 객체를 정의하고, Pick은 특정 속성만 선택하고, Omit은 특정 속성을 제외합니다. Extract는 유니온에서 특정 타입만 추출하고, Exclude는 특정 타입을 제거합니다. NonNullable은 null과 undefined를 제거하고, ReturnType은 함수의 반환 타입을 추출합니다. 목적에 맞는 유틸리티 타입을 선택하면 타입 정의가 크게 간결해집니다.">
        <h2>유틸리티 타입 한눈에 보기</h2>
        <table class="compare-table" style="font-size: 0.7em;">
          <thead>
            <tr>
              <th>유틸리티 타입</th>
              <th>설명</th>
              <th>사용 예</th>
            </tr>
          </thead>
          <tbody>
            <tr class="fragment">
              <td><code>Partial&lt;T&gt;</code></td>
              <td>모든 프로퍼티 선택적</td>
              <td>업데이트 DTO</td>
            </tr>
            <tr class="fragment">
              <td><code>Required&lt;T&gt;</code></td>
              <td>모든 프로퍼티 필수</td>
              <td>완전한 설정 객체 보장</td>
            </tr>
            <tr class="fragment">
              <td><code>Readonly&lt;T&gt;</code></td>
              <td>모든 프로퍼티 읽기전용</td>
              <td>불변 상태 관리</td>
            </tr>
            <tr class="fragment">
              <td><code>Record&lt;K, V&gt;</code></td>
              <td>K를 키, V를 값으로</td>
              <td>맵/사전 객체 정의</td>
            </tr>
            <tr class="fragment">
              <td><code>Pick&lt;T, K&gt;</code></td>
              <td>T에서 K만 선택</td>
              <td>공개 API 응답 필터링</td>
            </tr>
            <tr class="fragment">
              <td><code>Omit&lt;T, K&gt;</code></td>
              <td>T에서 K 제외</td>
              <td>비밀번호 제거 등</td>
            </tr>
            <tr class="fragment">
              <td><code>Extract&lt;T, U&gt;</code></td>
              <td>T에서 U에 할당 가능한 것만</td>
              <td>유니온 필터링</td>
            </tr>
            <tr class="fragment">
              <td><code>Exclude&lt;T, U&gt;</code></td>
              <td>T에서 U에 할당 가능한 것 제외</td>
              <td>유니온에서 제거</td>
            </tr>
            <tr class="fragment">
              <td><code>NonNullable&lt;T&gt;</code></td>
              <td>null, undefined 제거</td>
              <td>안전한 값 보장</td>
            </tr>
            <tr class="fragment">
              <td><code>ReturnType&lt;T&gt;</code></td>
              <td>함수 반환 타입 추출</td>
              <td>함수 결과 타입 재사용</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 17: Real-World Generic API Wrapper -->
      <section data-narration="제네릭을 활용한 API 클라이언트 실전 예제입니다. ApiClient 클래스의 request 메서드는 T 타입 매개변수로 응답 데이터 타입을 지정하여, ApiResponse 제네릭 인터페이스로 감싼 결과를 반환합니다. get 메서드는 T 타입을 그대로 전달하고, getList는 PaginatedData 제네릭으로 페이지네이션 구조를 추가합니다. post 메서드는 T와 B 두 타입 매개변수로 반환 타입과 요청 본문 타입을 각각 지정합니다. 사용할 때 User 타입을 전달하면 반환값이 User로 확정되어, 별도의 타입 캐스팅 없이 완벽한 타입 추론이 이루어집니다.">
        <h2>실전 예제: 제네릭 API 클라이언트</h2>
        <pre><code class="typescript" data-trim data-noescape>
interface ApiResponse&lt;T&gt; {
  data: T;
  status: number;
  message: string;
}

interface PaginatedData&lt;T&gt; {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  hasNext: boolean;
}

class ApiClient {
  constructor(private baseUrl: string) {}

  private async request&lt;T&gt;(
    endpoint: string,
    options?: RequestInit
  ): Promise&lt;ApiResponse&lt;T&gt;&gt; {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      headers: { "Content-Type": "application/json" },
      ...options,
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    return response.json();
  }

  async get&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {
    const result = await this.request&lt;T&gt;(endpoint);
    return result.data;
  }

  async getList&lt;T&gt;(
    endpoint: string,
    page = 1
  ): Promise&lt;PaginatedData&lt;T&gt;&gt; {
    return this.get&lt;PaginatedData&lt;T&gt;&gt;(
      `${endpoint}?page=${page}`
    );
  }

  async post&lt;T, B&gt;(endpoint: string, body: B): Promise&lt;T&gt; {
    const result = await this.request&lt;T&gt;(endpoint, {
      method: "POST",
      body: JSON.stringify(body),
    });
    return result.data;
  }
}

// 사용 - 완벽한 타입 추론!
const api = new ApiClient("https://api.example.com");

interface User { id: number; name: string; }
interface CreateUserDTO { name: string; email: string; }

const user = await api.get&lt;User&gt;("/users/1");         // User
const users = await api.getList&lt;User&gt;("/users");       // PaginatedData&lt;User&gt;
const newUser = await api.post&lt;User, CreateUserDTO&gt;(
  "/users", { name: "홍길동", email: "hong@mail.com" }
);  // User
        </code></pre>
      </section>

      <!-- Slide 18: Generic with Default Types -->
      <section data-narration="제네릭에도 기본 타입을 지정하여 타입 인수를 생략할 수 있게 만들 수 있습니다. EventEmitter 인터페이스는 Events 타입 매개변수에 Record string any를 기본값으로 지정하여, 타입 인수 없이 사용하면 모든 문자열 이벤트를 허용합니다. AppEvents 인터페이스를 전달하면 login, logout, error 등 정의된 이벤트만 허용되고, 각 이벤트의 데이터 타입도 정확히 추론됩니다. login 이벤트의 핸들러에서 data.userId는 string, data.timestamp는 number로 자동 타입이 결정됩니다. 이처럼 기본값을 활용하면 간단한 사용은 편리하게, 정밀한 사용은 타입 안전하게 설계할 수 있습니다.">
        <h2>제네릭 기본값 (Default Types)</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 타입 매개변수에 기본값 지정
interface EventEmitter&lt;Events extends Record&lt;string, any&gt; = Record&lt;string, any&gt;&gt; {
  on&lt;K extends keyof Events&gt;(event: K, handler: (data: Events[K]) => void): void;
  emit&lt;K extends keyof Events&gt;(event: K, data: Events[K]): void;
}

// 이벤트 맵 정의
interface AppEvents {
  login: { userId: string; timestamp: number };
  logout: { userId: string };
  error: { message: string; code: number };
}

// 타입 안전한 이벤트!
declare const emitter: EventEmitter&lt;AppEvents&gt;;

emitter.on("login", (data) => {
  console.log(data.userId);     // OK: string
  console.log(data.timestamp);  // OK: number
});

emitter.emit("error", {
  message: "서버 오류",
  code: 500
});

// emitter.emit("login", { foo: "bar" }); // Error!
        </code></pre>
        <div class="tip fragment">
          기본값이 있으면 타입 인자를 생략해도 동작합니다:<br>
          <code>EventEmitter</code> = <code>EventEmitter&lt;Record&lt;string, any&gt;&gt;</code>
        </div>
      </section>

      <!-- Slide 19: Common Patterns -->
      <section data-narration="실전에서 자주 사용되는 제네릭 패턴 세 가지를 살펴봅시다. 첫째, typedKeys 함수는 Object.keys의 반환 타입을 제네릭으로 강화하여 keyof T 배열을 반환합니다. 둘째, useState 함수는 초기값의 타입 T를 기반으로 getter와 setter를 반환하는 상태 관리 훅 패턴으로, setName에 숫자를 전달하면 에러가 발생합니다. 셋째, createArray 팩토리 함수는 길이와 값을 받아 T 타입 배열을 생성하여, 0을 전달하면 number 배열, hello를 전달하면 string 배열이 됩니다. 이러한 패턴을 익히면 라이브러리 수준의 재사용 가능한 코드를 작성할 수 있습니다.">
        <h2>자주 쓰는 제네릭 패턴</h2>
        <pre><code class="typescript" data-trim data-noescape>
// 1. 타입 안전한 Object.keys
function typedKeys&lt;T extends object&gt;(obj: T): (keyof T)[] {
  return Object.keys(obj) as (keyof T)[];
}

const user = { name: "홍길동", age: 30 };
const keys = typedKeys(user); // ("name" | "age")[]
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 2. 제네릭 상태 관리 훅
function useState&lt;T&gt;(initial: T): [() => T, (newValue: T) => void] {
  let value = initial;
  return [
    () => value,
    (newValue: T) => { value = newValue; }
  ];
}

const [getName, setName] = useState("홍길동");
setName("김철수");
// setName(123); // Error: string만 가능!
        </code></pre>
        <pre class="fragment"><code class="typescript" data-trim data-noescape>
// 3. 제네릭 팩토리
function createArray&lt;T&gt;(length: number, value: T): T[] {
  return Array.from({ length }, () => value);
}

const zeros = createArray(5, 0);          // number[]
const hellos = createArray(3, "hello");   // string[]
        </code></pre>
      </section>

      <!-- Slide 20: Summary -->
      <section data-narration="챕터 6을 마치겠습니다. 가장 중요한 포인트는 제네릭으로 타입을 매개변수화하여 재사용성과 안전성을 동시에 확보하는 것과, extends 제약 조건으로 허용 범위를 정밀하게 제어하는 것입니다. 유틸리티 타입의 내부 원리인 매핑된 타입을 이해하면 직접 커스텀 타입도 설계할 수 있습니다. 다음 챕터에서는 타입 좁히기를 학습하여, 유니온 타입에서 조건 분기로 정확한 타입을 추론하는 기법을 다룹니다.">
        <h2>Chapter 6 요약</h2>
        <div class="key-point">
          <h3>핵심 정리</h3>
          <ul>
            <li class="fragment"><strong>제네릭</strong>: 타입을 매개변수화하여 재사용성과 타입 안전성 확보</li>
            <li class="fragment"><strong>제약 조건</strong>: <code>T extends U</code>로 허용 범위 제한</li>
            <li class="fragment"><strong>제네릭 인터페이스/클래스</strong>: 다양한 타입에 대응하는 구조 설계</li>
            <li class="fragment"><strong>유틸리티 타입</strong>: Partial, Pick, Omit, Record 등 내장 제네릭</li>
            <li class="fragment"><strong>조건부 타입</strong>: 타입 레벨(타입을 다루는 차원)의 if-else 분기</li>
            <li class="fragment"><strong>매핑된 타입</strong>: 기존 타입 변환으로 새 타입 생성</li>
            <li class="fragment"><strong>keyof / typeof</strong>: 타입 정보 추출의 핵심 도구</li>
          </ul>
        </div>
        <br>
        <p class="fragment">
          <a href="05-classes.html" style="color: #888; font-size: 0.8em;">
            &larr; 이전: Chapter 5 - 클래스
          </a>
          &nbsp;&nbsp;|&nbsp;&nbsp;
          <a href="07-type-narrowing.html" style="color: var(--ts-blue);">
            다음 챕터: Chapter 7 - 타입 좁히기 &rarr;
          </a>
        </p>
      </section>

    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
