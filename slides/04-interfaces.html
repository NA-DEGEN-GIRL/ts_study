<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chapter 4: 인터페이스 &amp; 타입 별칭 - TypeScript 완전 정복</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/night.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/monokai.min.css">
  <link rel="stylesheet" href="css/custom.css">
  <link rel="stylesheet" href="css/narration.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

      <!-- Slide 1: Title -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 4, 인터페이스와 타입 별칭입니다. 이 챕터에서는 객체의 구조를 정의하는 인터페이스, 유연한 타입 조합을 위한 타입 별칭, 그리고 Partial과 Pick 같은 유틸리티 타입을 학습합니다. 복잡한 애플리케이션에서 타입을 체계적으로 관리하는 것은 유지보수의 핵심입니다. 실무에서 API 요청과 응답 타입을 설계할 때 반드시 필요한 내용입니다.">
        <span class="chapter-number">Chapter 04</span>
        <h1>인터페이스 (Interface) &amp; 타입 별칭 (Type Alias)</h1>
        <p class="subtitle">복잡한 타입 (Type) 구조를 우아하게 정의하는 방법</p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.6em;">&#8592; 목차로 돌아가기</a></p>
      </section>

      <!-- Slide 2: Interface Basics -->
      <section data-transition="slide" data-narration="인터페이스는 객체의 구조를 정의하는 계약서와 같습니다. 이 코드에서 User 인터페이스는 name, age, email 세 가지 속성을 문자열과 숫자 타입으로 지정하고 있습니다. 인터페이스에 맞는 객체를 생성할 때는 모든 속성을 빠짐없이 포함해야 하며, 속성이 누락되거나 정의되지 않은 속성을 추가하면 컴파일 에러가 발생합니다. 이를 통해 객체의 형태를 강제하여 런타임 오류를 미리 방지할 수 있습니다.">
        <h2>인터페이스 기초</h2>
        <div class="key-point">
          <h3>핵심 개념</h3>
          <p>인터페이스는 <strong>객체의 구조(shape)</strong>를 정의합니다.<br>
          어떤 프로퍼티 (Property, 속성)가 어떤 타입을 가져야 하는지 계약(contract)을 만듭니다.</p>
          <p style="font-size: 0.85em;">인터페이스는 계약서와 같습니다 - "이 객체는 반드시 이런 형태를 가져야 해"라고 정의하는 것입니다.</p>
        </div>
        <pre><code class="language-typescript">// 인터페이스 정의: "User는 이런 형태여야 한다"
interface User {
  name: string;   // 이름은 문자열
  age: number;    // 나이는 숫자
  email: string;  // 이메일은 문자열
}

// 인터페이스에 맞는 객체 생성 (모든 속성을 빠짐없이 포함해야 함)
const user: User = {
  name: "홍길동",
  age: 25,
  email: "hong@example.com"
};

// 속성 누락 -> 에러
const bad: User = {
  name: "김철수"
  // Error! age, email이 빠짐
};

// 없는 속성 추가 -> 에러
const also_bad: User = {
  name: "이영희",
  age: 30,
  email: "lee@example.com",
  phone: "010-1234"  // Error! phone은 User에 없음
};</code></pre>
      </section>

      <!-- Slide 3: Interface vs Inline Object Type (NEW) -->
      <section data-transition="slide" data-narration="인터페이스와 인라인 객체 타입의 차이를 비교해 봅시다. 인터페이스는 이름을 붙여 재사용할 수 있는 독립적인 타입 정의이고, 인라인 객체 타입은 함수 매개변수 등에서 즉석으로 구조를 명시하는 방식입니다. 코드에서 보듯이 greetWithInterface는 미리 정의된 User 인터페이스를 사용하고, greetInline은 매개변수 위치에서 직접 구조를 기술합니다. 여러 곳에서 같은 구조를 쓰면 인터페이스로 분리하고, 한 번만 쓰는 간단한 구조는 인라인으로 작성하는 것이 일반적인 규칙입니다.">
        <h2>인터페이스 vs 인라인 객체 타입</h2>
        <div class="tip" style="margin-bottom: 0.5em;">
          <strong>언제 어떤 것을 사용할까?</strong> 재사용이 필요하면 인터페이스, 일회성이면 인라인 객체 타입을 사용합니다.
        </div>
        <pre><code class="language-typescript">// 방법 1: 인터페이스로 이름 붙여 정의 (재사용 가능)
interface User {
  name: string;
  age: number;
}

function greetWithInterface(user: User): string {
  return `안녕하세요, ${user.name}님!`;
}

// 방법 2: 인라인 객체 타입 (즉석 정의, 일회성)
function greetInline(user: { name: string; age: number }): string {
  return `안녕하세요, ${user.name}님!`;
}

// 두 함수 모두 같은 객체를 받을 수 있음
const person = { name: "홍길동", age: 25 };
greetWithInterface(person); // OK
greetInline(person);        // OK

// 인터페이스의 장점: 여러 곳에서 재사용
function isAdult(user: User): boolean {
  return user.age >= 18;
}

function formatUser(user: User): string {
  return `${user.name} (${user.age}세)`;
}
// User 인터페이스 하나로 여러 함수에서 활용!</code></pre>
      </section>

      <!-- Slide 4: Optional Properties -->
      <section data-transition="slide" data-narration="속성 이름 뒤에 물음표를 붙이면 선택적 속성이 됩니다. 이 코드에서 email과 nickname은 물음표가 붙어 있어서 생략해도 에러가 나지 않습니다. user1처럼 name과 age만으로 객체를 만들 수 있고, user2처럼 email을 추가해도 됩니다. 선택적 속성에 접근할 때는 undefined일 수 있으므로, if문이나 옵셔널 체이닝으로 안전하게 처리해야 합니다. 실무에서 API 응답처럼 일부 필드가 없을 수 있는 데이터를 모델링할 때 필수적입니다.">
        <h2>선택적 속성 (Optional Property)</h2>
        <pre><code class="language-typescript">// ? 를 붙이면 선택적 속성
interface User {
  name: string;
  age: number;
  email?: string;      // 선택적
  nickname?: string;   // 선택적
}

// email과 nickname 생략 가능
const user1: User = { name: "Kim", age: 25 };
const user2: User = { name: "Lee", age: 30, email: "lee@test.com" };

// 선택적 속성 접근 시 undefined 가능성 처리
function sendEmail(user: User): void {
  if (user.email) {
    // 이 블록에서 user.email은 string
    console.log(`메일 발송: ${user.email}`);
  } else {
    console.log("이메일이 없습니다.");
  }

  // 옵셔널 체이닝
  const domain = user.email?.split("@")[1];  // string | undefined
}</code></pre>
      </section>

      <!-- Slide 5: Readonly Properties -->
      <section data-transition="slide" data-narration="readonly 키워드를 속성 앞에 붙이면 한 번 초기화된 후에는 값을 변경할 수 없습니다. 이 코드에서 Config 인터페이스의 host, port, database는 모두 readonly이므로 객체 생성 시에만 값을 할당할 수 있고 이후 수정하면 컴파일 에러가 발생합니다. Point 인터페이스의 movePoint 함수처럼 원본을 수정하는 대신 새 객체를 반환하는 불변 패턴에 유용합니다. 설정값이나 ID처럼 절대 변하면 안 되는 데이터를 보호할 때 실무에서 자주 사용합니다.">
        <h2>읽기 전용 속성 (Readonly)</h2>
        <pre><code class="language-typescript">// readonly로 변경 불가 속성 만들기
interface Config {
  readonly host: string;
  readonly port: number;
  readonly database: string;
}

const config: Config = {
  host: "localhost",
  port: 5432,
  database: "mydb"
};

config.port = 3000;  // Error! readonly 속성은 수정 불가

// 객체 생성 시에만 값 할당 가능
const newConfig: Config = {
  host: "production.server.com",
  port: 5432,
  database: "prod_db"
};

// 실전 활용: 불변 데이터 모델
interface Point {
  readonly x: number;
  readonly y: number;
}

function movePoint(point: Point, dx: number, dy: number): Point {
  // 원본 수정 대신 새 객체 반환
  return { x: point.x + dx, y: point.y + dy };
}</code></pre>
      </section>

      <!-- Slide 6: Index Signatures -->
      <section data-transition="slide" data-narration="인덱스 시그니처는 동적인 키를 가진 객체의 타입을 정의하는 방법입니다. 대괄호 안에 키의 타입을 지정하고 콜론 뒤에 값의 타입을 정의합니다. Dictionary 인터페이스는 어떤 문자열 키든 문자열 값을 가진다고 선언하여, translations 객체에 원하는 만큼 키-값 쌍을 추가할 수 있습니다. ApiResponse처럼 고정 속성과 인덱스 시그니처를 함께 사용하면, status와 message는 타입이 보장되면서 나머지 동적 속성도 허용하는 유연한 구조를 만들 수 있습니다.">
        <h2>인덱스 시그니처 (Index Signature)</h2>
        <p>동적 속성 이름을 가진 객체 타입을 정의합니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">속성 이름을 미리 알 수 없을 때, "어떤 이름이든 이 타입의 값을 가진다"고 정의하는 방법입니다.</span></p>
        <pre><code class="language-typescript">// 문자열 키에 대한 인덱스 시그니처: [키이름: 키타입]: 값타입
interface Dictionary {
  [key: string]: string; // 어떤 문자열 키든, 값은 문자열
}

const translations: Dictionary = {
  hello: "안녕하세요",
  goodbye: "안녕히 가세요",
  thanks: "감사합니다"
};

translations["welcome"] = "환영합니다"; // OK

// 숫자 키 인덱스 시그니처
interface NumberList {
  [index: number]: string;
}

const fruits: NumberList = ["사과", "바나나", "체리"];

// 고정 속성 + 인덱스 시그니처 혼합
interface ApiResponse {
  status: number;             // 고정 속성
  message: string;            // 고정 속성
  [key: string]: unknown;     // 나머지 동적 속성
}

const response: ApiResponse = {
  status: 200,
  message: "OK",
  data: { users: [] },       // OK - unknown 타입
  timestamp: 1700000000       // OK - unknown 타입
};</code></pre>
      </section>

      <!-- Slide 7: Extending Interfaces -->
      <section data-transition="slide" data-narration="extends 키워드를 사용하면 기존 인터페이스의 속성을 물려받아 새로운 인터페이스를 만들 수 있습니다. 이 코드에서 Dog 인터페이스는 Animal을 확장하여 name과 age를 상속받고, breed와 bark 메서드를 추가로 정의합니다. 따라서 myDog 객체는 Animal의 속성과 Dog만의 속성을 모두 가져야 합니다. 여러 인터페이스를 동시에 확장하는 다중 확장도 가능하여, 복잡한 도메인 모델을 단계적으로 구성할 때 매우 유용합니다.">
        <h2>인터페이스 확장 (extends)</h2>
        <pre><code class="language-typescript">// 기본 인터페이스 (부모 역할)
interface Animal {
  name: string;  // 동물 이름
  age: number;   // 동물 나이
}

// 확장: Animal의 속성을 물려받고 + 새 속성 추가
interface Dog extends Animal {
  breed: string;   // 견종 (Dog만의 속성)
  bark(): void;    // 짖기 메서드 (Method, 객체에 속한 함수)
}

interface Cat extends Animal {
  indoor: boolean;
  meow(): void;
}

const myDog: Dog = {
  name: "멍멍이",
  age: 3,
  breed: "골든리트리버",
  bark() { console.log("왈왈!"); }
};

// 다중 확장
interface ServiceDog extends Dog {
  certificationId: string;
  task: "guide" | "therapy" | "search";
}

// 여러 인터페이스 동시 확장
interface Pet extends Animal, Dog {
  owner: string;
}</code></pre>
      </section>

      <!-- Slide 8: Multi-Level Inheritance Pattern (NEW) -->
      <section data-transition="slide" data-narration="다단계 상속 패턴은 실무에서 엔티티 시스템을 설계할 때 자주 사용됩니다. 이 코드에서 BaseEntity는 모든 엔티티가 공통으로 가지는 id, createdAt, updatedAt을 정의합니다. User는 BaseEntity를 확장하여 email과 name을 추가하고, AdminUser는 User를 다시 확장하여 permissions 배열과 department를 추가합니다. 이처럼 단계적으로 확장하면 공통 속성을 중복 없이 관리할 수 있고, 각 단계에서 필요한 속성만 추가하여 체계적인 타입 계층을 구성할 수 있습니다.">
        <h2>다단계 상속 패턴 실전 예시</h2>
        <div class="tip" style="margin-bottom: 0.5em;">
          <strong>실전 패턴:</strong> BaseEntity에서 시작하여 도메인별로 단계적으로 확장하면, 공통 속성 중복 없이 체계적인 타입 계층을 구성할 수 있습니다.
        </div>
        <pre><code class="language-typescript">// 1단계: 모든 엔티티의 공통 속성
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

// 2단계: 사용자 기본 정보 (BaseEntity 확장)
interface User extends BaseEntity {
  email: string;
  name: string;
  role: "user" | "admin";
}

// 3단계: 관리자 전용 정보 (User 확장)
interface AdminUser extends User {
  role: "admin";              // 리터럴 타입으로 고정
  permissions: string[];      // 권한 목록
  department: string;         // 소속 부서
}

// AdminUser는 BaseEntity + User + AdminUser의 모든 속성을 가짐
const admin: AdminUser = {
  id: "admin-001",
  createdAt: new Date(),
  updatedAt: new Date(),
  email: "admin@company.com",
  name: "관리자",
  role: "admin",
  permissions: ["read", "write", "delete", "manage"],
  department: "IT팀"
};</code></pre>
      </section>

      <!-- Slide 9: Interface for Functions and Classes -->
      <section data-transition="slide" data-narration="인터페이스는 객체뿐 아니라 함수의 호출 시그니처나 클래스의 구현 규약을 정의하는 데에도 사용됩니다. SearchFunction 인터페이스는 문자열 두 개를 받아 불리언을 반환하는 함수의 형태를 정의하고, Counter는 호출 가능하면서 속성과 메서드도 가진 하이브리드 타입입니다. implements 키워드를 사용하면 Document 클래스가 Printable과 Loggable 두 인터페이스의 계약을 반드시 이행하도록 강제하여, print와 log 메서드를 구현하지 않으면 컴파일 에러가 발생합니다.">
        <h2>인터페이스: 함수와 클래스</h2>
        <pre><code class="language-typescript">// 함수 타입 인터페이스
interface SearchFunction {
  (source: string, query: string): boolean;
}

const search: SearchFunction = (source, query) => {
  return source.includes(query);
};

// 호출 시그니처 + 속성 (하이브리드 타입)
interface Counter {
  (start: number): void;    // 호출 가능
  count: number;             // 속성도 가짐
  reset(): void;             // 메서드도 가짐
}

// 클래스에서 인터페이스 구현 (implements: "이 계약을 지키겠다")
interface Printable {
  print(): string;    // 출력 기능을 반드시 구현해야 함
}

interface Loggable {
  log(level: string): void;  // 로그 기능을 반드시 구현해야 함
}

// 두 인터페이스를 모두 구현하는 클래스
class Document implements Printable, Loggable {
  constructor(private content: string) {} // 인스턴스 (Instance) 생성 시 내용 전달

  print(): string {
    return this.content;
  }

  log(level: string): void {
    console.log(`[${level}] ${this.content}`);
  }
}</code></pre>
      </section>

      <!-- Slide 10: Type Aliases -->
      <section data-transition="slide" data-narration="타입 별칭은 type 키워드로 기존 타입에 새로운 이름을 붙이는 것입니다. 이 코드에서 ID는 문자열 또는 숫자의 유니온 타입이고, Coordinate는 숫자 두 개의 튜플, Formatter는 숫자를 문자열로 변환하는 함수 타입입니다. 인터페이스와 달리 유니온, 튜플, 원시 타입 등 어떤 타입이든 별칭을 만들 수 있습니다. 복합 타입 User처럼 여러 별칭을 조합하면 복잡한 구조도 읽기 쉽게 표현할 수 있어, 코드의 가독성과 유지보수성이 크게 향상됩니다.">
        <h2>타입 별칭 (Type Alias)</h2>
        <p style="font-size: 0.85em; color: #aaa;">타입 별칭이란 복잡한 타입에 짧은 이름을 붙여주는 것입니다. <code>type</code> 키워드를 사용합니다.</p>
        <pre><code class="language-typescript">// 객체 타입 별칭: type 이름 = { ... }
type Point = {
  x: number;
  y: number;
};

// 원시 타입 별칭 (간단한 타입에 의미 있는 이름 부여)
type ID = string | number;        // ID는 문자열이거나 숫자
type Name = string;                // Name은 문자열

// 튜플 (Tuple) 타입 별칭
type Coordinate = [number, number]; // 좌표는 숫자 2개의 쌍

// 함수 타입 별칭
type Formatter = (value: number) => string; // 숫자를 문자열로 변환하는 함수

// 유니온 (Union) 타입 별칭
type Status = "active" | "inactive" | "pending"; // 3가지 중 하나
type Theme = "light" | "dark";

// 복합 타입 별칭
type User = {
  id: ID;
  name: Name;
  status: Status;
  location: Coordinate;
  format: Formatter;
};

const user: User = {
  id: "user-001",
  name: "Kim",
  status: "active",
  location: [37.5665, 126.978],
  format: (v) => v.toFixed(2)
};</code></pre>
      </section>

      <!-- Slide 11: Interface vs Type -->
      <section data-transition="slide" data-narration="인터페이스와 타입 별칭의 핵심 차이를 비교합니다. 인터페이스는 같은 이름으로 여러 번 선언하면 자동 병합되지만 타입 별칭은 재선언이 불가합니다. 반면 타입 별칭은 유니온, 교차, 원시 타입, 튜플, 매핑 타입을 표현할 수 있어 더 다양한 상황에 대응합니다. 일반적으로 객체 구조를 정의할 때는 interface를 사용하고, 유니온이나 교차 같은 복합 타입을 만들 때는 type을 사용하는 것이 권장됩니다. 다만 팀의 컨벤션을 따르는 것이 가장 중요합니다.">
        <h2>Interface vs Type 비교</h2>
        <table class="compare-table">
          <thead>
            <tr>
              <th>기능</th>
              <th>interface</th>
              <th>type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>객체 구조 정의</td>
              <td style="color: var(--ts-green);">O</td>
              <td style="color: var(--ts-green);">O</td>
            </tr>
            <tr>
              <td>extends (확장)</td>
              <td style="color: var(--ts-green);">O (extends)</td>
              <td style="color: var(--ts-green);">O (&amp; 교차)</td>
            </tr>
            <tr>
              <td>implements (구현)</td>
              <td style="color: var(--ts-green);">O</td>
              <td style="color: var(--ts-green);">O</td>
            </tr>
            <tr>
              <td>선언 병합</td>
              <td style="color: var(--ts-green);">O (자동 병합)</td>
              <td style="color: var(--ts-red);">X</td>
            </tr>
            <tr>
              <td>유니온/교차 타입</td>
              <td style="color: var(--ts-red);">X</td>
              <td style="color: var(--ts-green);">O</td>
            </tr>
            <tr>
              <td>원시 타입 별칭</td>
              <td style="color: var(--ts-red);">X</td>
              <td style="color: var(--ts-green);">O</td>
            </tr>
            <tr>
              <td>튜플/매핑 타입</td>
              <td style="color: var(--ts-red);">X</td>
              <td style="color: var(--ts-green);">O</td>
            </tr>
          </tbody>
        </table>
        <div class="fragment tip" style="margin-top: 15px;">
          <strong>일반 규칙:</strong> 객체 구조 정의 &rarr; <code>interface</code>,
          유니온/교차/원시 &rarr; <code>type</code>. 팀 컨벤션을 따르세요.
        </div>
      </section>

      <!-- Slide 12: Declaration Merging -->
      <section data-transition="slide" data-narration="선언 병합은 인터페이스만의 고유한 기능으로, 같은 이름의 인터페이스를 여러 번 선언하면 자동으로 합쳐집니다. 이 코드에서 Window 인터페이스를 두 번 선언하면 title과 appVersion 속성이 하나의 인터페이스로 병합됩니다. 실전에서는 Express의 Request 객체에 사용자 정보를 추가하는 것처럼, 외부 라이브러리의 타입을 확장할 때 매우 유용합니다. 반면 type 별칭은 같은 이름으로 재선언하면 에러가 발생하므로 병합이 불가능합니다.">
        <h2>선언 병합 (Declaration Merging)</h2>
        <p>interface만의 고유 기능: 같은 이름으로 여러 번 선언하면 자동으로 합쳐집니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">마치 문서에 내용을 추가하듯, 기존 인터페이스에 새 속성을 덧붙일 수 있습니다.</span></p>
        <pre><code class="language-typescript">// 선언 1
interface Window {
  title: string;
}

// 선언 2 - 자동으로 병합됨!
interface Window {
  appVersion: string;
}

// 결과: Window = { title: string; appVersion: string; }

// 실전 활용: 라이브러리 타입 확장
// express의 Request 객체에 사용자 정보 추가
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        role: string;
      };
    }
  }
}

// 이제 req.user를 타입 안전하게 사용 가능
// app.get("/", (req) => { req.user?.id; });</code></pre>

        <div class="warning">
          <strong>주의:</strong> <code>type</code>은 같은 이름으로 재선언하면 에러가 발생합니다.
          <code>type</code>은 병합이 불가능합니다.
        </div>
      </section>

      <!-- Slide 13: Union Types with Type Aliases -->
      <section data-transition="slide" data-narration="유니온 타입을 타입 별칭과 함께 사용하면 여러 가능한 타입을 하나의 이름으로 관리할 수 있습니다. HttpMethod처럼 문자열 리터럴 유니온은 허용되는 값을 나열하고, Shape처럼 서로 다른 구조의 객체를 유니온으로 묶으면 kind 속성으로 분기하여 각각의 타입에 안전하게 접근할 수 있습니다. Result 제네릭 타입은 success 값에 따라 data 또는 error를 가지는 패턴으로, API 호출 결과를 모델링할 때 실전에서 매우 자주 사용됩니다.">
        <h2>유니온 타입과 타입 별칭</h2>
        <pre><code class="language-typescript">// 문자열 리터럴 (Literal) 유니온: 허용되는 값을 나열
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
type StatusCode = 200 | 201 | 400 | 401 | 403 | 404 | 500;

// 타입 유니온: 서로 다른 구조의 객체
type Shape =
  | { kind: "circle"; radius: number }
  | { kind: "square"; side: number }
  | { kind: "rectangle"; width: number; height: number };

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.side ** 2;
    case "rectangle":
      return shape.width * shape.height;
  }
}

// 다양한 결과 타입
type Result&lt;T&gt; =
  | { success: true; data: T }
  | { success: false; error: string };

function divide(a: number, b: number): Result&lt;number&gt; {
  if (b === 0) return { success: false, error: "0으로 나눌 수 없습니다" };
  return { success: true, data: a / b };
}</code></pre>
      </section>

      <!-- Slide 14: Intersection Types -->
      <section data-transition="slide" data-narration="교차 타입은 앰퍼샌드 기호로 여러 타입을 합쳐 모든 속성을 동시에 가진 타입을 만듭니다. 이 코드에서 Person은 HasName, HasAge, HasEmail 세 타입의 교차이므로, person 객체는 name, age, email 세 가지 속성을 모두 가져야 합니다. 유니온이 이것 또는 저것이라면, 교차는 이것 그리고 저것 모두를 의미합니다. interface extends와 비슷한 효과를 내지만, 타입 별칭으로 더 유연하게 조합할 수 있어 여러 타입을 즉석에서 합칠 때 편리합니다.">
        <h2>교차 타입 (Intersection Type)</h2>
        <p><code>&amp;</code>로 여러 타입을 합쳐 <strong>모든 속성을 동시에 가진</strong> 타입을 생성합니다.<br>
        <span style="font-size: 0.8em; color: #aaa;">유니온(<code>|</code>)이 "이것 또는 저것"이라면, 인터섹션(<code>&amp;</code>)은 "이것 그리고 저것 모두"입니다.</span></p>
        <pre><code class="language-typescript">// 기본 교차 타입
type HasName = { name: string };
type HasAge = { age: number };
type HasEmail = { email: string };

type Person = HasName &amp; HasAge &amp; HasEmail;

const person: Person = {
  name: "Kim",
  age: 25,
  email: "kim@example.com"
  // 3가지 타입의 모든 속성이 필요!
};

// interface extends와 비교
interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

interface SoftDeletable {
  deletedAt: Date | null;
  isDeleted: boolean;
}

// 교차 타입으로 조합
type BaseEntity = Timestamped &amp; SoftDeletable;

type User = BaseEntity &amp; {
  id: string;
  name: string;
  email: string;
};</code></pre>
      </section>

      <!-- Slide 15: Discriminated Unions -->
      <section data-transition="slide" data-narration="판별 유니온은 공통 속성의 리터럴 값으로 타입을 구분하는 핵심 패턴입니다. 이 코드에서 Action 타입의 각 멤버는 type이라는 공통 판별 속성을 가지며, switch문에서 type 값을 검사하면 해당 분기에서 payload의 정확한 타입이 자동으로 좁혀집니다. LOGIN 케이스에서는 username과 password에 접근할 수 있고, LOGOUT 케이스에서는 payload가 없음을 타입스크립트가 인식합니다. Redux 액션이나 상태 머신을 모델링할 때 필수적인 패턴입니다.">
        <h2>판별 유니온 (Discriminated Union)</h2>
        <div class="key-point">
          <h3>핵심 패턴</h3>
          <p>공통 판별 속성(discriminant, 구분자)으로 유니온 멤버를 구분하는 패턴입니다.<br>
          <span style="font-size: 0.9em;">택배 상자에 "종류" 라벨을 붙여서, 라벨만 보고 내용물의 타입을 알 수 있는 것과 같습니다.</span></p>
        </div>
        <pre><code class="language-typescript">// 판별 속성: type (각 멤버마다 다른 리터럴 값을 가짐 -> 이걸로 구분)
type Action =
  | { type: "LOGIN"; payload: { username: string; password: string } }
  | { type: "LOGOUT" }
  | { type: "FETCH_DATA"; payload: { url: string } }
  | { type: "SET_ERROR"; payload: { message: string } };

// state: any는 예시를 간단히 하기 위한 것 (실제로는 구체적 타입 권장)
function reducer(state: any, action: Action) {
  switch (action.type) {
    case "LOGIN":
      // action.payload.username 접근 가능
      return { ...state, user: action.payload.username };
    case "LOGOUT":
      // payload 없음
      return { ...state, user: null };
    case "FETCH_DATA":
      // action.payload.url 접근 가능
      return { ...state, loading: true };
    case "SET_ERROR":
      // action.payload.message 접근 가능
      return { ...state, error: action.payload.message };
  }
}</code></pre>
      </section>

      <!-- Slide 16: Discriminated Unions - Real Example -->
      <section data-transition="slide" data-narration="판별 유니온의 실전 활용을 더 살펴봅시다. ApiResponse 제네릭 타입은 status 속성으로 loading, success, error 세 가지 상태를 구분하며, switch문에서 각 상태에 맞는 데이터에 안전하게 접근합니다. PaymentMethod는 결제 수단을 card, bank, mobile로 구분하여 각각 카드번호, 계좌정보, 전화번호 등 서로 다른 속성을 가집니다. 이처럼 판별 유니온은 API 응답 처리, 상태 관리, 폼 입력 타입 분기 등 실전에서 매우 빈번하게 사용되는 강력한 타입 안전 패턴입니다.">
        <h2>판별 유니온 실전 예제</h2>
        <pre><code class="language-typescript">// API 응답 타입 모델링
type ApiResponse&lt;T&gt; =
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string; retryAfter?: number };

function renderResponse&lt;T&gt;(response: ApiResponse&lt;T&gt;): string {
  switch (response.status) {
    case "loading":
      return "로딩 중...";
    case "success":
      return `데이터: ${JSON.stringify(response.data)}`;
    case "error":
      return `에러: ${response.error}`;
  }
}

// 결제 수단 모델링
type PaymentMethod =
  | { type: "card"; cardNumber: string; expiryDate: string }
  | { type: "bank"; bankName: string; accountNumber: string }
  | { type: "mobile"; phoneNumber: string; provider: string };

function processPayment(method: PaymentMethod): void {
  switch (method.type) {
    case "card":
      console.log(`카드 결제: ${method.cardNumber}`);
      break;
    case "bank":
      console.log(`계좌 이체: ${method.bankName} ${method.accountNumber}`);
      break;
    case "mobile":
      console.log(`모바일: ${method.provider} ${method.phoneNumber}`);
      break;
  }
}</code></pre>
      </section>

      <!-- Slide 17: Utility Types - Partial, Required -->
      <section data-transition="slide" data-narration="Partial 유틸리티 타입은 모든 속성을 선택적으로 만들어, 업데이트 함수에서 변경하고 싶은 속성만 전달할 수 있게 합니다. 이 코드에서 updateUser 함수는 Partial User 타입을 받아 name만 변경하거나 email만 변경하는 것이 가능합니다. 반면 Required는 모든 선택적 속성의 물음표를 제거하여 필수로 만듭니다. Config 인터페이스의 host, port, debug가 모두 선택적이지만, Required Config로 변환하면 세 속성 모두 반드시 제공해야 합니다.">
        <h2>유틸리티 타입 (Utility Type): Partial, Required</h2>
        <p style="font-size: 0.85em; color: #aaa;">유틸리티 타입이란 TypeScript가 기본 제공하는 "타입 변환 도구"입니다. 기존 타입을 변형해서 새 타입을 만듭니다.</p>
        <pre><code class="language-typescript">interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

// Partial&lt;T&gt; - 모든 속성을 선택적(?)으로 바꿈
type PartialUser = Partial&lt;User&gt;;
// { id?: string; name?: string; email?: string; age?: number; }

// 업데이트 함수에서 유용: 바꾸고 싶은 속성만 전달하면 됨
function updateUser(id: string, updates: Partial&lt;User&gt;): User {
  const user = getUserById(id);  // 기존 사용자 조회
  return { ...user, ...updates }; // 기존 값에 변경사항 덮어쓰기
}

updateUser("1", { name: "새 이름" });        // name만 변경 (나머지는 그대로)
updateUser("1", { email: "new@email.com" }); // email만 변경

// Required&lt;T&gt; - 모든 속성을 필수로 (선택적 ? 제거)
interface Config {
  host?: string;
  port?: number;
  debug?: boolean;
}

type RequiredConfig = Required&lt;Config&gt;;
// { host: string; port: number; debug: boolean; }

// 모든 설정이 확정된 최종 config
function startServer(config: Required&lt;Config&gt;): void {
  console.log(`${config.host}:${config.port}`);
}</code></pre>
      </section>

      <!-- Slide 18: Utility Types - Pick, Omit -->
      <section data-transition="slide" data-narration="Pick은 기존 타입에서 특정 속성만 골라 새 타입을 만들고, Omit은 특정 속성을 제외한 새 타입을 만듭니다. 이 코드에서 UserProfile은 User에서 id, name, email 세 속성만 선택하고, UserWithoutPassword는 password만 제외합니다. 실전에서 API 요청과 응답 타입을 분리할 때 핵심적으로 사용됩니다. CreateUserRequest는 생성에 필요한 속성만, UserResponse는 비밀번호를 제외한 속성만, UpdateUserRequest는 수정 가능한 속성을 선택적으로 조합합니다.">
        <h2>유틸리티 타입: Pick, Omit</h2>
        <pre><code class="language-typescript">interface User {
  id: string;
  name: string;
  email: string;
  password: string;
  createdAt: Date;
  updatedAt: Date;
}

// Pick&lt;T, K&gt; - 특정 속성만 골라내기 ("이것만 가져올래")
type UserProfile = Pick&lt;User, "id" | "name" | "email"&gt;;
// { id: string; name: string; email: string; } -- 3개만 선택

// Omit&lt;T, K&gt; - 특정 속성만 제외하기 ("이것만 빼줘")
type UserWithoutPassword = Omit&lt;User, "password"&gt;;
// { id: string; name: string; email: string; createdAt: Date; updatedAt: Date; }

// 실전 예: API 요청/응답 타입 분리
type CreateUserRequest = Pick&lt;User, "name" | "email" | "password"&gt;;
type UserResponse = Omit&lt;User, "password"&gt;;
type UpdateUserRequest = Partial&lt;Pick&lt;User, "name" | "email"&gt;&gt;;

// 조합 예시
function createUser(data: CreateUserRequest): UserResponse {
  const user: User = {
    ...data,
    id: generateId(),
    createdAt: new Date(),
    updatedAt: new Date()
  };
  // password를 제외하고 반환
  const { password, ...response } = user;
  return response;
}</code></pre>
      </section>

      <!-- Slide 19: More Utility Types -->
      <section data-transition="slide" data-narration="Record 유틸리티 타입은 키 타입과 값 타입을 지정하여 사전 형태의 객체 타입을 만듭니다. 이 코드에서 permissions는 Role 유니온의 각 값을 키로, 문자열 배열을 값으로 가지므로 admin, editor, viewer 세 키가 반드시 존재해야 합니다. Readonly는 모든 속성을 읽기 전용으로 만들어 config 객체의 port를 변경하려고 하면 컴파일 에러가 발생합니다. DeepReadonly는 재귀적으로 중첩 객체까지 모든 속성을 불변으로 만드는 고급 패턴입니다.">
        <h2>유틸리티 타입: Record, Readonly</h2>
        <pre><code class="language-typescript">// Record&lt;K, V&gt; - 키(K) 타입과 값(V) 타입으로 객체 타입 생성 (사전처럼)
type Role = "admin" | "editor" | "viewer";

const permissions: Record&lt;Role, string[]&gt; = {
  admin:  ["read", "write", "delete", "manage"],
  editor: ["read", "write"],
  viewer: ["read"]
};

// 점수판
type StudentScores = Record&lt;string, number&gt;;
const scores: StudentScores = {
  "홍길동": 95,
  "김철수": 88,
  "이영희": 92
};

// Readonly&lt;T&gt; - 모든 속성을 readonly로
interface Config {
  host: string;
  port: number;
}

const config: Readonly&lt;Config&gt; = {
  host: "localhost",
  port: 3000
};

config.port = 8080;  // Error! 모든 속성이 readonly

// 깊은 불변성을 위한 재귀 타입
type DeepReadonly&lt;T&gt; = {
  readonly [K in keyof T]: T[K] extends object ? DeepReadonly&lt;T[K]&gt; : T[K];
};</code></pre>
      </section>

      <!-- Slide 20: Practical Patterns -->
      <section data-transition="slide" data-narration="지금까지 배운 인터페이스, 타입 별칭, 유틸리티 타입을 종합적으로 활용하는 Entity 시스템 패턴입니다. BaseEntity에 공통 속성을 정의하고, User와 Post가 이를 확장합니다. CreateDTO 제네릭 타입은 Omit으로 BaseEntity의 키를 제거하여, id와 날짜 없이 생성 요청 타입을 만듭니다. UpdateDTO는 여기에 Partial을 적용하여 수정할 속성만 선택적으로 전달합니다. 이처럼 유틸리티 타입을 조합하면 반복 없이 CRUD 전체의 타입을 체계적으로 관리할 수 있습니다.">
        <h2>실전 패턴 종합</h2>
        <pre><code class="language-typescript">// 패턴: Entity 시스템
interface BaseEntity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

interface User extends BaseEntity {
  name: string;
  email: string;
  role: "admin" | "user";
}

interface Post extends BaseEntity {
  title: string;
  content: string;
  authorId: string;
  tags: string[];
  status: "draft" | "published" | "archived";
}

// Create 요청: id, 날짜는 서버에서 자동 생성하므로 제외
// DTO (Data Transfer Object): 데이터를 주고받을 때 사용하는 타입
type CreateDTO&lt;T extends BaseEntity&gt; = Omit&lt;T, keyof BaseEntity&gt;;
type UpdateDTO&lt;T extends BaseEntity&gt; = Partial&lt;CreateDTO&lt;T&gt;&gt;;

// 사용
type CreateUserDTO = CreateDTO&lt;User&gt;;
// { name: string; email: string; role: "admin" | "user"; }

type UpdatePostDTO = UpdateDTO&lt;Post&gt;;
// { title?: string; content?: string; authorId?: string;
//   tags?: string[]; status?: "draft" | "published" | "archived"; }</code></pre>
      </section>

      <!-- Slide 21: Summary -->
      <section data-transition="slide" data-narration="챕터 4를 정리하겠습니다. 인터페이스로 객체 구조를 정의하고 extends로 확장하며, 타입 별칭으로 유니온과 교차 타입을 표현했습니다. 판별 유니온으로 타입 안전한 분기를 구현하고, Partial, Pick, Omit, Record 같은 유틸리티 타입으로 기존 타입을 효율적으로 변형하는 방법을 학습했습니다. 가장 중요한 포인트는 인터페이스와 타입 별칭의 적절한 사용 구분과, 유틸리티 타입 조합으로 반복 없이 타입을 관리하는 것입니다.">
        <h2>Chapter 4 정리</h2>
        <table class="compare-table" style="font-size: 0.72em;">
          <thead>
            <tr>
              <th>개념</th>
              <th>문법</th>
              <th>용도</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>인터페이스</td><td><code>interface User { }</code></td><td>객체 구조 정의</td></tr>
            <tr><td>선택적 속성</td><td><code>name?: string</code></td><td>생략 가능한 속성</td></tr>
            <tr><td>읽기 전용</td><td><code>readonly id: string</code></td><td>불변 속성</td></tr>
            <tr><td>인덱스 시그니처</td><td><code>[key: string]: T</code></td><td>동적 키</td></tr>
            <tr><td>extends</td><td><code>interface B extends A</code></td><td>확장</td></tr>
            <tr><td>타입 별칭</td><td><code>type Point = { }</code></td><td>유니온, 교차 등</td></tr>
            <tr><td>교차 타입</td><td><code>A &amp; B</code></td><td>타입 합치기</td></tr>
            <tr><td>판별 유니온</td><td><code>{ type: "x" } | { type: "y" }</code></td><td>안전한 분기</td></tr>
            <tr><td>Partial/Required</td><td><code>Partial&lt;T&gt;</code></td><td>선택적/필수 변환</td></tr>
            <tr><td>Pick/Omit</td><td><code>Pick&lt;T, K&gt;</code></td><td>속성 선택/제외</td></tr>
            <tr><td>Record</td><td><code>Record&lt;K, V&gt;</code></td><td>키-값 타입 객체</td></tr>
          </tbody>
        </table>
      </section>

      <!-- Slide 22: Next Chapter -->
      <section class="chapter-title" data-transition="zoom" data-narration="챕터 4를 마치겠습니다. 가장 중요한 포인트는 인터페이스로 객체 구조를 정의하고, 유틸리티 타입으로 기존 타입을 변형하여 반복 없이 관리하는 것입니다. 실전에서는 API 타입 설계 시 이 패턴들을 적극 활용하세요. 다음 챕터에서는 타입스크립트의 클래스를 학습하며, 접근 제어자, 추상 클래스, 인터페이스 구현 등 객체지향 프로그래밍의 핵심을 다룹니다.">
        <span class="chapter-number">Next</span>
        <h1>수고하셨습니다!</h1>
        <br>
        <p>
          <a href="05-classes.html" style="color: var(--ts-blue); font-size: 1.2em;">
            다음 챕터: 클래스 &#8594;
          </a>
        </p>
        <br>
        <p><a href="../index.html" style="color: #888; font-size: 0.7em;">&#8592; 목차로 돌아가기</a></p>
      </section>

    </div>
  </div>

  <div class="nav-footer">
    <a href="../index.html" style="color: #888;">TypeScript 완전 정복</a> | Chapter 04
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
  <script>
    Reveal.initialize({
      hash: true,
      slideNumber: true,
      plugins: [RevealHighlight],
      transition: 'slide',
      height: 700,
      center: false,
      margin: 0.04,
      minScale: 0.2,
      maxScale: 1.5,
      keyboard: {
        38: null,
        40: null
      },
      mouseWheel: false
    });

    // 위/아래 화살표 → 슬라이드 내 스크롤
    document.addEventListener('keydown', function(e) {
      if (e.keyCode === 38 || e.keyCode === 40) {
        var slide = Reveal.getCurrentSlide();
        if (!slide) return;
        var amount = 80;
        if (e.keyCode === 38) {
          slide.scrollTop -= amount;
        } else {
          slide.scrollTop += amount;
        }
        e.preventDefault();
        e.stopPropagation();
      }
    }, true);
  </script>
  <script src="js/narration.js"></script>
</body>
</html>
